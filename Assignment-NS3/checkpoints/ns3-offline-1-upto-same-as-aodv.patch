diff --git a/doc/installation/source/windows.rst b/doc/installation/source/windows.rst
deleted file mode 100644
index 883bf34f9..000000000
--- a/doc/installation/source/windows.rst
+++ /dev/null
@@ -1,734 +0,0 @@
-.. include:: replace.txt
-.. heading hierarchy:
-   ------------- Chapter
-   ************* Section (#.#)
-   ============= Subsection (#.#.#)
-   ############# Paragraph (no number)
-
-.. _Windows:
-
-Windows
--------
-
-This chapter describes installation steps specific to Microsoft Windows (version 10) and its
-derivatives (e.g. Home, Pro, Enterprise) using the Msys2/MinGW64 toolchain.
-
-There are two documented ways to use |ns3| on Windows:  the Windows Subsystem for Linux (WSL) or
-via the Msys2/MinGW64 toolchain.  Both options are listed below; users may choose to install
-either WSL or the Msys2/MinGW64 toolchain (installing both is not required).
-
-.. note::
-  |ns3| is not fully compatible with Visual Studio IDE / MSVC compiler; only Visual Studio Code
-  editor, the Msys2/MinGW64 toolchain, and WSL, as explained below.
-
-.. _WSL2:
-
-Windows Subsystem for Linux
-***************************
-
-Windows Subsystem for Linux (WSL), particularly WSL2, can be used on Windows for |ns3|.  WSL2
-runs a real Linux kernel on Windows's Hyper-V hypervisor, providing 100% code compatibility with
-Linux and seamless integration with Windows.  VS Code has excellent support and integration with
-WSL, enabling Windows users to develop for ns-3 in a native environment. It is recommended to
-install the WSL extension in VS Code for this purpose.
-
-Users starting with WSL2 can follow the Linux installation instructions to fill out other
-package prerequisites.  Note that |ns3| emulation features using WSL2 are not tested/supported.
-
-For more information:
-
-* `WSL <https://learn.microsoft.com/en-us/windows/wsl/>`_
-* `Developing in WSL with VS Code <https://code.visualstudio.com/docs/remote/wsl>`_
-* `WSL tutorial <https://code.visualstudio.com/docs/remote/wsl-tutorial>`_
-
-.. _Windows 10 package prerequisites:
-
-Windows 10 package prerequisites
-********************************
-
-The following instructions are relevant to the ns-3.37 release and Windows 10.
-
-Installation of the Msys2 environment
-+++++++++++++++++++++++++++++++++++++
-
-.. _Msys2: https://www.msys2.org/
-
-The `Msys2`_ includes ports of Unix tools for Windows built with multiple toolchains,
-including: MinGW32, MinGW64, Clang64, UCRT.
-
-|ns3| has been tested with the  MinGW64 (GCC) toolchain.  MinGW32 is 32-bit, which |ns3| does
-not support.  The project's Windows maintainer has tested Clang64 unsuccessfully, and has
-not tested the UCRT toolchain (which may work).
-
-The `Msys2`_ installer can be found on their site.
-Msys2 will be installed by default in the ``C:\msys64`` directory.
-
-The next required step is adding the binaries directories from the MinGW64 toolchain and generic Msys2 tools
-to the PATH environment variable. This can be accomplished via the GUI (search for system environment variable),
-or via the following command (assuming it was installed to the default directory):
-
-.. sourcecode:: console
-
-    C:\> setx PATH "C:\msys64\mingw64\bin;C:\msys64\usr\bin;%PATH%;" /m
-
-Note: if the MinGW64 binary directory doesn't precede the Windows/System32 directory (already in ``%PATH%``),
-the documentation build will fail since Windows has a conflicting ``convert`` command (FAT-to-NTFS). Similarly,
-if the Msys64 binary directory doesn't precede the Windows/System2 directory, running the ``bash`` command will
-result in Windows trying to run the Windows Subsystem for Linux (WSL) bash shell.
-
-Accessing the MinGW64 shell
-+++++++++++++++++++++++++++
-
-After installing Msys2 and adding the binary directories to the ``PATH``, we can access the Unix-like MinGW64 shell
-and use the Pacman package manager.
-
-The Pacman package manager is similar to the one used by Arch Linux, and can be accessed via one of the Msys2 shells.
-In this case, we will be using the MinGW64 shell. We can take this opportunity to update the package cache and packages.
-
-.. sourcecode:: console
-
-    C:\ns-3-dev\> set MSYSTEM MINGW64
-    C:\ns-3-dev\> bash
-    /c/ns-3-dev/ MINGW64$ pacman -Syu
-
-Pacman will request you to close the shell and re-open it to proceed after the upgrade.
-
-
-Minimal requirements for C++ (release)
-++++++++++++++++++++++++++++++++++++++
-
-This is the minimal set of packages needed to run ns-3 C++ programs from a released tarball.
-
-.. sourcecode:: console
-
-    /c/ns-3-dev/ MINGW64$ pacman -S \
-    mingw-w64-x86_64-toolchain \
-    mingw-w64-x86_64-cmake \
-    mingw-w64-x86_64-ninja \
-    mingw-w64-x86_64-grep \
-    mingw-w64-x86_64-sed \
-    mingw-w64-x86_64-python
-
-
-Netanim animator
-++++++++++++++++
-
-Qt5 development tools are needed for Netanim animator. Qt4 will also work but we have migrated to qt5.
-
-.. sourcecode:: console
-
-    /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-qt5 git
-
-
-Support for MPI-based distributed emulation
-+++++++++++++++++++++++++++++++++++++++++++
-
-The MPI setup requires two parts.
-
-The first part is the Microsoft MPI SDK required to build the MPI applications,
-which is distributed via Msys2.
-
-.. sourcecode:: console
-
-    /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-msmpi
-
-.. _Microsoft MPI: https://www.microsoft.com/en-us/download/details.aspx?id=100593
-
-The second part is the `Microsoft MPI`_ executors (mpiexec, mpirun) package,
-which is distributed as an installable (``msmpisetup.exe``).
-
-After installing it, the path containing the executors also need to be included to ``PATH``
-environment variable of the Windows and/or the MinGW64 shell, depending on whether
-you want to run MPI programs in either shell or both of them.
-
-.. sourcecode:: console
-
-    C:\ns-3-dev\> setx PATH "%PATH%;C:\Program Files\Microsoft MPI\Bin" /m
-    C:\ns-3-dev\> set MSYSTEM MINGW64
-    C:\ns-3-dev\> bash
-    /c/ns-3-dev/ MINGW64$ echo "export PATH=$PATH:/c/Program\ Files/Microsoft\ MPI/Bin" >> ~/.bashrc
-
-Debugging
-+++++++++
-
-GDB is installed along with the mingw-w64-x86_64-toolchain package.
-
-Doxygen and related inline documentation
-++++++++++++++++++++++++++++++++++++++++
-
-To build the Doxygen-based documentation, we need doxygen and a Latex toolchain.
-Getting Doxygen from Msys2 is straightforward.
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-imagemagick mingw-w64-x86_64-doxygen mingw-w64-x86_64-graphviz mingw-w64-x86_64-texlive-full
-
-The ns-3 manual, models and tutorial
-++++++++++++++++++++++++++++++++++++
-
-These documents are written in reStructuredText for Sphinx (doc/tutorial, doc/manual, doc/models).
-The figures are typically written in Dia.
-
-The documents can be generated into multiple formats, one of them being pdf,
-which requires the same Latex setup for doxygen.
-
-Sphinx and Dia can be installed via Msys2's package manager:
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-python-sphinx mingw-w64-x86_64-dia mingw-w64-x86_64-texlive-full
-
-GNU Scientific Library (GSL)
-++++++++++++++++++++++++++++
-
-GSL is used to provide more accurate WiFi error models and can be installed with:
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-gsl
-
-Database support for statistics framework
-+++++++++++++++++++++++++++++++++++++++++
-
-SQLite3 is installed along with the mingw-w64-x86_64-toolchain package.
-
-
-Xml-based version of the config store
-+++++++++++++++++++++++++++++++++++++
-
-Requires libxml2 >= version 2.7, which can be installed with the following.
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-libxml2
-
-Support for openflow module
-+++++++++++++++++++++++++++
-
-Requires some boost libraries that can be installed with the following.
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-boost
-
-Support for click module
-+++++++++++++++++++++++++++
-
-Requires autotools, which can be installed with the following.
-
-.. sourcecode:: console
-
-  /c/ns-3-dev/ MINGW64$ pacman -S mingw-w64-x86_64-autotools
-
-Windows 10 Docker container
-***************************
-
-Docker containers are not as useful for Windows, since only Windows hosts can use them,
-however we add directions on how to use the Windows container and how to update the Docker
-image for reference.
-
-First, gather all dependencies previously mentioned to cover all supported features.
-Install them to a base directory for the container (e.g. ``C:\tools``).
-
-Save the following Dockerfile to the base directory.
-
-.. sourcecode:: docker
-
-    # It is really unfortunate we need a 16 GB base image just to get the installers working, but such is life
-    FROM mcr.microsoft.com/windows:20H2
-
-    # Copy the current host directory to the container
-    COPY .\\ C:/tools
-    WORKDIR C:\\tools
-
-    # Create temporary dir
-    RUN mkdir C:\\tools\\temp
-
-    # Export environment variables
-    RUN setx PATH "C:\\tools\\msys64\\mingw64\\bin;C:\\tools\\msys64\\usr\\bin;%PATH%" /m
-    RUN setx PATH "%PATH%;C:\\Program Files\\Microsoft MPI\\bin;C:\\tools\\dia\bin;C:\tools\texlive\2022\bin\win32" /m
-    RUN setx MSYSTEM "MINGW64" /m
-
-    # Install Msys2
-    RUN .\\msys2-x86_64-20220503.exe in --confirm-command --accept-messages --root C:\\tools\\msys64
-
-    # Update base packages
-    RUN C:\\tools\\msys64\\usr\\bin\\pacman -Syyuu --noconfirm
-
-    # Install base packages
-    RUN bash -c "echo export PATH=$PATH:/c/Program\ Files/Microsoft\ MPI/Bin >> /c/tools/msys64/home/$USER/.bashrc" && \
-        bash -c "echo export PATH=$PATH:/c/tools/dia/bin >> /c/tools/msys64/home/$USER/.bashrc" && \
-        bash -c "echo export PATH=$PATH:/c/tools/texlive/2022/bin/win32 >> /c/tools/msys64/home/$USER/.bashrc" && \
-        bash -c "pacman -S mingw-w64-x86_64-toolchain \
-                       mingw-w64-x86_64-cmake \
-                       mingw-w64-x86_64-ninja \
-                       mingw-w64-x86_64-grep \
-                       mingw-w64-x86_64-sed \
-                       mingw-w64-x86_64-qt5 \
-                       git \
-                       mingw-w64-x86_64-msmpi \
-                       mingw-w64-x86_64-uncrustify \
-                       mingw-w64-x86_64-imagemagick \
-                       mingw-w64-x86_64-doxygen \
-                       mingw-w64-x86_64-graphviz \
-                       mingw-w64-x86_64-python-sphinx \
-                       mingw-w64-x86_64-gsl \
-                       mingw-w64-x86_64-libxml2 \
-                       mingw-w64-x86_64-boost \
-                       --noconfirm"
-
-    # Install Microsoft MPI
-    RUN .\\msmpisetup.exe -unattend -force -full -verbose
-
-    # Install TexLive
-    RUN .\\install-tl-20220526\\install-tl-windows.bat --no-gui --lang en -profile .\\texlive.profile
-
-    # Move working directory to temp and start cmd
-    WORKDIR C:\\tools\\temp
-    ENTRYPOINT ["cmd"]
-
-Now you should be able to run ``docker build -t username/image .``.
-
-After building the container image, you should be able to use it:
-
-.. sourcecode:: console
-
-    $ docker run -it username/image
-    C:\tools\temp$ git clone https://gitlab.com/nsnam/ns-3-dev
-    C:\tools\temp$ cd ns-3-dev
-    C:\tools\temp\ns-3-dev$ python ns3 configure --enable-tests --enable-examples
-    C:\tools\temp\ns-3-dev$ python ns3 build
-    C:\tools\temp\ns-3-dev$ python test.py
-
-If testing succeeds, the container image can then be pushed to the Docker Hub using
-``docker push username/image``.
-
-
-Windows 10 Vagrant
-******************
-
-.. _VirtualBox: https://www.virtualbox.org/
-.. _Vagrant: https://developer.hashicorp.com/vagrant/docs
-.. _virtual machine: https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine
-.. _boxes available: https://vagrantcloud.com/boxes/search
-
-As an alternative to manually setting up all dependencies required by ns-3,
-one can use a pre-packaged `virtual machine`_. There are many ways to do that,
-but for automation, the most used certainly is `Vagrant`_.
-
-Vagrant supports multiple virtual machine providers, is available in all platforms and is
-fairly straightforward to use and configure.
-
-There are many `boxes available`_ offering guests operating systems such as BSD, Mac, Linux and Windows.
-
-Using the pre-packaged Vagrant box
-++++++++++++++++++++++++++++++++++
-
-The provider for the ns-3 Vagrant box is `VirtualBox`_.
-
-The reference Windows virtual machine can be downloaded via the following Vagrant command
-
-.. sourcecode:: console
-
-    ~/mingw64_test $ vagrant init gabrielcarvfer/ns3_win10_mingw64
-
-After that, a Vagrantfile will be created in the current directory (in this case, mingw64_test).
-
-The file can be modified to adjust the number of processors and memory available to the virtual machine (VM).
-
-.. sourcecode:: console
-
-    ~/mingw64_test $ cat Vagrantfile
-    # -*- mode: ruby -*-
-    # vi: set ft=ruby :
-
-    # All Vagrant configuration is done below. The "2" in Vagrant.configure
-    # configures the configuration version (we support older styles for
-    # backwards compatibility). Please don't change it unless you know what
-    # you're doing.
-    Vagrant.configure("2") do |config|
-    # The most common configuration options are documented and commented below.
-    # For a complete reference, please see the online documentation at
-    # https://docs.vagrantup.com.
-
-    # Every Vagrant development environment requires a box. You can search for
-    # boxes at https://vagrantcloud.com/search.
-    config.vm.box = "gabrielcarvfer/ns3_win10_mingw64"
-
-    # Disable automatic box update checking. If you disable this, then
-    # boxes will only be checked for updates when the user runs
-    # `vagrant box outdated`. This is not recommended.
-    # config.vm.box_check_update = false
-
-    # Create a forwarded port mapping which allows access to a specific port
-    # within the machine from a port on the host machine. In the example below,
-    # accessing "localhost:8080" will access port 80 on the guest machine.
-    # NOTE: This will enable public access to the opened port
-    # config.vm.network "forwarded_port", guest: 80, host: 8080
-
-    # Create a forwarded port mapping which allows access to a specific port
-    # within the machine from a port on the host machine and only allow access
-    # via 127.0.0.1 to disable public access
-    # config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1"
-
-    # Create a private network, which allows host-only access to the machine
-    # using a specific IP.
-    # config.vm.network "private_network", ip: "192.168.33.10"
-
-    # Create a public network, which generally matched to bridged network.
-    # Bridged networks make the machine appear as another physical device on
-    # your network.
-    # config.vm.network "public_network"
-
-    # Share an additional folder to the guest VM. The first argument is
-    # the path on the host to the actual folder. The second argument is
-    # the path on the guest to mount the folder. And the optional third
-    # argument is a set of non-required options.
-    # config.vm.synced_folder "../data", "/vagrant_data"
-
-    # Provider-specific configuration so you can fine-tune various
-    # backing providers for Vagrant. These expose provider-specific options.
-    # Example for VirtualBox:
-    #
-    # config.vm.provider "virtualbox" do |vb|
-    #   # Display the VirtualBox GUI when booting the machine
-    #   vb.gui = true
-    #
-    #   # Customize the amount of memory on the VM:
-    #   vb.memory = "1024"
-    # end
-    #
-    # View the documentation for the provider you are using for more
-    # information on available options.
-
-    # Enable provisioning with a shell script. Additional provisioners such as
-    # Ansible, Chef, Docker, Puppet and Salt are also available. Please see the
-    # documentation for more information about their specific syntax and use.
-    # config.vm.provision "shell", inline: <<-SHELL
-    #   apt-get update
-    #   apt-get install -y apache2
-    # SHELL
-    end
-
-We can uncomment the virtualbox provider block and change vCPUs and RAM.
-It is recommended never to match the number of vCPUs to the number of thread of the machine,
-or the host operating system can become unresponsive.
-For compilation workloads, it is recommended to allocate 1-2 GB of RAM per vCPU.
-
-.. _user Vagrantfile:
-
-.. sourcecode:: console
-
-    ~/mingw64_test/ $ cat Vagrantfile
-    # -*- mode: ruby -*-
-    # vi: set ft=ruby :
-    Vagrant.configure("2") do |config|
-    config.vm.box = "gabrielcarvfer/ns3_win10_mingw64"
-      config.vm.provider "virtualbox" do |vb|
-        vb.cpus = "8"
-        vb.memory = "8096" # 8GB of RAM
-      end
-    end
-
-After changing the settings, we can start the VM and login via ssh. The default password is "vagrant".
-
-.. sourcecode:: console
-
-    ~/mingw64_test/ $ vagrant up
-    ~/mingw64_test/ $ vagrant ssh
-    C:\Users\vagrant>
-
-
-We are now logged into the machine and ready to work. If you prefer to update the tools, get into the
-MinGW64 shell and run pacman.
-
-.. sourcecode:: console
-
-    C:\Users\vagrant\> set MSYSTEM MINGW64
-    C:\Users\vagrant\> bash
-    /c/Users/vagrant/ MINGW64$ pacman -Syu
-    /c/Users/vagrant/ MINGW64$ exit
-    C:\Users\vagrant\>
-
-At this point, we can clone ns-3 locally:
-
-.. sourcecode:: console
-
-    C:\Users\vagrant> git clone `https://gitlab.com/nsnam/ns-3-dev`
-    C:\Users\vagrant> cd ns-3-dev
-    C:\Users\vagrant\ns-3-dev> python3 ns3 configure --enable-tests --enable-examples --enable-mpi
-    C:\Users\vagrant\ns-3-dev> python3 test.py
-
-We can also access the ~/mingw64_test/ from the host machine, where the Vagrantfile resides, by accessing
-the synchronized folder C:\vagrant.
-If the Vagrantfile is in the host ns-3-dev directory, we can continue working on it.
-
-.. sourcecode:: console
-
-    C:\Users\vagrant> cd C:\vagrant
-    C:\vagrant\> python3 ns3 configure --enable-tests --enable-examples --enable-mpi
-    C:\vagrant\> python3 test.py
-
-If all the PATH variables were set for the MinGW64 shell, we can also use it instead of the
-default CMD shell.
-
-.. sourcecode:: console
-
-    C:\vagrant\> set MSYSTEM=MINGW64
-    C:\vagrant\> bash
-    /c/vagrant/ MINGW64$ ./ns3 clean
-    /c/vagrant/ MINGW64$ ./ns3 configure --enable-tests --enable-examples --enable-mpi
-    /c/vagrant/ MINGW64$ ./test.py
-
-To stop the Vagrant machine, we should close the SSH session then halt.
-
-.. sourcecode:: console
-
-    /c/vagrant/ MINGW64$ exit
-    C:\vagrant\> exit
-    ~/mingw64_test/ vagrant halt
-
-To destroy the machine (e.g. to restore the default settings), use the following.
-
-.. sourcecode:: console
-
-    vagrant destroy
-
-Packaging a new Vagrant box
-+++++++++++++++++++++++++++
-
-**BEWARE: DO NOT CHANGE THE SETTINGS MENTIONED ON A REAL MACHINE**
-
-**THE SETTINGS ARE MEANT FOR A DISPOSABLE VIRTUAL MACHINE**
-
-.. _Windows 10 ISO: https://www.microsoft.com/pt-br/software-download/windows10ISO
-
-Start by downloading the `Windows 10 ISO`_.
-
-Then install `VirtualBox`_.
-
-Configure a VirtualBox VM and use the Windows 10 ISO file as the install source.
-
-During the installation, create a local user named "vagrant" and set its password to "vagrant".
-
-Check for any Windows updates and install them.
-
-The following commands assume administrative permissions and a PowerShell shell.
-
-Install the VirtualBox guest extensions
-=======================================
-
-On the VirtualBox GUI, click on ``Devices->Insert Guest Additions CD Image...``
-to download the VirtualBox guest extensions ISO and mount it as a CD drive on the guest VM.
-
-Run the installer to enable USB-passthrough, folder syncing and others.
-
-After installing, unmount the drive by removing it from the VM. Click on ``Settings->Storage``,
-select the guest drive and remove it clicking the button with an red ``x``.
-
-Install the OpenSSH server
-==========================
-
-Open PowerShell and run the following to install OpenSSH server,
-then set it to start automatically and open the firewall ports.
-
-.. sourcecode:: console
-
-    Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
-    Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
-    Start-Service sshd
-    Set-Service -Name sshd -StartupType 'Automatic'
-    if (!(Get-NetFirewallRule -Name "OpenSSH-Server-In-TCP" -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) {
-        Write-Output "Firewall Rule 'OpenSSH-Server-In-TCP' does not exist, creating it..."
-        New-NetFirewallRule -Name 'OpenSSH-Server-In-TCP' -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22
-    } else {
-        Write-Output "Firewall rule 'OpenSSH-Server-In-TCP' has been created and exists."
-    }
-
-Enable essential services and disable unnecessary ones
-======================================================
-
-Ensure the following services are set to **automatic** from the Services panel(services.msc):
-
-    - Base Filtering Engine
-    - Remote Procedure Call (RPC)
-    - DCOM Server Process Launcher
-    - RPC Endpoint Mapper
-    - Windows Firewall
-
-Ensure the following services are set to **disabled** from the Services panel(services.msc):
-
-    - Windows Update
-    - Windows Update Remediation
-    - Windows Search
-
-The same can be accomplished via the command-line with the following commands:
-
-.. sourcecode:: console
-
-    Set-Service -Name BFE -StartupType 'Automatic'
-    Set-Service -Name RpcSs -StartupType 'Automatic'
-    Set-Service -Name DcomLaunch -StartupType 'Automatic'
-    Set-Service -Name RpcEptMapper -StartupType 'Automatic'
-    Set-Service -Name mpssvc -StartupType 'Automatic'
-    Set-Service -Name wuauserv -StartupType 'Disabled'
-    Set-Service -Name WaaSMedicSvc -StartupType 'Disabled'
-    Set-Service -Name WSearch -StartupType 'Disabled'
-
-Install the packages you need
-=============================
-
-In this step we install all the software required by ns-3, as listed in the Section `Windows 10 package prerequisites`_.
-
-Disable Windows Defender
-========================
-
-After installing everything, it should be safe to disable the Windows security.
-
-Enter in the Windows Security settings and disable "anti-tamper protection".
-It rollbacks changes to security settings periodically.
-
-Enter in the Group Policy Editor (gpedit.msc) and disable:
-
-    - Realtime protection
-    - Behavior monitoring
-    - Scanning of archives, removable drives, network files, scripts
-    - Windows defender
-
-
-The same can be accomplished with the following command-line commands.
-
-.. sourcecode:: console
-
-    Set-MpPreference -DisableArchiveScanning 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableBehaviorMonitoring 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableIntrusionPreventionSystem 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableIOAVProtection 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableRemovableDriveScanning 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableBlockAtFirstSeen 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableScanningMappedNetworkDrivesForFullScan 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableScanningNetworkFiles 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableScriptScanning 1 -ErrorAction SilentlyContinue
-    Set-MpPreference -DisableRealtimeMonitoring 1 -ErrorAction SilentlyContinue
-    Set-Service -Name WdNisSvc -StartupType 'Disabled'
-    Set-Service -Name WinDefend -StartupType 'Disabled'
-    Set-Service -Name Sense -StartupType 'Disabled'
-    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" -Name SpyNetReporting -Value 0
-    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" -Name SubmitSamplesConsent -Value 0
-    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Features" -Name TamperProtection -Value 4
-    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender" -Name DisableAntiSpyware -Value 1
-    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name DisableAntiSpyware -Value 1
-
-Note: the previous commands were an excerpt from the complete script in:
-https://github.com/jeremybeaume/tools/blob/master/disable-defender.ps1
-
-Turn off UAC notifications
-==========================
-
-The UAC notifications are the popups where you can give your OK to elevation to administrative privileges.
-It can be disabled via User Account Control Settings, or via the following commands.
-
-.. sourcecode:: console
-
-    reg ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f
-
-
-Change the strong password security Policy
-==========================================
-
-Open the Local Security Policy management window. Under Security Settings/Account Policy/Password Policy,
-disable the option saying "Password must meet complexity requirements".
-
-
-Testing
-=======
-
-After you reach this point, reboot your machine then log back in.
-
-Test if all your packages are working as expected.
-
-In the case of ns-3, try to enable all supported features, run the test.py and test-ns3.py suites.
-
-If everything works, then try to log in via SSH.
-
-If everything works, shut down the machine and prepare for packaging.
-
-The network interface configured should be a NAT. Other interfaces won't work correctly.
-
-Default Vagrantfile
-===================
-
-Vagrant can package VirtualBox VMs into Vagrant boxes without much more work.
-However, it still needs one more file to do that: the default Vagrantfile.
-
-This file will be used by Vagrant to configure the VM later on and how to connect to it.
-
-.. sourcecode:: ruby
-
-    # -*- mode: ruby -*-
-    # vi: set ft=ruby :
-
-    Vagrant.configure("2") do |config|
-    config.vm.box = "BOX_FILE.box" # name of the box
-    config.vm.communicator = "winssh" # indicate that we are talking to a windows box via ssh
-    config.vm.guest = :windows # indicate that the guest is a windows machine
-    config.vm.network :forwarded_port, guest: 3389, host: 3389, id: "rdp", auto_correct: true
-    config.ssh.password = "vagrant" # give the default password, so that it stops trying to use a .ssh key-pair
-    config.ssh.insert_key = false # let the user use a written password
-    config.ssh.keys_only = false
-    config.winssh.shell = "cmd" # select the default shell (could be cmd or powershell)
-      config.vm.provider :virtualbox do |v, override|
-          #v.gui = true # do not show the VirtualBox GUI if unset or set to false
-          v.customize ["modifyvm", :id, "--memory", 8096] # the default settings for the VM are 8GB of RAM
-          v.customize ["modifyvm", :id, "--cpus", 8] # the default settings for the VM are 8 vCPUs
-          v.customize ["modifyvm", :id, "--vram", 128] # 128 MB or vGPU RAM
-          v.customize ["modifyvm", :id, "--clipboard", "bidirectional"]
-          v.customize ["setextradata", "global", "GUI/SuppressMessages", "all" ]
-      end
-    end
-
-This Vagrantfile will be baked into the Vagrant box, and can be modified by the `user Vagrantfile`_.
-After writing the Vagrantfile, we can call the following command.
-
-.. sourcecode:: console
-
-    vagrant package --vagrantfile Vagrantfile --base VIRTUALBOX_VM_NAME --output BOX_FILE.box
-
-It will take an awful long time depending on your drive.
-
-After it finishes, we can add the box to test it.
-
-.. sourcecode:: console
-
-    vagrant box add BOX_NAME BOX_FILE
-    vagrant up BOX_NAME
-    vagrant ssh
-
-If it can connect to the box, you are ready to upload it to the Vagrant servers.
-
-Publishing the Vagrant box
-==========================
-
-Create an account in https://app.vagrantup.com/ or log in with yours.
-In the dashboard, you can create a new box named BOX_NAME or select an existing one to update.
-
-After you select your box, click to add a provider. Pick Virtualbox.
-Calculate the MD5 hash of your BOX_FILE.box and fill the field then click to proceed.
-
-Upload the box.
-
-Now you should be able to download your box from the Vagrant servers via the the following command.
-
-.. sourcecode:: console
-
-    vagrant init yourUserName/BOX_NAME
-    vagrant up
-    vagrant ssh
-
-More information on Windows packaging to Vagrant boxes is available here:
-
-    - https://www.vagrantup.com/docs/boxes/base
-    - https://www.vagrantup.com/docs/vagrantfile/machine_settings
-    - https://www.vagrantup.com/docs/vagrantfile/ssh_settings
-    - https://www.vagrantup.com/docs/vagrantfile/winssh_settings
-    - https://github.com/pghalliday/windows-vagrant-boxes
diff --git a/patch.sh b/patch.sh
new file mode 100644
index 000000000..9a8c231a9
--- /dev/null
+++ b/patch.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+if [ $# -lt 1 ]; then
+    echo "Usage: $0 suffix1 [suffix2 ...]"
+    exit 1
+fi
+
+# this is the commit id for version 3.43 original
+commitId="753817468d611239b1e3c2e272b2bed8ef1f580c"
+
+suffix=$(IFS="-"; echo "$*")
+git add --all
+git diff ${commitId} > "../ns3-offline-1-${suffix}.patch"
\ No newline at end of file
diff --git a/runner.sh b/runner.sh
new file mode 100644
index 000000000..77f75a603
--- /dev/null
+++ b/runner.sh
@@ -0,0 +1,61 @@
+#!/bin/bash
+
+# Arrays of values for each parameter
+nodeCounts=(20 40 70 100)
+packetsPerSecond=(100 200 300 400)
+nodeSpeeds=(5 10 15 20)
+
+# nodeCounts=(20)
+# packetsPerSecond=(100)
+# nodeSpeeds=(5)
+
+dir="./scratch/results"
+
+# Create a directory for results if it doesn't exist
+mkdir -p ${dir}
+rm -rf ${dir}/*
+
+# Get current timestamp for the run
+timestamp=$(date +"%Y%m%d_%H%M%S")
+
+# Create a log file
+log_file="${dir}/simulation_log_${timestamp}.txt"
+echo "Starting simulations at $(date)" > "$log_file"
+
+# Counter for tracking progress
+total_runs=$((${#nodeCounts[@]} * ${#packetsPerSecond[@]} * ${#nodeSpeeds[@]}))
+current_run=0
+
+# Iterate through all combinations
+for count in "${nodeCounts[@]}"; do
+    for pps in "${packetsPerSecond[@]}"; do
+        for speed in "${nodeSpeeds[@]}"; do
+            ((current_run++))
+            
+            # Create a descriptive name for this run
+            run_name="n${count}_p${pps}_s${speed}"
+            
+            echo "[$current_run/$total_runs] Running simulation with:"
+            echo "  Node Count: $count"
+            echo "  Packets/s: $pps"
+            echo "  Node Speed: $speed"
+            
+            # Log the start of this run
+            echo -e "\n=== Run $run_name started at $(date) ===" >> "$log_file"
+            
+            # Run the simulation and capture output
+            ./ns3 run "scratch/aodv-analysis --nodeCount=$count --packetsPerSecond=$pps --nodeSpeed=$speed" 
+            
+            # Log the completion
+            echo "=== Run $run_name completed at $(date) ===" >> "$log_file"
+            echo "Progress: $current_run/$total_runs simulations completed"
+            echo -e "\n"
+            
+            # Optional: add a small delay between runs to prevent system overload
+            sleep 1
+        done
+    done
+done
+
+echo "All simulations completed at $(date)" >> "$log_file"
+echo "All simulations completed! Check simulation_results directory for outputs."
diff --git a/src/raodv/CMakeLists.txt b/src/raodv/CMakeLists.txt
new file mode 100644
index 000000000..a211bb11c
--- /dev/null
+++ b/src/raodv/CMakeLists.txt
@@ -0,0 +1,31 @@
+build_lib(
+  LIBNAME raodv
+  SOURCE_FILES
+    helper/raodv-helper.cc
+    model/raodv-dpd.cc
+    model/raodv-id-cache.cc
+    model/raodv-neighbor.cc
+    model/raodv-packet.cc
+    model/raodv-routing-protocol.cc
+    model/raodv-rqueue.cc
+    model/raodv-rtable.cc
+  HEADER_FILES
+    helper/raodv-helper.h
+    model/raodv-dpd.h
+    model/raodv-id-cache.h
+    model/raodv-neighbor.h
+    model/raodv-packet.h
+    model/raodv-routing-protocol.h
+    model/raodv-rqueue.h
+    model/raodv-rtable.h
+  LIBRARIES_TO_LINK
+    ${libapplications}
+    ${libinternet-apps}
+    ${libwifi}
+  TEST_SOURCES
+    test/raodv-id-cache-test-suite.cc
+    test/raodv-regression.cc
+    test/raodv-test-suite.cc
+    test/loopback.cc
+    test/bug-772.cc
+)
diff --git a/src/raodv/doc/raodv.h b/src/raodv/doc/raodv.h
new file mode 100644
index 000000000..eb1c9f229
--- /dev/null
+++ b/src/raodv/doc/raodv.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef RAODV_H
+#define RAODV_H
+
+/**
+ * \defgroup raodv RAODV Routing
+ *
+ * This section documents the API of the ns-3 RAODV module. For a generic functional description,
+ * please refer to the ns-3 manual.
+ */
+
+#endif /* RAODV_H */
diff --git a/src/raodv/doc/raodv.rst b/src/raodv/doc/raodv.rst
new file mode 100644
index 000000000..295c83b34
--- /dev/null
+++ b/src/raodv/doc/raodv.rst
@@ -0,0 +1,134 @@
+.. include:: replace.txt
+
+Ad Hoc On-Demand Distance Vector (RAODV)
+---------------------------------------
+
+This model implements the base specification of the Ad Hoc On-Demand
+Distance Vector (RAODV) protocol. The implementation is based on
+:rfc:`3561`.
+
+The model was written by Elena Buchatskaia and Pavel Boyko of ITTP RAS,
+and is based on the ns-2 RAODV model developed by the CMU/MONARCH group
+and optimized and tuned by Samir Das and Mahesh Marina, University of
+Cincinnati, and also on the RAODV-UU implementation by Erik Nordström of
+Uppsala University.
+
+Model Description
+*****************
+
+The source code for the RAODV model lives in the directory `src/raodv`.
+
+Design
+++++++
+
+Class ``ns3::raodv::RoutingProtocol`` implements all functionality of
+service packet exchange and inherits from ``ns3::Ipv4RoutingProtocol``.
+The base class defines two virtual functions for packet routing and
+forwarding.  The first one, ``ns3::raodv::RouteOutput``, is used for
+locally originated packets, and the second one, ``ns3::raodv::RouteInput``,
+is used for forwarding and/or delivering received packets.
+
+Protocol operation depends on many adjustable parameters. Parameters for
+this functionality are attributes of ``ns3::raodv::RoutingProtocol``.
+Parameter default values are drawn from the RFC and allow the
+enabling/disabling protocol features, such as broadcasting HELLO messages,
+broadcasting data packets and so on.
+
+RAODV discovers routes on demand.  Therefore, the RAODV model buffers all
+packets while a route request packet (RREQ) is disseminated.
+A packet queue is implemented in raodv-rqueue.cc. A smart pointer to
+the packet, ``ns3::Ipv4RoutingProtocol::ErrorCallback``,
+``ns3::Ipv4RoutingProtocol::UnicastForwardCallback``, and the IP header
+are stored in this queue. The packet queue implements garbage collection
+of old packets and a queue size limit.
+
+The routing table implementation supports garbage collection of
+old entries and state machine, defined in the standard.
+It is implemented as a STL map container. The key is a destination IP address.
+
+Some elements of protocol operation aren't described in the RFC. These
+elements generally concern cooperation of different OSI model layers.
+The model uses the following heuristics:
+
+* This RAODV implementation can detect the presence of unidirectional
+  links and avoid them if necessary.  If the node the model receives an
+  RREQ for is a neighbor, the cause may be a unidirectional link.
+  This heuristic is taken from RAODV-UU implementation and can be disabled.
+* Protocol operation strongly depends on broken link detection mechanism.
+  The model implements two such heuristics.  First, this implementation
+  support HELLO messages. However HELLO messages are not a good way to
+  perform neighbor sensing in a wireless environment (at least not over
+  802.11). Therefore, one may experience bad performance when running over
+  wireless.  There are several reasons for this: 1) HELLO messages are
+  broadcasted. In 802.11, broadcasting is often done at a
+  lower bit rate than unicasting, thus HELLO messages can travel further
+  than unicast data. 2) HELLO messages are small, thus less prone to
+  bit errors than data transmissions, and 3) Broadcast transmissions are
+  not guaranteed to be bidirectional, unlike unicast transmissions.
+  Second, we use layer 2 feedback when possible. Link are considered to be
+  broken if frame transmission results in a transmission failure for all
+  retries. This mechanism is meant for active links and works faster than
+  the first method.
+
+The layer 2 feedback implementation relies on the ``TxErrHeader`` trace source,
+currently supported in AdhocWifiMac only.
+
+Scope and Limitations
++++++++++++++++++++++
+
+The model is for IPv4 only.  The following optional protocol optimizations
+are not implemented:
+
+#. Local link repair.
+#. RREP, RREQ and HELLO message extensions.
+
+These techniques require direct access to IP header, which contradicts
+the assertion from the RAODV RFC that RAODV works over UDP.  This model uses
+UDP for simplicity, hindering the ability to implement certain protocol
+optimizations. The model doesn't use low layer raw sockets because they
+are not portable.
+
+Future Work
++++++++++++
+
+No announced plans.
+
+..
+  References
+  ++++++++++
+
+..
+  Usage
+  *****
+
+..
+  Examples
+  ++++++++
+
+..
+  Helpers
+  +++++++
+
+..
+  Attributes
+  ++++++++++
+
+..
+  Tracing
+  +++++++
+
+..
+  Logging
+  +++++++
+
+..
+  Caveats
+  +++++++
+
+..
+  Validation
+  **********
+  Unit tests
+  ++++++++++
+  Larger-scale performance tests
+  ++++++++++++++++++++++++++++++
diff --git a/src/raodv/examples/CMakeLists.txt b/src/raodv/examples/CMakeLists.txt
new file mode 100644
index 000000000..90c0ef30d
--- /dev/null
+++ b/src/raodv/examples/CMakeLists.txt
@@ -0,0 +1,9 @@
+build_lib_example(
+  NAME raodv-example
+  SOURCE_FILES raodv-example.cc
+  LIBRARIES_TO_LINK
+    ${libwifi}
+    ${libinternet}
+    ${libraodv}
+    ${libinternet-apps}
+)
diff --git a/src/raodv/examples/raodv-example.cc b/src/raodv/examples/raodv-example.cc
new file mode 100644
index 000000000..3dafde49e
--- /dev/null
+++ b/src/raodv/examples/raodv-example.cc
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * This is an example script for RAODV manet routing protocol.
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "ns3/raodv-module.h"
+#include "ns3/core-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/network-module.h"
+#include "ns3/ping-helper.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/yans-wifi-helper.h"
+
+#include <cmath>
+#include <iostream>
+
+using namespace ns3;
+
+/**
+ * \defgroup raodv-examples RAODV Examples
+ * \ingroup raodv
+ * \ingroup examples
+ */
+
+/**
+ * \ingroup raodv-examples
+ * \ingroup examples
+ * \brief Test script.
+ *
+ * This script creates 1-dimensional grid topology and then ping last node from the first one:
+ *
+ * [10.0.0.1] <-- step --> [10.0.0.2] <-- step --> [10.0.0.3] <-- step --> [10.0.0.4]
+ *
+ * ping 10.0.0.4
+ *
+ * When 1/3 of simulation time has elapsed, one of the nodes is moved out of
+ * range, thereby breaking the topology.  By default, this will result in
+ * stopping ping replies reception after sequence number 33. If the step size is reduced
+ * to cover the gap, then also the following pings can be received.
+ */
+class RAodvExample
+{
+  public:
+    RAodvExample();
+    /**
+     * \brief Configure script parameters
+     * \param argc is the command line argument count
+     * \param argv is the command line arguments
+     * \return true on successful configuration
+     */
+    bool Configure(int argc, char** argv);
+    /// Run simulation
+    void Run();
+    /**
+     * Report results
+     * \param os the output stream
+     */
+    void Report(std::ostream& os);
+
+  private:
+    // parameters
+    /// Number of nodes
+    uint32_t size;
+    /// Distance between nodes, meters
+    double step;
+    /// Simulation time, seconds
+    double totalTime;
+    /// Write per-device PCAP traces if true
+    bool pcap;
+    /// Print routes if true
+    bool printRoutes;
+
+    // network
+    /// nodes used in the example
+    NodeContainer nodes;
+    /// devices used in the example
+    NetDeviceContainer devices;
+    /// interfaces used in the example
+    Ipv4InterfaceContainer interfaces;
+
+  private:
+    /// Create the nodes
+    void CreateNodes();
+    /// Create the devices
+    void CreateDevices();
+    /// Create the network
+    void InstallInternetStack();
+    /// Create the simulation applications
+    void InstallApplications();
+};
+
+int
+main(int argc, char** argv)
+{
+    RAodvExample test;
+    if (!test.Configure(argc, argv))
+    {
+        NS_FATAL_ERROR("Configuration failed. Aborted.");
+    }
+
+    test.Run();
+    test.Report(std::cout);
+    return 0;
+}
+
+//-----------------------------------------------------------------------------
+RAodvExample::RAodvExample()
+    : size(10),
+      step(50),
+      totalTime(100),
+      pcap(true),
+      printRoutes(true)
+{
+}
+
+bool
+RAodvExample::Configure(int argc, char** argv)
+{
+    // Enable RAODV logs by default. Comment this if too noisy
+    // LogComponentEnable("RAodvRoutingProtocol", LOG_LEVEL_ALL);
+
+    SeedManager::SetSeed(12345);
+    CommandLine cmd(__FILE__);
+
+    cmd.AddValue("pcap", "Write PCAP traces.", pcap);
+    cmd.AddValue("printRoutes", "Print routing table dumps.", printRoutes);
+    cmd.AddValue("size", "Number of nodes.", size);
+    cmd.AddValue("time", "Simulation time, s.", totalTime);
+    cmd.AddValue("step", "Grid step, m", step);
+
+    cmd.Parse(argc, argv);
+    return true;
+}
+
+void
+RAodvExample::Run()
+{
+    //  Config::SetDefault ("ns3::WifiRemoteStationManager::RtsCtsThreshold", UintegerValue (1)); //
+    //  enable rts cts all the time.
+    CreateNodes();
+    CreateDevices();
+    InstallInternetStack();
+    InstallApplications();
+
+    std::cout << "Starting simulation for " << totalTime << " s ...\n";
+
+    Simulator::Stop(Seconds(totalTime));
+    Simulator::Run();
+    Simulator::Destroy();
+}
+
+void
+RAodvExample::Report(std::ostream&)
+{
+}
+
+void
+RAodvExample::CreateNodes()
+{
+    std::cout << "Creating " << (unsigned)size << " nodes " << step << " m apart.\n";
+    nodes.Create(size);
+    // Name nodes
+    for (uint32_t i = 0; i < size; ++i)
+    {
+        std::ostringstream os;
+        os << "node-" << i;
+        Names::Add(os.str(), nodes.Get(i));
+    }
+    // Create static grid
+    MobilityHelper mobility;
+    mobility.SetPositionAllocator("ns3::GridPositionAllocator",
+                                  "MinX",
+                                  DoubleValue(0.0),
+                                  "MinY",
+                                  DoubleValue(0.0),
+                                  "DeltaX",
+                                  DoubleValue(step),
+                                  "DeltaY",
+                                  DoubleValue(0),
+                                  "GridWidth",
+                                  UintegerValue(size),
+                                  "LayoutType",
+                                  StringValue("RowFirst"));
+    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    mobility.Install(nodes);
+}
+
+void
+RAodvExample::CreateDevices()
+{
+    WifiMacHelper wifiMac;
+    wifiMac.SetType("ns3::AdhocWifiMac");
+    YansWifiPhyHelper wifiPhy;
+    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();
+    wifiPhy.SetChannel(wifiChannel.Create());
+    WifiHelper wifi;
+    wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
+                                 "DataMode",
+                                 StringValue("OfdmRate6Mbps"),
+                                 "RtsCtsThreshold",
+                                 UintegerValue(0));
+    devices = wifi.Install(wifiPhy, wifiMac, nodes);
+
+    if (pcap)
+    {
+        wifiPhy.EnablePcapAll(std::string("raodv"));
+    }
+}
+
+void
+RAodvExample::InstallInternetStack()
+{
+    RAodvHelper raodv;
+    // you can configure RAODV attributes here using raodv.Set(name, value)
+    InternetStackHelper stack;
+    stack.SetRoutingHelper(raodv); // has effect on the next Install ()
+    stack.Install(nodes);
+    Ipv4AddressHelper address;
+    address.SetBase("10.0.0.0", "255.0.0.0");
+    interfaces = address.Assign(devices);
+
+    if (printRoutes)
+    {
+        Ptr<OutputStreamWrapper> routingStream =
+            Create<OutputStreamWrapper>("raodv.routes", std::ios::out);
+        Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(8), routingStream);
+    }
+}
+
+void
+RAodvExample::InstallApplications()
+{
+    PingHelper ping(interfaces.GetAddress(size - 1));
+    ping.SetAttribute("VerboseMode", EnumValue(Ping::VerboseMode::VERBOSE));
+
+    ApplicationContainer p = ping.Install(nodes.Get(0));
+    p.Start(Seconds(0));
+    p.Stop(Seconds(totalTime) - Seconds(0.001));
+
+    // move node away
+    Ptr<Node> node = nodes.Get(size / 2);
+    Ptr<MobilityModel> mob = node->GetObject<MobilityModel>();
+    Simulator::Schedule(Seconds(totalTime / 3),
+                        &MobilityModel::SetPosition,
+                        mob,
+                        Vector(1e5, 1e5, 1e5));
+}
diff --git a/src/raodv/helper/raodv-helper.cc b/src/raodv/helper/raodv-helper.cc
new file mode 100644
index 000000000..adf0fa89e
--- /dev/null
+++ b/src/raodv/helper/raodv-helper.cc
@@ -0,0 +1,113 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 IITP RAS
+ * Copyright (c) 2024 Sheikh Azizul Hakim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on
+ *      NS-2 AODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      AODV-UU implementation by Erik Nordström of Uppsala University
+ *      http://core.it.uu.se/core/index.php/AODV-UU
+ *
+ *      A Reverse AODV Routing Protocol in Ad Hoc Mobile Networks
+ *      https://dl.ifip.org/db/conf/euc/eucw2006/KimTA06.pdf 
+ *
+ * Authors (AODV):      Elena Buchatskaia <borovkovaes@iitp.ru>
+ *                      Pavel Boyko <boyko@iitp.ru>
+ * Authors (R-AODV):    Sheikh Azizul Hakim <hakim@cse.buet.ac.bd>
+ */
+ 
+#include "raodv-helper.h"
+#include "ns3/raodv-routing-protocol.h"
+#include "ns3/node-list.h"
+#include "ns3/names.h"
+#include "ns3/ptr.h"
+#include "ns3/ipv4-list-routing.h"
+
+namespace ns3 {
+
+    RAodvHelper::RAodvHelper() :
+            Ipv4RoutingHelper() {
+        m_agentFactory.SetTypeId("ns3::raodv::RoutingProtocol");
+    }
+
+    RAodvHelper *
+    RAodvHelper::Copy(void) const {
+        return new RAodvHelper(*this);
+    }
+
+    Ptr <Ipv4RoutingProtocol>
+    RAodvHelper::Create(Ptr <Node> node) const {
+        Ptr <raodv::RoutingProtocol> agent = m_agentFactory.Create<raodv::RoutingProtocol>();
+        node->AggregateObject(agent);
+        return agent;
+    }
+
+    void
+    RAodvHelper::Set(std::string name, const AttributeValue &value) {
+        m_agentFactory.Set(name, value);
+    }
+
+    uint32_t RAodvHelper::getSizeOfControlPackets(NodeContainer nodes) {
+        Ptr<Node> node = nodes.Get(0);
+        Ptr <Ipv4> ipv4 = node->GetObject<Ipv4>();
+        NS_ASSERT_MSG(ipv4, "Ipv4 not installed on node");
+        Ptr <Ipv4RoutingProtocol> proto = ipv4->GetRoutingProtocol();
+        NS_ASSERT_MSG(proto, "Ipv4 routing not installed on node");
+
+        // this is giving error
+        return 64; // for now keeping it
+
+        // Ptr <raodv::RoutingProtocol> aodv = DynamicCast<raodv::RoutingProtocol>(proto);
+        // return aodv->getSizeOfControlPackets();
+    }
+
+    int64_t
+    RAodvHelper::AssignStreams(NodeContainer c, int64_t stream) {
+        int64_t currentStream = stream;
+        Ptr <Node> node;
+        for (NodeContainer::Iterator i = c.Begin(); i != c.End(); ++i) {
+            node = (*i);
+            Ptr <Ipv4> ipv4 = node->GetObject<Ipv4>();
+            NS_ASSERT_MSG(ipv4, "Ipv4 not installed on node");
+            Ptr <Ipv4RoutingProtocol> proto = ipv4->GetRoutingProtocol();
+            NS_ASSERT_MSG(proto, "Ipv4 routing not installed on node");
+            Ptr <raodv::RoutingProtocol> aodv = DynamicCast<raodv::RoutingProtocol>(proto);
+            if (aodv) {
+                currentStream += aodv->AssignStreams(currentStream);
+                continue;
+            }
+            // RAodv may also be in a list
+            Ptr <Ipv4ListRouting> list = DynamicCast<Ipv4ListRouting>(proto);
+            if (list) {
+                int16_t priority;
+                Ptr <Ipv4RoutingProtocol> listProto;
+                Ptr <raodv::RoutingProtocol> listRAodv;
+                for (uint32_t i = 0; i < list->GetNRoutingProtocols(); i++) {
+                    listProto = list->GetRoutingProtocol(i, priority);
+                    listRAodv = DynamicCast<raodv::RoutingProtocol>(listProto);
+                    if (listRAodv) {
+                        currentStream += listRAodv->AssignStreams(currentStream);
+                        break;
+                    }
+                }
+            }
+        }
+        return (currentStream - stream);
+    }
+
+}
diff --git a/src/raodv/helper/raodv-helper.h b/src/raodv/helper/raodv-helper.h
new file mode 100644
index 000000000..4a6f9a9f3
--- /dev/null
+++ b/src/raodv/helper/raodv-helper.h
@@ -0,0 +1,102 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 IITP RAS
+ * Copyright (c) 2024 Sheikh Azizul Hakim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on
+ *      NS-2 AODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      AODV-UU implementation by Erik Nordström of Uppsala University
+ *      http://core.it.uu.se/core/index.php/AODV-UU
+ *
+ *      A Reverse AODV Routing Protocol in Ad Hoc Mobile Networks
+ *      https://dl.ifip.org/db/conf/euc/eucw2006/KimTA06.pdf 
+ *
+ * Authors (AODV):      Elena Buchatskaia <borovkovaes@iitp.ru>
+ *                      Pavel Boyko <boyko@iitp.ru>
+ * Authors (R-AODV):    Sheikh Azizul Hakim <hakim@cse.buet.ac.bd>
+ */
+ 
+
+#ifndef RAODV_HELPER_H
+#define RAODV_HELPER_H
+
+#include "ns3/object-factory.h"
+#include "ns3/node.h"
+#include "ns3/node-container.h"
+#include "ns3/ipv4-routing-helper.h"
+
+namespace ns3 {
+/**
+ * \ingroup aodv
+ * \brief Helper class that adds RAODV routing to nodes.
+ */
+class RAodvHelper : public Ipv4RoutingHelper
+{
+public:
+  RAodvHelper ();
+
+  /**
+   * \returns pointer to clone of this RAodvHelper
+   *
+   * \internal
+   * This method is mainly for internal use by the other helpers;
+   * clients are expected to free the dynamic memory allocated by this method
+   */
+  RAodvHelper* Copy (void) const;
+
+  /**
+   * \param node the node on which the routing protocol will run
+   * \returns a newly-created routing protocol
+   *
+   * This method will be called by ns3::InternetStackHelper::Install
+   *
+   * \todo support installing RAODV on the subset of all available IP interfaces
+   */
+  virtual Ptr<Ipv4RoutingProtocol> Create (Ptr<Node> node) const;
+  /**
+   * \param name the name of the attribute to set
+   * \param value the value of the attribute to set.
+   *
+   * This method controls the attributes of ns3::aodv::RoutingProtocol
+   */
+  void Set (std::string name, const AttributeValue &value);
+  /**
+   * Assign a fixed random variable stream number to the random variables
+   * used by this model.  Return the number of streams (possibly zero) that
+   * have been assigned.  The Install() method of the InternetStackHelper
+   * should have previously been called by the user.
+   *
+   * \param stream first stream index to use
+   * \param c NodeContainer of the set of nodes for which RAODV
+   *          should be modified to use a fixed stream
+   * \return the number of stream indices assigned by this helper
+   */
+  int64_t AssignStreams (NodeContainer c, int64_t stream);
+
+private:
+  /** the factory to create RAODV routing object */
+  ObjectFactory m_agentFactory;
+
+    uint32_t getSizeOfControlPackets();
+
+    uint32_t getSizeOfControlPackets(NodeContainer nodes);
+};
+
+}
+
+#endif /* RAODV_HELPER_H */
diff --git a/src/raodv/model/raodv-dpd.cc b/src/raodv/model/raodv-dpd.cc
new file mode 100644
index 000000000..1dc548efd
--- /dev/null
+++ b/src/raodv/model/raodv-dpd.cc
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "raodv-dpd.h"
+
+namespace ns3
+{
+namespace raodv
+{
+
+bool
+DuplicatePacketDetection::IsDuplicate(Ptr<const Packet> p, const Ipv4Header& header)
+{
+    return m_idCache.IsDuplicate(header.GetSource(), p->GetUid());
+}
+
+void
+DuplicatePacketDetection::SetLifetime(Time lifetime)
+{
+    m_idCache.SetLifetime(lifetime);
+}
+
+Time
+DuplicatePacketDetection::GetLifetime() const
+{
+    return m_idCache.GetLifeTime();
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-dpd.h b/src/raodv/model/raodv-dpd.h
new file mode 100644
index 000000000..26d9f4e5b
--- /dev/null
+++ b/src/raodv/model/raodv-dpd.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef RAODV_DPD_H
+#define RAODV_DPD_H
+
+#include "raodv-id-cache.h"
+
+#include "ns3/ipv4-header.h"
+#include "ns3/nstime.h"
+#include "ns3/packet.h"
+
+namespace ns3
+{
+namespace raodv
+{
+/**
+ * \ingroup raodv
+ *
+ * \brief Helper class used to remember already seen packets and detect duplicates.
+ *
+ * Currently duplicate detection is based on unique packet ID given by Packet::GetUid ()
+ * This approach is known to be weak (ns3::Packet UID is an internal identifier and not intended for
+ * logical uniqueness in models) and should be changed.
+ */
+class DuplicatePacketDetection
+{
+  public:
+    /**
+     * Constructor
+     * \param lifetime the lifetime for added entries
+     */
+    DuplicatePacketDetection(Time lifetime)
+        : m_idCache(lifetime)
+    {
+    }
+
+    /**
+     * Check if the packet is a duplicate. If not, save information about this packet.
+     * \param p the packet to check
+     * \param header the IP header to check
+     * \returns true if duplicate
+     */
+    bool IsDuplicate(Ptr<const Packet> p, const Ipv4Header& header);
+    /**
+     * Set duplicate record lifetime
+     * \param lifetime the lifetime for duplicate records
+     */
+    void SetLifetime(Time lifetime);
+    /**
+     * Get duplicate record lifetime
+     * \returns the duplicate record lifetime
+     */
+    Time GetLifetime() const;
+
+  private:
+    /// Impl
+    IdCache m_idCache;
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODV_DPD_H */
diff --git a/src/raodv/model/raodv-id-cache.cc b/src/raodv/model/raodv-id-cache.cc
new file mode 100644
index 000000000..7f935f054
--- /dev/null
+++ b/src/raodv/model/raodv-id-cache.cc
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#include "raodv-id-cache.h"
+
+#include <algorithm>
+
+namespace ns3
+{
+namespace raodv
+{
+bool
+IdCache::IsDuplicate(Ipv4Address addr, uint32_t id)
+{
+    Purge();
+    for (auto i = m_idCache.begin(); i != m_idCache.end(); ++i)
+    {
+        if (i->m_context == addr && i->m_id == id)
+        {
+            return true;
+        }
+    }
+    UniqueId uniqueId = {addr, id, m_lifetime + Simulator::Now()};
+    m_idCache.push_back(uniqueId);
+    return false;
+}
+
+void
+IdCache::Purge()
+{
+    m_idCache.erase(remove_if(m_idCache.begin(), m_idCache.end(), IsExpired()), m_idCache.end());
+}
+
+uint32_t
+IdCache::GetSize()
+{
+    Purge();
+    return m_idCache.size();
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-id-cache.h b/src/raodv/model/raodv-id-cache.h
new file mode 100644
index 000000000..32f42ef2c
--- /dev/null
+++ b/src/raodv/model/raodv-id-cache.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef RAODV_ID_CACHE_H
+#define RAODV_ID_CACHE_H
+
+#include "ns3/ipv4-address.h"
+#include "ns3/simulator.h"
+
+#include <vector>
+
+namespace ns3
+{
+namespace raodv
+{
+/**
+ * \ingroup raodv
+ *
+ * \brief Unique packets identification cache used for simple duplicate detection.
+ */
+class IdCache
+{
+  public:
+    /**
+     * constructor
+     * \param lifetime the lifetime for added entries
+     */
+    IdCache(Time lifetime)
+        : m_lifetime(lifetime)
+    {
+    }
+
+    /**
+     * Check that entry (addr, id) exists in cache. Add entry, if it doesn't exist.
+     * \param addr the IP address
+     * \param id the cache entry ID
+     * \returns true if the pair exists
+     */
+    bool IsDuplicate(Ipv4Address addr, uint32_t id);
+    /// Remove all expired entries
+    void Purge();
+    /**
+     * \returns number of entries in cache
+     */
+    uint32_t GetSize();
+
+    /**
+     * Set lifetime for future added entries.
+     * \param lifetime the lifetime for entries
+     */
+    void SetLifetime(Time lifetime)
+    {
+        m_lifetime = lifetime;
+    }
+
+    /**
+     * Return lifetime for existing entries in cache
+     * \returns the lifetime
+     */
+    Time GetLifeTime() const
+    {
+        return m_lifetime;
+    }
+
+  private:
+    /// Unique packet ID
+    struct UniqueId
+    {
+        /// ID is supposed to be unique in single address context (e.g. sender address)
+        Ipv4Address m_context;
+        /// The id
+        uint32_t m_id;
+        /// When record will expire
+        Time m_expire;
+    };
+
+    /**
+     * \brief IsExpired structure
+     */
+    struct IsExpired
+    {
+        /**
+         * \brief Check if the entry is expired
+         *
+         * \param u UniqueId entry
+         * \return true if expired, false otherwise
+         */
+        bool operator()(const UniqueId& u) const
+        {
+            return (u.m_expire < Simulator::Now());
+        }
+    };
+
+    /// Already seen IDs
+    std::vector<UniqueId> m_idCache;
+    /// Default lifetime for ID records
+    Time m_lifetime;
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODV_ID_CACHE_H */
diff --git a/src/raodv/model/raodv-neighbor.cc b/src/raodv/model/raodv-neighbor.cc
new file mode 100644
index 000000000..f25d06b35
--- /dev/null
+++ b/src/raodv/model/raodv-neighbor.cc
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "raodv-neighbor.h"
+
+#include "ns3/log.h"
+#include "ns3/wifi-mac-header.h"
+
+#include <algorithm>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("RAodvNeighbors");
+
+namespace raodv
+{
+Neighbors::Neighbors(Time delay)
+    : m_ntimer(Timer::CANCEL_ON_DESTROY)
+{
+    m_ntimer.SetDelay(delay);
+    m_ntimer.SetFunction(&Neighbors::Purge, this);
+    m_txErrorCallback = MakeCallback(&Neighbors::ProcessTxError, this);
+}
+
+bool
+Neighbors::IsNeighbor(Ipv4Address addr)
+{
+    Purge();
+    for (auto i = m_nb.begin(); i != m_nb.end(); ++i)
+    {
+        if (i->m_neighborAddress == addr)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+Time
+Neighbors::GetExpireTime(Ipv4Address addr)
+{
+    Purge();
+    for (auto i = m_nb.begin(); i != m_nb.end(); ++i)
+    {
+        if (i->m_neighborAddress == addr)
+        {
+            return (i->m_expireTime - Simulator::Now());
+        }
+    }
+    return Seconds(0);
+}
+
+void
+Neighbors::Update(Ipv4Address addr, Time expire)
+{
+    for (auto i = m_nb.begin(); i != m_nb.end(); ++i)
+    {
+        if (i->m_neighborAddress == addr)
+        {
+            i->m_expireTime = std::max(expire + Simulator::Now(), i->m_expireTime);
+            if (i->m_hardwareAddress == Mac48Address())
+            {
+                i->m_hardwareAddress = LookupMacAddress(i->m_neighborAddress);
+            }
+            return;
+        }
+    }
+
+    NS_LOG_LOGIC("Open link to " << addr);
+    Neighbor neighbor(addr, LookupMacAddress(addr), expire + Simulator::Now());
+    m_nb.push_back(neighbor);
+    Purge();
+}
+
+/**
+ * \brief CloseNeighbor structure
+ */
+struct CloseNeighbor
+{
+    /**
+     * Check if the entry is expired
+     *
+     * \param nb Neighbors::Neighbor entry
+     * \return true if expired, false otherwise
+     */
+    bool operator()(const Neighbors::Neighbor& nb) const
+    {
+        return ((nb.m_expireTime < Simulator::Now()) || nb.close);
+    }
+};
+
+void
+Neighbors::Purge()
+{
+    if (m_nb.empty())
+    {
+        return;
+    }
+
+    CloseNeighbor pred;
+    if (!m_handleLinkFailure.IsNull())
+    {
+        for (auto j = m_nb.begin(); j != m_nb.end(); ++j)
+        {
+            if (pred(*j))
+            {
+                NS_LOG_LOGIC("Close link to " << j->m_neighborAddress);
+                m_handleLinkFailure(j->m_neighborAddress);
+            }
+        }
+    }
+    m_nb.erase(std::remove_if(m_nb.begin(), m_nb.end(), pred), m_nb.end());
+    m_ntimer.Cancel();
+    m_ntimer.Schedule();
+}
+
+void
+Neighbors::ScheduleTimer()
+{
+    m_ntimer.Cancel();
+    m_ntimer.Schedule();
+}
+
+void
+Neighbors::AddArpCache(Ptr<ArpCache> a)
+{
+    m_arp.push_back(a);
+}
+
+void
+Neighbors::DelArpCache(Ptr<ArpCache> a)
+{
+    m_arp.erase(std::remove(m_arp.begin(), m_arp.end(), a), m_arp.end());
+}
+
+Mac48Address
+Neighbors::LookupMacAddress(Ipv4Address addr)
+{
+    Mac48Address hwaddr;
+    for (auto i = m_arp.begin(); i != m_arp.end(); ++i)
+    {
+        ArpCache::Entry* entry = (*i)->Lookup(addr);
+        if (entry != nullptr && (entry->IsAlive() || entry->IsPermanent()) && !entry->IsExpired())
+        {
+            hwaddr = Mac48Address::ConvertFrom(entry->GetMacAddress());
+            break;
+        }
+    }
+    return hwaddr;
+}
+
+void
+Neighbors::ProcessTxError(const WifiMacHeader& hdr)
+{
+    Mac48Address addr = hdr.GetAddr1();
+
+    for (auto i = m_nb.begin(); i != m_nb.end(); ++i)
+    {
+        if (i->m_hardwareAddress == addr)
+        {
+            i->close = true;
+        }
+    }
+    Purge();
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-neighbor.h b/src/raodv/model/raodv-neighbor.h
new file mode 100644
index 000000000..6c1de9d04
--- /dev/null
+++ b/src/raodv/model/raodv-neighbor.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef RAODVNEIGHBOR_H
+#define RAODVNEIGHBOR_H
+
+#include "ns3/arp-cache.h"
+#include "ns3/callback.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/simulator.h"
+#include "ns3/timer.h"
+
+#include <vector>
+
+namespace ns3
+{
+
+class WifiMacHeader;
+
+namespace raodv
+{
+
+class RoutingProtocol;
+
+/**
+ * \ingroup raodv
+ * \brief maintain list of active neighbors
+ */
+class Neighbors
+{
+  public:
+    /**
+     * constructor
+     * \param delay the delay time for purging the list of neighbors
+     */
+    Neighbors(Time delay);
+
+    /// Neighbor description
+    struct Neighbor
+    {
+        /// Neighbor IPv4 address
+        Ipv4Address m_neighborAddress;
+        /// Neighbor MAC address
+        Mac48Address m_hardwareAddress;
+        /// Neighbor expire time
+        Time m_expireTime;
+        /// Neighbor close indicator
+        bool close;
+
+        /**
+         * \brief Neighbor structure constructor
+         *
+         * \param ip Ipv4Address entry
+         * \param mac Mac48Address entry
+         * \param t Time expire time
+         */
+        Neighbor(Ipv4Address ip, Mac48Address mac, Time t)
+            : m_neighborAddress(ip),
+              m_hardwareAddress(mac),
+              m_expireTime(t),
+              close(false)
+        {
+        }
+    };
+
+    /**
+     * Return expire time for neighbor node with address addr, if exists, else return 0.
+     * \param addr the IP address of the neighbor node
+     * \returns the expire time for the neighbor node
+     */
+    Time GetExpireTime(Ipv4Address addr);
+    /**
+     * Check that node with address addr is neighbor
+     * \param addr the IP address to check
+     * \returns true if the node with IP address is a neighbor
+     */
+    bool IsNeighbor(Ipv4Address addr);
+    /**
+     * Update expire time for entry with address addr, if it exists, else add new entry
+     * \param addr the IP address to check
+     * \param expire the expire time for the address
+     */
+    void Update(Ipv4Address addr, Time expire);
+    /// Remove all expired entries
+    void Purge();
+    /// Schedule m_ntimer.
+    void ScheduleTimer();
+
+    /// Remove all entries
+    void Clear()
+    {
+        m_nb.clear();
+    }
+
+    /**
+     * Add ARP cache to be used to allow layer 2 notifications processing
+     * \param a pointer to the ARP cache to add
+     */
+    void AddArpCache(Ptr<ArpCache> a);
+    /**
+     * Don't use given ARP cache any more (interface is down)
+     * \param a pointer to the ARP cache to delete
+     */
+    void DelArpCache(Ptr<ArpCache> a);
+
+    /**
+     * Get callback to ProcessTxError
+     * \returns the callback function
+     */
+    Callback<void, const WifiMacHeader&> GetTxErrorCallback() const
+    {
+        return m_txErrorCallback;
+    }
+
+    /**
+     * Set link failure callback
+     * \param cb the callback function
+     */
+    void SetCallback(Callback<void, Ipv4Address> cb)
+    {
+        m_handleLinkFailure = cb;
+    }
+
+    /**
+     * Get link failure callback
+     * \returns the link failure callback
+     */
+    Callback<void, Ipv4Address> GetCallback() const
+    {
+        return m_handleLinkFailure;
+    }
+
+  private:
+    /// link failure callback
+    Callback<void, Ipv4Address> m_handleLinkFailure;
+    /// TX error callback
+    Callback<void, const WifiMacHeader&> m_txErrorCallback;
+    /// Timer for neighbor's list. Schedule Purge().
+    Timer m_ntimer;
+    /// vector of entries
+    std::vector<Neighbor> m_nb;
+    /// list of ARP cached to be used for layer 2 notifications processing
+    std::vector<Ptr<ArpCache>> m_arp;
+
+    /**
+     * Find MAC address by IP using list of ARP caches
+     *
+     * \param addr the IP address to lookup
+     * \returns the MAC address for the IP address
+     */
+    Mac48Address LookupMacAddress(Ipv4Address addr);
+    /**
+     * Process layer 2 TX error notification
+     * \param hdr header of the packet
+     */
+    void ProcessTxError(const WifiMacHeader& hdr);
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODVNEIGHBOR_H */
diff --git a/src/raodv/model/raodv-packet.cc b/src/raodv/model/raodv-packet.cc
new file mode 100644
index 000000000..636afe138
--- /dev/null
+++ b/src/raodv/model/raodv-packet.cc
@@ -0,0 +1,745 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 IITP RAS
+ * Copyright (c) 2024 Sheikh Azizul Hakim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on
+ *      NS-2 AODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      AODV-UU implementation by Erik Nordström of Uppsala University
+ *      http://core.it.uu.se/core/index.php/AODV-UU
+ *
+ *      A Reverse AODV Routing Protocol in Ad Hoc Mobile Networks
+ *      https://dl.ifip.org/db/conf/euc/eucw2006/KimTA06.pdf 
+ *
+ * Authors (AODV):      Elena Buchatskaia <borovkovaes@iitp.ru>
+ *                      Pavel Boyko <boyko@iitp.ru>
+ * Authors (R-AODV):    Sheikh Azizul Hakim <hakim@cse.buet.ac.bd>
+ */
+ 
+#include "raodv-packet.h"
+#include "ns3/address-utils.h"
+#include "ns3/packet.h"
+#include <string>
+
+using namespace std;
+
+namespace ns3 {
+namespace raodv {
+
+NS_OBJECT_ENSURE_REGISTERED (TypeHeader);
+
+TypeHeader::TypeHeader(MessageType t)
+        : m_type(t),
+          m_valid(true) {
+}
+
+TypeId
+TypeHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::TypeHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<TypeHeader>();
+    return tid;
+}
+
+TypeId
+TypeHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+TypeHeader::GetSerializedSize() const {
+    return 1;
+}
+
+void
+TypeHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8((uint8_t) m_type);
+}
+
+uint32_t
+TypeHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+
+    uint8_t type = i.ReadU8();
+    m_valid = true;
+    switch (type) {
+        case AODVTYPE_RREQ:
+        case AODVTYPE_RREP:
+        case AODVTYPE_RERR:
+        case AODVTYPE_RREP_ACK:
+        case AODVTYPE_REV_RREQ: {
+            m_type = (MessageType) type;
+            break;
+        }
+        default:
+            m_valid = false;
+    }
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+TypeHeader::Print(std::ostream &os) const {
+    switch (m_type) {
+        case AODVTYPE_RREQ: {
+            os << "RREQ";
+            break;
+        }
+        case AODVTYPE_RREP: {
+            os << "RREPly";
+            break;
+        }
+        case AODVTYPE_RERR: {
+            os << "RERR";
+            break;
+        }
+        case AODVTYPE_RREP_ACK: {
+            os << "RREP_ACK";
+            break;
+        }
+        case AODVTYPE_REV_RREQ: {
+            os << "REV_RREQ";
+            break;
+        }
+        default:
+            os << "UNKNOWN_TYPE";
+    }
+}
+
+bool
+TypeHeader::operator==(TypeHeader const &o) const {
+    return (m_type == o.m_type && m_valid == o.m_valid);
+}
+
+std::ostream &
+operator<<(std::ostream &os, TypeHeader const &h) {
+    h.Print(os);
+    return os;
+}
+
+//-----------------------------------------------------------------------------
+// RREQ
+//-----------------------------------------------------------------------------
+RreqHeader::RreqHeader(uint8_t flags, uint8_t reserved, uint8_t hopCount, uint32_t requestID, Ipv4Address dst,
+                       uint32_t dstSeqNo, Ipv4Address origin, uint32_t originSeqNo)
+        : m_flags(flags),
+          m_reserved(reserved),
+          m_hopCount(hopCount),
+          m_requestID(requestID),
+          m_dst(dst),
+          m_dstSeqNo(dstSeqNo),
+          m_origin(origin),
+          m_originSeqNo(originSeqNo) {
+}
+
+NS_OBJECT_ENSURE_REGISTERED (RreqHeader);
+
+TypeId
+RreqHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::RreqHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<RreqHeader>();
+    return tid;
+}
+
+TypeId
+RreqHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+RreqHeader::GetSerializedSize() const {
+    return 23;
+}
+
+void
+RreqHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8(m_flags);
+    i.WriteU8(m_reserved);
+    i.WriteU8(m_hopCount);
+    i.WriteHtonU32(m_requestID);
+    WriteTo(i, m_dst);
+    i.WriteHtonU32(m_dstSeqNo);
+    WriteTo(i, m_origin);
+    i.WriteHtonU32(m_originSeqNo);
+}
+
+uint32_t
+RreqHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+    m_flags = i.ReadU8();
+    m_reserved = i.ReadU8();
+    m_hopCount = i.ReadU8();
+    m_requestID = i.ReadNtohU32();
+    ReadFrom(i, m_dst);
+    m_dstSeqNo = i.ReadNtohU32();
+    ReadFrom(i, m_origin);
+    m_originSeqNo = i.ReadNtohU32();
+
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+RreqHeader::Print(std::ostream &os) const {
+    os << "RREQ ID " << m_requestID << " destination: ipv4 " << m_dst
+       << " sequence number " << m_dstSeqNo << " source: ipv4 "
+       << m_origin << " sequence number " << m_originSeqNo
+       << " flags:" << " Gratuitous RREP " << (*this).GetGratuitousRrep()
+       << " Destination only " << (*this).GetDestinationOnly()
+       << " Unknown sequence number " << (*this).GetUnknownSeqno();
+}
+
+std::ostream &
+operator<<(std::ostream &os, RreqHeader const &h) {
+    h.Print(os);
+    return os;
+}
+
+void
+RreqHeader::SetGratuitousRrep(bool f) {
+    if (f) {
+        m_flags |= (1 << 5);
+    } else {
+        m_flags &= ~(1 << 5);
+    }
+}
+
+bool
+RreqHeader::GetGratuitousRrep() const {
+    return (m_flags & (1 << 5));
+}
+
+void
+RreqHeader::SetDestinationOnly(bool f) {
+    if (f) {
+        m_flags |= (1 << 4);
+    } else {
+        m_flags &= ~(1 << 4);
+    }
+}
+
+bool
+RreqHeader::GetDestinationOnly() const {
+    return (m_flags & (1 << 4));
+}
+
+void
+RreqHeader::SetUnknownSeqno(bool f) {
+    if (f) {
+        m_flags |= (1 << 3);
+    } else {
+        m_flags &= ~(1 << 3);
+    }
+}
+
+bool
+RreqHeader::GetUnknownSeqno() const {
+    return (m_flags & (1 << 3));
+}
+
+bool
+RreqHeader::operator==(RreqHeader const &o) const {
+    return (m_flags == o.m_flags && m_reserved == o.m_reserved
+            && m_hopCount == o.m_hopCount && m_requestID == o.m_requestID
+            && m_dst == o.m_dst && m_dstSeqNo == o.m_dstSeqNo
+            && m_origin == o.m_origin && m_originSeqNo == o.m_originSeqNo);
+}
+
+
+// this is the new header 
+// it does not have the originSeqNo
+
+//-----------------------------------------------------------------------------
+// RevREQ
+//-----------------------------------------------------------------------------
+RevRreqHeader::RevRreqHeader(uint8_t flags, uint8_t reserved, uint8_t hopCount, uint32_t requestID, Ipv4Address dst,
+                       uint32_t dstSeqNo, Ipv4Address origin)
+        : m_flags(flags),
+          m_reserved(reserved),
+          m_hopCount(hopCount),
+          m_requestID(requestID),
+          m_dst(dst),
+          m_dstSeqNo(dstSeqNo),
+          m_origin(origin) {
+}
+
+NS_OBJECT_ENSURE_REGISTERED (RevRreqHeader);
+
+TypeId
+RevRreqHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::RevRreqHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<RevRreqHeader>();
+    return tid;
+}
+
+TypeId
+RevRreqHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+RevRreqHeader::GetSerializedSize() const {
+    return 23;
+}
+
+void
+RevRreqHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8(m_flags);
+    i.WriteU8(m_reserved);
+    i.WriteU8(m_hopCount);
+    i.WriteHtonU32(m_requestID);
+    WriteTo(i, m_dst);
+    i.WriteHtonU32(m_dstSeqNo);
+    WriteTo(i, m_origin);
+    i.WriteHtonU32(m_lifeTime);
+}
+
+uint32_t
+RevRreqHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+    m_flags = i.ReadU8();
+    m_reserved = i.ReadU8();
+    m_hopCount = i.ReadU8();
+    m_requestID = i.ReadNtohU32();
+    ReadFrom(i, m_dst);
+    m_dstSeqNo = i.ReadNtohU32();
+    ReadFrom(i, m_origin);
+    m_lifeTime = i.ReadNtohU32(); 
+
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+RevRreqHeader::Print(std::ostream &os) const {
+    os << "RevRREQ ID " << m_requestID << " destination: ipv4 " << m_dst
+       << " sequence number " << m_dstSeqNo << " source: ipv4 "
+       << m_origin
+       << " flags:" << " Gratuitous RREP " << (*this).GetGratuitousRrep()
+       << " Destination only " << (*this).GetDestinationOnly()
+       << " Unknown sequence number " << (*this).GetUnknownSeqno();
+}
+
+std::ostream &
+operator<<(std::ostream &os, RevRreqHeader const &h) {
+    h.Print(os);
+    return os;
+}
+
+void
+RevRreqHeader::SetGratuitousRrep(bool f) {
+    if (f) {
+        m_flags |= (1 << 5);
+    } else {
+        m_flags &= ~(1 << 5);
+    }
+}
+
+bool
+RevRreqHeader::GetGratuitousRrep() const {
+    return (m_flags & (1 << 5));
+}
+
+void
+RevRreqHeader::SetDestinationOnly(bool f) {
+    if (f) {
+        m_flags |= (1 << 4);
+    } else {
+        m_flags &= ~(1 << 4);
+    }
+}
+
+bool
+RevRreqHeader::GetDestinationOnly() const {
+    return (m_flags & (1 << 4));
+}
+
+void
+RevRreqHeader::SetUnknownSeqno(bool f) {
+    if (f) {
+        m_flags |= (1 << 3);
+    } else {
+        m_flags &= ~(1 << 3);
+    }
+}
+
+bool
+RevRreqHeader::GetUnknownSeqno() const {
+    return (m_flags & (1 << 3));
+}
+
+bool
+RevRreqHeader::operator==(RevRreqHeader const &o) const {
+    return (m_flags == o.m_flags && m_reserved == o.m_reserved
+            && m_hopCount == o.m_hopCount && m_requestID == o.m_requestID
+            && m_dst == o.m_dst && m_dstSeqNo == o.m_dstSeqNo
+            && m_origin == o.m_origin);
+}
+
+
+//-----------------------------------------------------------------------------
+// RREP
+//-----------------------------------------------------------------------------
+
+RrepHeader::RrepHeader(uint8_t prefixSize, uint8_t hopCount, Ipv4Address dst,
+                       uint32_t dstSeqNo, Ipv4Address origin, Time lifeTime)
+        : m_flags(0),
+          m_prefixSize(prefixSize),
+          m_hopCount(hopCount),
+          m_dst(dst),
+          m_dstSeqNo(dstSeqNo),
+          m_origin(origin) {
+    m_lifeTime = uint32_t(lifeTime.GetMilliSeconds());
+}
+
+NS_OBJECT_ENSURE_REGISTERED (RrepHeader);
+
+TypeId
+RrepHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::RrepHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<RrepHeader>();
+    return tid;
+}
+
+TypeId
+RrepHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+RrepHeader::GetSerializedSize() const {
+    return 19;
+}
+
+void
+RrepHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8(m_flags);
+    i.WriteU8(m_prefixSize);
+    i.WriteU8(m_hopCount);
+    WriteTo(i, m_dst);
+    i.WriteHtonU32(m_dstSeqNo);
+    WriteTo(i, m_origin);
+    i.WriteHtonU32(m_lifeTime);
+}
+
+uint32_t
+RrepHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+
+    m_flags = i.ReadU8();
+    m_prefixSize = i.ReadU8();
+    m_hopCount = i.ReadU8();
+    ReadFrom(i, m_dst);
+    m_dstSeqNo = i.ReadNtohU32();
+    ReadFrom(i, m_origin);
+    m_lifeTime = i.ReadNtohU32();
+
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+RrepHeader::Print(std::ostream &os) const {
+    os << "destination: ipv4 " << m_dst << " sequence number " << m_dstSeqNo;
+    if (m_prefixSize != 0) {
+        os << " prefix size " << m_prefixSize;
+    }
+    os << " source ipv4 " << m_origin << " lifetime " << m_lifeTime
+       << " acknowledgment required flag " << (*this).GetAckRequired();
+}
+
+void
+RrepHeader::SetLifeTime(Time t) {
+    m_lifeTime = t.GetMilliSeconds();
+}
+
+void
+RevRreqHeader::SetLifeTime(Time t) {
+    m_lifeTime = t.GetMilliSeconds();
+}
+
+Time
+RevRreqHeader::GetLifeTime() const {
+    Time t(MilliSeconds(m_lifeTime));
+    return t;
+}
+
+
+Time
+RrepHeader::GetLifeTime() const {
+    Time t(MilliSeconds(m_lifeTime));
+    return t;
+}
+
+void
+RrepHeader::SetAckRequired(bool f) {
+    if (f) {
+        m_flags |= (1 << 6);
+    } else {
+        m_flags &= ~(1 << 6);
+    }
+}
+
+bool
+RrepHeader::GetAckRequired() const {
+    return (m_flags & (1 << 6));
+}
+
+void
+RrepHeader::SetPrefixSize(uint8_t sz) {
+    m_prefixSize = sz;
+}
+
+uint8_t
+RrepHeader::GetPrefixSize() const {
+    return m_prefixSize;
+}
+
+bool
+RrepHeader::operator==(RrepHeader const &o) const {
+    return (m_flags == o.m_flags && m_prefixSize == o.m_prefixSize
+            && m_hopCount == o.m_hopCount && m_dst == o.m_dst && m_dstSeqNo == o.m_dstSeqNo
+            && m_origin == o.m_origin && m_lifeTime == o.m_lifeTime);
+}
+
+void
+RrepHeader::SetHello(Ipv4Address origin, uint32_t srcSeqNo, Time lifetime) {
+    m_flags = 0;
+    m_prefixSize = 0;
+    m_hopCount = 0;
+    m_dst = origin;
+    m_dstSeqNo = srcSeqNo;
+    m_origin = origin;
+    m_lifeTime = lifetime.GetMilliSeconds();
+}
+
+std::ostream &
+operator<<(std::ostream &os, RrepHeader const &h) {
+    h.Print(os);
+    return os;
+}
+
+//-----------------------------------------------------------------------------
+// RREP-ACK
+//-----------------------------------------------------------------------------
+
+RrepAckHeader::RrepAckHeader()
+        : m_reserved(0) {
+}
+
+NS_OBJECT_ENSURE_REGISTERED (RrepAckHeader);
+
+TypeId
+RrepAckHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::RrepAckHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<RrepAckHeader>();
+    return tid;
+}
+
+TypeId
+RrepAckHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+RrepAckHeader::GetSerializedSize() const {
+    return 1;
+}
+
+void
+RrepAckHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8(m_reserved);
+}
+
+uint32_t
+RrepAckHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+    m_reserved = i.ReadU8();
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+RrepAckHeader::Print(std::ostream &os) const {
+}
+
+bool
+RrepAckHeader::operator==(RrepAckHeader const &o) const {
+    return m_reserved == o.m_reserved;
+}
+
+std::ostream &
+operator<<(std::ostream &os, RrepAckHeader const &h) {
+    h.Print(os);
+    return os;
+}
+
+//-----------------------------------------------------------------------------
+// RERR
+//-----------------------------------------------------------------------------
+RerrHeader::RerrHeader()
+        : m_flag(0),
+          m_reserved(0) {
+}
+
+NS_OBJECT_ENSURE_REGISTERED (RerrHeader);
+
+TypeId
+RerrHeader::GetTypeId() {
+    static TypeId tid = TypeId("ns3::raodv::RerrHeader")
+            .SetParent<Header>()
+            .SetGroupName("Aodv")
+            .AddConstructor<RerrHeader>();
+    return tid;
+}
+
+TypeId
+RerrHeader::GetInstanceTypeId() const {
+    return GetTypeId();
+}
+
+uint32_t
+RerrHeader::GetSerializedSize() const {
+    return (3 + 8 * GetDestCount());
+}
+
+void
+RerrHeader::Serialize(Buffer::Iterator i) const {
+    i.WriteU8(m_flag);
+    i.WriteU8(m_reserved);
+    i.WriteU8(GetDestCount());
+    std::map<Ipv4Address, uint32_t>::const_iterator j;
+    for (j = m_unreachableDstSeqNo.begin(); j != m_unreachableDstSeqNo.end(); ++j) {
+        WriteTo(i, (*j).first);
+        i.WriteHtonU32((*j).second);
+    }
+}
+
+uint32_t
+RerrHeader::Deserialize(Buffer::Iterator start) {
+    Buffer::Iterator i = start;
+    m_flag = i.ReadU8();
+    m_reserved = i.ReadU8();
+    uint8_t dest = i.ReadU8();
+    m_unreachableDstSeqNo.clear();
+    Ipv4Address address;
+    uint32_t seqNo;
+    for (uint8_t k = 0; k < dest; ++k) {
+        ReadFrom(i, address);
+        seqNo = i.ReadNtohU32();
+        m_unreachableDstSeqNo.insert(std::make_pair(address, seqNo));
+    }
+
+    uint32_t dist = i.GetDistanceFrom(start);
+    NS_ASSERT(dist == GetSerializedSize());
+    return dist;
+}
+
+void
+RerrHeader::Print(std::ostream &os) const {
+    os << "Unreachable destination (ipv4 address, seq. number):";
+    std::map<Ipv4Address, uint32_t>::const_iterator j;
+    for (j = m_unreachableDstSeqNo.begin(); j != m_unreachableDstSeqNo.end(); ++j) {
+        os << (*j).first << ", " << (*j).second;
+    }
+    os << "No delete flag " << (*this).GetNoDelete();
+}
+
+void
+RerrHeader::SetNoDelete(bool f) {
+    if (f) {
+        m_flag |= (1 << 0);
+    } else {
+        m_flag &= ~(1 << 0);
+    }
+}
+
+bool
+RerrHeader::GetNoDelete() const {
+    return (m_flag & (1 << 0));
+}
+
+bool
+RerrHeader::AddUnDestination(Ipv4Address dst, uint32_t seqNo) {
+    if (m_unreachableDstSeqNo.find(dst) != m_unreachableDstSeqNo.end()) {
+        return true;
+    }
+
+    NS_ASSERT(GetDestCount() < 255); // can't support more than 255 destinations in single RERR
+    m_unreachableDstSeqNo.insert(std::make_pair(dst, seqNo));
+    return true;
+}
+
+bool
+RerrHeader::RemoveUnDestination(std::pair <Ipv4Address, uint32_t> &un) {
+    if (m_unreachableDstSeqNo.empty()) {
+        return false;
+    }
+    std::map<Ipv4Address, uint32_t>::iterator i = m_unreachableDstSeqNo.begin();
+    un = *i;
+    m_unreachableDstSeqNo.erase(i);
+    return true;
+}
+
+void
+RerrHeader::Clear() {
+    m_unreachableDstSeqNo.clear();
+    m_flag = 0;
+    m_reserved = 0;
+}
+
+bool
+RerrHeader::operator==(RerrHeader const &o) const {
+    if (m_flag != o.m_flag || m_reserved != o.m_reserved || GetDestCount() != o.GetDestCount()) {
+        return false;
+    }
+
+    std::map<Ipv4Address, uint32_t>::const_iterator j = m_unreachableDstSeqNo.begin();
+    std::map<Ipv4Address, uint32_t>::const_iterator k = o.m_unreachableDstSeqNo.begin();
+    for (uint8_t i = 0; i < GetDestCount(); ++i) {
+        if ((j->first != k->first) || (j->second != k->second)) {
+            return false;
+        }
+
+        j++;
+        k++;
+    }
+    return true;
+}
+
+std::ostream &
+operator<<(std::ostream &os, RerrHeader const &h) {
+    h.Print(os);
+    return os;
+}
+}
+}
diff --git a/src/raodv/model/raodv-packet.h b/src/raodv/model/raodv-packet.h
new file mode 100644
index 000000000..7c9d75eb9
--- /dev/null
+++ b/src/raodv/model/raodv-packet.h
@@ -0,0 +1,882 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 IITP RAS
+ * Copyright (c) 2024 Sheikh Azizul Hakim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on
+ *      NS-2 AODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      AODV-UU implementation by Erik Nordström of Uppsala University
+ *      http://core.it.uu.se/core/index.php/AODV-UU
+ *
+ *      A Reverse AODV Routing Protocol in Ad Hoc Mobile Networks
+ *      https://dl.ifip.org/db/conf/euc/eucw2006/KimTA06.pdf 
+ *
+ * Authors (AODV):      Elena Buchatskaia <borovkovaes@iitp.ru>
+ *                      Pavel Boyko <boyko@iitp.ru>
+ * Authors (R-AODV):    Sheikh Azizul Hakim <hakim@cse.buet.ac.bd>
+ */
+ 
+#ifndef RAODVPACKET_H
+#define RAODVPACKET_H
+
+#include <iostream>
+#include "ns3/header.h"
+#include "ns3/enum.h"
+#include "ns3/ipv4-address.h"
+#include <map>
+#include "ns3/nstime.h"
+
+namespace ns3 {
+namespace raodv {
+
+/**
+* \ingroup aodv
+* \brief MessageType enumeration
+*/
+enum MessageType {
+    AODVTYPE_RREQ = 1,   //!< AODVTYPE_RREQ
+    AODVTYPE_RREP = 2,   //!< AODVTYPE_RREP
+    AODVTYPE_RERR = 3,   //!< AODVTYPE_RERR
+    AODVTYPE_RREP_ACK = 4, //!< AODVTYPE_RREP_ACK
+    AODVTYPE_REV_RREQ = 5 //!< AODVTYPE_REV_RREQ
+};
+
+/**
+* \ingroup aodv
+* \brief AODV types
+*/
+class TypeHeader : public Header {
+public:
+    /**
+     * constructor
+     * \param t the AODV RREQ type
+     */
+    TypeHeader(MessageType t = AODVTYPE_RREQ);
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator start) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    /**
+     * \returns the type
+     */
+    MessageType Get() const {
+        return m_type;
+    }
+
+    /**
+     * Check that type if valid
+     * \returns true if the type is valid
+     */
+    bool IsValid() const {
+        return m_valid;
+    }
+
+    /**
+     * \brief Comparison operator
+     * \param o header to compare
+     * \return true if the headers are equal
+     */
+    bool operator==(TypeHeader const &o) const;
+
+private:
+    MessageType m_type; ///< type of the message
+    bool m_valid; ///< Indicates if the message is valid
+};
+
+/**
+  * \brief Stream output operator
+  * \param os output stream
+  * \return updated stream
+  */
+std::ostream &operator<<(std::ostream &os, TypeHeader const &h);
+
+/**
+* \ingroup aodv
+* \brief   Route Request (RREQ) Message Format
+  \verbatim
+  0                   1                   2                   3
+  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |     Type      |J|R|G|D|U|   Reserved          |   Hop Count   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                            RREQ ID                            |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Destination IP Address                     |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                  Destination Sequence Number                  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Originator IP Address                      |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                  Originator Sequence Number                   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  \endverbatim
+*/
+class RreqHeader : public Header {
+public:
+    /**
+     * constructor
+     *
+     * \param flags the message flags (0)
+     * \param reserved the reserved bits (0)
+     * \param hopCount the hop count
+     * \param requestID the request ID
+     * \param dst the destination IP address
+     * \param dstSeqNo the destination sequence number
+     * \param origin the origin IP address
+     * \param originSeqNo the origin sequence number
+     */
+    RreqHeader(uint8_t flags = 0, uint8_t reserved = 0, uint8_t hopCount = 0, uint32_t requestID = 0,
+               Ipv4Address dst = Ipv4Address(), uint32_t dstSeqNo = 0, Ipv4Address origin = Ipv4Address(),
+               uint32_t originSeqNo = 0);
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator start) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    // Fields
+    /**
+     * \brief Set the hop count
+     * \param count the hop count
+     */
+    void SetHopCount(uint8_t count) {
+        m_hopCount = count;
+    }
+
+    /**
+     * \brief Get the hop count
+     * \return the hop count
+     */
+    uint8_t GetHopCount() const {
+        return m_hopCount;
+    }
+
+    /**
+     * \brief Set the request ID
+     * \param id the request ID
+     */
+    void SetId(uint32_t id) {
+        m_requestID = id;
+    }
+
+    /**
+     * \brief Get the request ID
+     * \return the request ID
+     */
+    uint32_t GetId() const {
+        return m_requestID;
+    }
+
+    /**
+     * \brief Set the destination address
+     * \param a the destination address
+     */
+    void SetDst(Ipv4Address a) {
+        m_dst = a;
+    }
+
+    /**
+     * \brief Get the destination address
+     * \return the destination address
+     */
+    Ipv4Address GetDst() const {
+        return m_dst;
+    }
+
+    /**
+     * \brief Set the destination sequence number
+     * \param s the destination sequence number
+     */
+    void SetDstSeqno(uint32_t s) {
+        m_dstSeqNo = s;
+    }
+
+    /**
+     * \brief Get the destination sequence number
+     * \return the destination sequence number
+     */
+    uint32_t GetDstSeqno() const {
+        return m_dstSeqNo;
+    }
+
+    /**
+     * \brief Set the origin address
+     * \param a the origin address
+     */
+    void SetOrigin(Ipv4Address a) {
+        m_origin = a;
+    }
+
+    /**
+     * \brief Get the origin address
+     * \return the origin address
+     */
+    Ipv4Address GetOrigin() const {
+        return m_origin;
+    }
+
+    /**
+     * \brief Set the origin sequence number
+     * \param s the origin sequence number
+     */
+    void SetOriginSeqno(uint32_t s) {
+        m_originSeqNo = s;
+    }
+
+    /**
+     * \brief Get the origin sequence number
+     * \return the origin sequence number
+     */
+    uint32_t GetOriginSeqno() const {
+        return m_originSeqNo;
+    }
+
+    // Flags
+    /**
+     * \brief Set the gratuitous RREP flag
+     * \param f the gratuitous RREP flag
+     */
+    void SetGratuitousRrep(bool f);
+
+    /**
+     * \brief Get the gratuitous RREP flag
+     * \return the gratuitous RREP flag
+     */
+    bool GetGratuitousRrep() const;
+
+    /**
+     * \brief Set the Destination only flag
+     * \param f the Destination only flag
+     */
+    void SetDestinationOnly(bool f);
+
+    /**
+     * \brief Get the Destination only flag
+     * \return the Destination only flag
+     */
+    bool GetDestinationOnly() const;
+
+    /**
+     * \brief Set the unknown sequence number flag
+     * \param f the unknown sequence number flag
+     */
+    void SetUnknownSeqno(bool f);
+
+    /**
+     * \brief Get the unknown sequence number flag
+     * \return the unknown sequence number flag
+     */
+    bool GetUnknownSeqno() const;
+
+    /**
+     * \brief Comparison operator
+     * \param o RREQ header to compare
+     * \return true if the RREQ headers are equal
+     */
+    bool operator==(RreqHeader const &o) const;
+
+private:
+    uint8_t m_flags;          ///< |J|R|G|D|U| bit flags, see RFC
+    uint8_t m_reserved;       ///< Not used (must be 0)
+    uint8_t m_hopCount;       ///< Hop Count
+    uint32_t m_requestID;      ///< RREQ ID
+    Ipv4Address m_dst;            ///< Destination IP Address
+    uint32_t m_dstSeqNo;       ///< Destination Sequence Number
+    Ipv4Address m_origin;         ///< Originator IP Address
+    uint32_t m_originSeqNo;    ///< Source Sequence Number
+};
+
+
+/**
+* \ingroup aodv
+* \brief  Reverse Route Request (RRREQ) Message Format
+  \verbatim
+  0                   1                   2                   3
+  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |     Type      |J|R|G|D|U|   Reserved          |   Hop Count   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                      broadcast ID (??)                        |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Destination IP Address                     |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                  Destination Sequence Number                  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Originator IP Address                      |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                           Lifetime                            |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  \endverbatim
+*/
+class RevRreqHeader : public Header {
+public:
+    /**
+     * constructor
+     *
+     * \param flags the message flags (0)
+     * \param reserved the reserved bits (0)
+     * \param hopCount the hop count
+     * \param requestID the request ID
+     * \param dst the destination IP address
+     * \param dstSeqNo the destination sequence number
+     * \param origin the origin IP address
+     * \param originSeqNo the origin sequence number
+     */
+    RevRreqHeader(uint8_t flags = 0, uint8_t reserved = 0, uint8_t hopCount = 0
+            , uint32_t requestID = 0
+            , Ipv4Address dst = Ipv4Address(), uint32_t dstSeqNo = 0
+            , Ipv4Address origin = Ipv4Address());
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator start) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    // Fields
+    /**
+     * \brief Set the hop count
+     * \param count the hop count
+     */
+    void SetHopCount(uint8_t count) {
+        m_hopCount = count;
+    }
+
+    /**
+     * \brief Get the hop count
+     * \return the hop count
+     */
+    uint8_t GetHopCount() const {
+        return m_hopCount;
+    }
+
+    /**
+     * \brief Set the request ID
+     * \param id the request ID
+     */
+    void SetId(uint32_t id) {
+        m_requestID = id;
+    }
+
+    /**
+     * \brief Get the request ID
+     * \return the request ID
+     */
+    uint32_t GetId() const {
+        return m_requestID;
+    }
+
+    /**
+     * \brief Set the destination address
+     * \param a the destination address
+     */
+    void SetDst(Ipv4Address a) {
+        m_dst = a;
+    }
+
+    /**
+     * \brief Get the destination address
+     * \return the destination address
+     */
+    Ipv4Address GetDst() const {
+        return m_dst;
+    }
+
+    /**
+     * \brief Set the destination sequence number
+     * \param s the destination sequence number
+     */
+    void SetDstSeqno(uint32_t s) {
+        m_dstSeqNo = s;
+    }
+
+    /**
+     * \brief Get the destination sequence number
+     * \return the destination sequence number
+     */
+    uint32_t GetDstSeqno() const {
+        return m_dstSeqNo;
+    }
+
+    /**
+     * \brief Set the origin address
+     * \param a the origin address
+     */
+    void SetOrigin(Ipv4Address a) {
+        m_origin = a;
+    }
+
+    /**
+     * \brief Get the origin address
+     * \return the origin address
+     */
+    Ipv4Address GetOrigin() const {
+        return m_origin;
+    }
+
+    // Flags
+    /**
+     * \brief Set the gratuitous RREP flag
+     * \param f the gratuitous RREP flag
+     */
+    void SetGratuitousRrep(bool f);
+
+    /**
+     * \brief Get the gratuitous RREP flag
+     * \return the gratuitous RREP flag
+     */
+    bool GetGratuitousRrep() const;
+
+    /**
+     * \brief Set the Destination only flag
+     * \param f the Destination only flag
+     */
+    void SetDestinationOnly(bool f);
+
+    /**
+     * \brief Get the Destination only flag
+     * \return the Destination only flag
+     */
+    bool GetDestinationOnly() const;
+
+    /**
+     * \brief Set the unknown sequence number flag
+     * \param f the unknown sequence number flag
+     */
+    void SetUnknownSeqno(bool f);
+
+    /**
+     * \brief Get the unknown sequence number flag
+     * \return the unknown sequence number flag
+     */
+    bool GetUnknownSeqno() const;
+
+    /**
+     * \brief Comparison operator
+     * \param o RREQ header to compare
+     * \return true if the RREQ headers are equal
+     */
+    bool operator==(RevRreqHeader const &o) const;
+
+
+    /**
+     * \brief Set the lifetime
+     * \param t the lifetime
+     */
+    void SetLifeTime(Time t);
+
+    /**
+     * \brief Get the lifetime
+     * \return the lifetime
+     */
+    Time GetLifeTime() const;
+
+
+private:
+    uint8_t m_flags;               ///< |J|R|G|D|U| bit flags, see RFC
+    uint8_t m_reserved;            ///< Not used (must be 0)
+    uint8_t m_hopCount;            ///< Hop Count
+    uint32_t m_requestID;          ///< RREQ ID
+    Ipv4Address m_dst;             ///< Destination IP Address
+    uint32_t m_dstSeqNo;           ///< Destination Sequence Number
+    Ipv4Address m_origin;          ///< Originator IP Address
+    uint32_t m_lifeTime;           ///< Lifetime (in milliseconds)
+};
+
+/**
+  * \brief Stream output operator
+  * \param os output stream
+  * \return updated stream
+  */
+std::ostream &operator<<(std::ostream &os, RreqHeader const &);
+
+/**
+* \ingroup aodv
+* \brief Route Reply (RREP) Message Format
+  \verbatim
+  0                   1                   2                   3
+  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |     Type      |R|A|    Reserved     |Prefix Sz|   Hop Count   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                     Destination IP address                    |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                  Destination Sequence Number                  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Originator IP address                      |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                           Lifetime                            |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  \endverbatim
+*/
+class RrepHeader : public Header {
+public:
+    /**
+     * constructor
+     *
+     * \param prefixSize the prefix size (0)
+     * \param hopCount the hop count (0)
+     * \param dst the destination IP address
+     * \param dstSeqNo the destination sequence number
+     * \param origin the origin IP address
+     * \param lifetime the lifetime
+     */
+    RrepHeader(uint8_t prefixSize = 0, uint8_t hopCount = 0, Ipv4Address dst = Ipv4Address(), uint32_t dstSeqNo = 0,
+               Ipv4Address origin = Ipv4Address(), Time lifetime = MilliSeconds(0));
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator start) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    // Fields
+    /**
+     * \brief Set the hop count
+     * \param count the hop count
+     */
+    void SetHopCount(uint8_t count) {
+        m_hopCount = count;
+    }
+
+    /**
+     * \brief Get the hop count
+     * \return the hop count
+     */
+    uint8_t GetHopCount() const {
+        return m_hopCount;
+    }
+
+    /**
+     * \brief Set the destination address
+     * \param a the destination address
+     */
+    void SetDst(Ipv4Address a) {
+        m_dst = a;
+    }
+
+    /**
+     * \brief Get the destination address
+     * \return the destination address
+     */
+    Ipv4Address GetDst() const {
+        return m_dst;
+    }
+
+    /**
+     * \brief Set the destination sequence number
+     * \param s the destination sequence number
+     */
+    void SetDstSeqno(uint32_t s) {
+        m_dstSeqNo = s;
+    }
+
+    /**
+     * \brief Get the destination sequence number
+     * \return the destination sequence number
+     */
+    uint32_t GetDstSeqno() const {
+        return m_dstSeqNo;
+    }
+
+    /**
+     * \brief Set the origin address
+     * \param a the origin address
+     */
+    void SetOrigin(Ipv4Address a) {
+        m_origin = a;
+    }
+
+    /**
+     * \brief Get the origin address
+     * \return the origin address
+     */
+    Ipv4Address GetOrigin() const {
+        return m_origin;
+    }
+
+    /**
+     * \brief Set the lifetime
+     * \param t the lifetime
+     */
+    void SetLifeTime(Time t);
+
+    /**
+     * \brief Get the lifetime
+     * \return the lifetime
+     */
+    Time GetLifeTime() const;
+
+    // Flags
+    /**
+     * \brief Set the ack required flag
+     * \param f the ack required flag
+     */
+    void SetAckRequired(bool f);
+
+    /**
+     * \brief get the ack required flag
+     * \return the ack required flag
+     */
+    bool GetAckRequired() const;
+
+    /**
+     * \brief Set the prefix size
+     * \param sz the prefix size
+     */
+    void SetPrefixSize(uint8_t sz);
+
+    /**
+     * \brief Set the pefix size
+     * \return the prefix size
+     */
+    uint8_t GetPrefixSize() const;
+
+    /**
+     * Configure RREP to be a Hello message
+     *
+     * \param src the source IP address
+     * \param srcSeqNo the source sequence number
+     * \param lifetime the lifetime of the message
+     */
+    void SetHello(Ipv4Address src, uint32_t srcSeqNo, Time lifetime);
+
+    /**
+     * \brief Comparison operator
+     * \param o RREP header to compare
+     * \return true if the RREP headers are equal
+     */
+    bool operator==(RrepHeader const &o) const;
+
+private:
+    uint8_t m_flags;                  ///< A - acknowledgment required flag
+    uint8_t m_prefixSize;         ///< Prefix Size
+    uint8_t m_hopCount;         ///< Hop Count
+    Ipv4Address m_dst;              ///< Destination IP Address
+    uint32_t m_dstSeqNo;         ///< Destination Sequence Number
+    Ipv4Address m_origin;           ///< Source IP Address
+    uint32_t m_lifeTime;         ///< Lifetime (in milliseconds)
+};
+
+
+/**
+  * \brief Stream output operator
+  * \param os output stream
+  * \return updated stream
+  */
+std::ostream &operator<<(std::ostream &os, RrepHeader const &);
+
+/**
+* \ingroup aodv
+* \brief Route Reply Acknowledgment (RREP-ACK) Message Format
+  \verbatim
+  0                   1
+  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |     Type      |   Reserved    |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  \endverbatim
+*/
+class RrepAckHeader : public Header {
+public:
+    /// constructor
+    RrepAckHeader();
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator start) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    /**
+     * \brief Comparison operator
+     * \param o RREP header to compare
+     * \return true if the RREQ headers are equal
+     */
+    bool operator==(RrepAckHeader const &o) const;
+
+private:
+    uint8_t m_reserved; ///< Not used (must be 0)
+};
+
+/**
+  * \brief Stream output operator
+  * \param os output stream
+  * \return updated stream
+  */
+std::ostream &operator<<(std::ostream &os, RrepAckHeader const &);
+
+
+/**
+* \ingroup aodv
+* \brief Route Error (RERR) Message Format
+  \verbatim
+  0                   1                   2                   3
+  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |     Type      |N|          Reserved           |   DestCount   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |            Unreachable Destination IP Address (1)             |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |         Unreachable Destination Sequence Number (1)           |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
+  |  Additional Unreachable Destination IP Addresses (if needed)  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Additional Unreachable Destination Sequence Numbers (if needed)|
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  \endverbatim
+*/
+class RerrHeader : public Header {
+public:
+    /// constructor
+    RerrHeader();
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    TypeId GetInstanceTypeId() const;
+
+    uint32_t GetSerializedSize() const;
+
+    void Serialize(Buffer::Iterator i) const;
+
+    uint32_t Deserialize(Buffer::Iterator start);
+
+    void Print(std::ostream &os) const;
+
+    // No delete flag
+    /**
+     * \brief Set the no delete flag
+     * \param f the no delete flag
+     */
+    void SetNoDelete(bool f);
+
+    /**
+     * \brief Get the no delete flag
+     * \return the no delete flag
+     */
+    bool GetNoDelete() const;
+
+    /**
+     * \brief Add unreachable node address and its sequence number in RERR header
+     * \param dst unreachable IPv4 address
+     * \param seqNo unreachable sequence number
+     * \return false if we already added maximum possible number of unreachable destinations
+     */
+    bool AddUnDestination(Ipv4Address dst, uint32_t seqNo);
+
+    /**
+     * \brief Delete pair (address + sequence number) from REER header, if the number of unreachable destinations > 0
+     * \param un unreachable pair (address + sequence number)
+     * \return true on success
+     */
+    bool RemoveUnDestination(std::pair <Ipv4Address, uint32_t> &un);
+
+    /// Clear header
+    void Clear();
+
+    /**
+     * \returns number of unreachable destinations in RERR message
+     */
+    uint8_t GetDestCount() const {
+        return (uint8_t) m_unreachableDstSeqNo.size();
+    }
+
+    /**
+     * \brief Comparison operator
+     * \param o RERR header to compare
+     * \return true if the RERR headers are equal
+     */
+    bool operator==(RerrHeader const &o) const;
+
+private:
+    uint8_t m_flag;            ///< No delete flag
+    uint8_t m_reserved;        ///< Not used (must be 0)
+
+    /// List of Unreachable destination: IP addresses and sequence numbers
+    std::map <Ipv4Address, uint32_t> m_unreachableDstSeqNo;
+};
+
+/**
+  * \brief Stream output operator
+  * \param os output stream
+  * \return updated stream
+  */
+std::ostream &operator<<(std::ostream &os, RerrHeader const &);
+
+}  // namespace raodv
+}  // namespace ns3
+
+#endif /* AODVPACKET_H */
diff --git a/src/raodv/model/raodv-routing-protocol.cc b/src/raodv/model/raodv-routing-protocol.cc
new file mode 100644
index 000000000..44d49d685
--- /dev/null
+++ b/src/raodv/model/raodv-routing-protocol.cc
@@ -0,0 +1,2282 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#define NS_LOG_APPEND_CONTEXT                                                                      \
+    if (m_ipv4)                                                                                    \
+    {                                                                                              \
+        std::clog << "[node " << m_ipv4->GetObject<Node>()->GetId() << "] ";                       \
+    }
+
+#include "raodv-routing-protocol.h"
+
+#include "ns3/adhoc-wifi-mac.h"
+#include "ns3/boolean.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/log.h"
+#include "ns3/pointer.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/string.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/udp-header.h"
+#include "ns3/udp-l4-protocol.h"
+#include "ns3/udp-socket-factory.h"
+#include "ns3/wifi-mpdu.h"
+#include "ns3/wifi-net-device.h"
+
+#include <algorithm>
+#include <limits>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("RAodvRoutingProtocol");
+
+namespace raodv
+{
+NS_OBJECT_ENSURE_REGISTERED(RoutingProtocol);
+
+/// UDP Port for RAODV control traffic
+const uint32_t RoutingProtocol::RAODV_PORT = 654;
+
+/**
+ * \ingroup raodv
+ * \brief Tag used by RAODV implementation
+ */
+class DeferredRouteOutputTag : public Tag
+{
+  public:
+    /**
+     * \brief Constructor
+     * \param o the output interface
+     */
+    DeferredRouteOutputTag(int32_t o = -1)
+        : Tag(),
+          m_oif(o)
+    {
+    }
+
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId()
+    {
+        static TypeId tid = TypeId("ns3::raodv::DeferredRouteOutputTag")
+                                .SetParent<Tag>()
+                                .SetGroupName("RAodv")
+                                .AddConstructor<DeferredRouteOutputTag>();
+        return tid;
+    }
+
+    TypeId GetInstanceTypeId() const override
+    {
+        return GetTypeId();
+    }
+
+    /**
+     * \brief Get the output interface
+     * \return the output interface
+     */
+    int32_t GetInterface() const
+    {
+        return m_oif;
+    }
+
+    /**
+     * \brief Set the output interface
+     * \param oif the output interface
+     */
+    void SetInterface(int32_t oif)
+    {
+        m_oif = oif;
+    }
+
+    uint32_t GetSerializedSize() const override
+    {
+        return sizeof(int32_t);
+    }
+
+    void Serialize(TagBuffer i) const override
+    {
+        i.WriteU32(m_oif);
+    }
+
+    void Deserialize(TagBuffer i) override
+    {
+        m_oif = i.ReadU32();
+    }
+
+    void Print(std::ostream& os) const override
+    {
+        os << "DeferredRouteOutputTag: output interface = " << m_oif;
+    }
+
+  private:
+    /// Positive if output device is fixed in RouteOutput
+    int32_t m_oif;
+};
+
+NS_OBJECT_ENSURE_REGISTERED(DeferredRouteOutputTag);
+
+//-----------------------------------------------------------------------------
+RoutingProtocol::RoutingProtocol()
+    : m_rreqRetries(2),
+      m_ttlStart(1),
+      m_ttlIncrement(2),
+      m_ttlThreshold(7),
+      m_timeoutBuffer(2),
+      m_rreqRateLimit(10),
+      m_rerrRateLimit(10),
+      m_activeRouteTimeout(Seconds(3)),
+      m_netDiameter(35),
+      m_nodeTraversalTime(MilliSeconds(40)),
+      m_netTraversalTime(Time((2 * m_netDiameter) * m_nodeTraversalTime)),
+      m_pathDiscoveryTime(Time(2 * m_netTraversalTime)),
+      m_myRouteTimeout(Time(2 * std::max(m_pathDiscoveryTime, m_activeRouteTimeout))),
+      m_helloInterval(Seconds(1)),
+      m_allowedHelloLoss(2),
+      m_deletePeriod(Time(5 * std::max(m_activeRouteTimeout, m_helloInterval))),
+      m_nextHopWait(m_nodeTraversalTime + MilliSeconds(10)),
+      m_blackListTimeout(Time(m_rreqRetries * m_netTraversalTime)),
+      m_maxQueueLen(64),
+      m_maxQueueTime(Seconds(30)),
+      m_destinationOnly(false),
+      m_gratuitousReply(true),
+      m_enableHello(false),
+      m_routingTable(m_deletePeriod),
+      m_queue(m_maxQueueLen, m_maxQueueTime),
+      m_requestId(0),
+      m_seqNo(0),
+      m_rreqIdCache(m_pathDiscoveryTime),
+      m_dpd(m_pathDiscoveryTime),
+      m_nb(m_helloInterval),
+      m_rreqCount(0),
+      m_rerrCount(0),
+      m_htimer(Timer::CANCEL_ON_DESTROY),
+      m_rreqRateLimitTimer(Timer::CANCEL_ON_DESTROY),
+      m_rerrRateLimitTimer(Timer::CANCEL_ON_DESTROY),
+      m_lastBcastTime(Seconds(0))
+{
+    m_nb.SetCallback(MakeCallback(&RoutingProtocol::SendRerrWhenBreaksLinkToNextHop, this));
+}
+
+TypeId
+RoutingProtocol::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::raodv::RoutingProtocol")
+            .SetParent<Ipv4RoutingProtocol>()
+            .SetGroupName("RAodv")
+            .AddConstructor<RoutingProtocol>()
+            .AddAttribute("HelloInterval",
+                          "HELLO messages emission interval.",
+                          TimeValue(Seconds(1)),
+                          MakeTimeAccessor(&RoutingProtocol::m_helloInterval),
+                          MakeTimeChecker())
+            .AddAttribute("TtlStart",
+                          "Initial TTL value for RREQ.",
+                          UintegerValue(1),
+                          MakeUintegerAccessor(&RoutingProtocol::m_ttlStart),
+                          MakeUintegerChecker<uint16_t>())
+            .AddAttribute("TtlIncrement",
+                          "TTL increment for each attempt using the expanding ring search for RREQ "
+                          "dissemination.",
+                          UintegerValue(2),
+                          MakeUintegerAccessor(&RoutingProtocol::m_ttlIncrement),
+                          MakeUintegerChecker<uint16_t>())
+            .AddAttribute("TtlThreshold",
+                          "Maximum TTL value for expanding ring search, TTL = NetDiameter is used "
+                          "beyond this value.",
+                          UintegerValue(7),
+                          MakeUintegerAccessor(&RoutingProtocol::m_ttlThreshold),
+                          MakeUintegerChecker<uint16_t>())
+            .AddAttribute("TimeoutBuffer",
+                          "Provide a buffer for the timeout.",
+                          UintegerValue(2),
+                          MakeUintegerAccessor(&RoutingProtocol::m_timeoutBuffer),
+                          MakeUintegerChecker<uint16_t>())
+            .AddAttribute("RreqRetries",
+                          "Maximum number of retransmissions of RREQ to discover a route",
+                          UintegerValue(2),
+                          MakeUintegerAccessor(&RoutingProtocol::m_rreqRetries),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("RreqRateLimit",
+                          "Maximum number of RREQ per second.",
+                          UintegerValue(10),
+                          MakeUintegerAccessor(&RoutingProtocol::m_rreqRateLimit),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("RerrRateLimit",
+                          "Maximum number of RERR per second.",
+                          UintegerValue(10),
+                          MakeUintegerAccessor(&RoutingProtocol::m_rerrRateLimit),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("NodeTraversalTime",
+                          "Conservative estimate of the average one hop traversal time for packets "
+                          "and should include "
+                          "queuing delays, interrupt processing times and transfer times.",
+                          TimeValue(MilliSeconds(40)),
+                          MakeTimeAccessor(&RoutingProtocol::m_nodeTraversalTime),
+                          MakeTimeChecker())
+            .AddAttribute(
+                "NextHopWait",
+                "Period of our waiting for the neighbour's RREP_ACK = 10 ms + NodeTraversalTime",
+                TimeValue(MilliSeconds(50)),
+                MakeTimeAccessor(&RoutingProtocol::m_nextHopWait),
+                MakeTimeChecker())
+            .AddAttribute("ActiveRouteTimeout",
+                          "Period of time during which the route is considered to be valid",
+                          TimeValue(Seconds(3)),
+                          MakeTimeAccessor(&RoutingProtocol::m_activeRouteTimeout),
+                          MakeTimeChecker())
+            .AddAttribute("MyRouteTimeout",
+                          "Value of lifetime field in RREP generating by this node = 2 * "
+                          "max(ActiveRouteTimeout, PathDiscoveryTime)",
+                          TimeValue(Seconds(11.2)),
+                          MakeTimeAccessor(&RoutingProtocol::m_myRouteTimeout),
+                          MakeTimeChecker())
+            .AddAttribute("BlackListTimeout",
+                          "Time for which the node is put into the blacklist = RreqRetries * "
+                          "NetTraversalTime",
+                          TimeValue(Seconds(5.6)),
+                          MakeTimeAccessor(&RoutingProtocol::m_blackListTimeout),
+                          MakeTimeChecker())
+            .AddAttribute("DeletePeriod",
+                          "DeletePeriod is intended to provide an upper bound on the time for "
+                          "which an upstream node A "
+                          "can have a neighbor B as an active next hop for destination D, while B "
+                          "has invalidated the route to D."
+                          " = 5 * max (HelloInterval, ActiveRouteTimeout)",
+                          TimeValue(Seconds(15)),
+                          MakeTimeAccessor(&RoutingProtocol::m_deletePeriod),
+                          MakeTimeChecker())
+            .AddAttribute("NetDiameter",
+                          "Net diameter measures the maximum possible number of hops between two "
+                          "nodes in the network",
+                          UintegerValue(35),
+                          MakeUintegerAccessor(&RoutingProtocol::m_netDiameter),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute(
+                "NetTraversalTime",
+                "Estimate of the average net traversal time = 2 * NodeTraversalTime * NetDiameter",
+                TimeValue(Seconds(2.8)),
+                MakeTimeAccessor(&RoutingProtocol::m_netTraversalTime),
+                MakeTimeChecker())
+            .AddAttribute(
+                "PathDiscoveryTime",
+                "Estimate of maximum time needed to find route in network = 2 * NetTraversalTime",
+                TimeValue(Seconds(5.6)),
+                MakeTimeAccessor(&RoutingProtocol::m_pathDiscoveryTime),
+                MakeTimeChecker())
+            .AddAttribute("MaxQueueLen",
+                          "Maximum number of packets that we allow a routing protocol to buffer.",
+                          UintegerValue(64),
+                          MakeUintegerAccessor(&RoutingProtocol::SetMaxQueueLen,
+                                               &RoutingProtocol::GetMaxQueueLen),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("MaxQueueTime",
+                          "Maximum time packets can be queued (in seconds)",
+                          TimeValue(Seconds(30)),
+                          MakeTimeAccessor(&RoutingProtocol::SetMaxQueueTime,
+                                           &RoutingProtocol::GetMaxQueueTime),
+                          MakeTimeChecker())
+            .AddAttribute("AllowedHelloLoss",
+                          "Number of hello messages which may be loss for valid link.",
+                          UintegerValue(2),
+                          MakeUintegerAccessor(&RoutingProtocol::m_allowedHelloLoss),
+                          MakeUintegerChecker<uint16_t>())
+            .AddAttribute("GratuitousReply",
+                          "Indicates whether a gratuitous RREP should be unicast to the node "
+                          "originated route discovery.",
+                          BooleanValue(true),
+                          MakeBooleanAccessor(&RoutingProtocol::SetGratuitousReplyFlag,
+                                              &RoutingProtocol::GetGratuitousReplyFlag),
+                          MakeBooleanChecker())
+            .AddAttribute("DestinationOnly",
+                          "Indicates only the destination may respond to this RREQ.",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&RoutingProtocol::SetDestinationOnlyFlag,
+                                              &RoutingProtocol::GetDestinationOnlyFlag),
+                          MakeBooleanChecker())
+            .AddAttribute("EnableHello",
+                          "Indicates whether a hello messages enable.",
+                          BooleanValue(true),
+                          MakeBooleanAccessor(&RoutingProtocol::SetHelloEnable,
+                                              &RoutingProtocol::GetHelloEnable),
+                          MakeBooleanChecker())
+            .AddAttribute("EnableBroadcast",
+                          "Indicates whether a broadcast data packets forwarding enable.",
+                          BooleanValue(true),
+                          MakeBooleanAccessor(&RoutingProtocol::SetBroadcastEnable,
+                                              &RoutingProtocol::GetBroadcastEnable),
+                          MakeBooleanChecker())
+            .AddAttribute("UniformRv",
+                          "Access to the underlying UniformRandomVariable",
+                          StringValue("ns3::UniformRandomVariable"),
+                          MakePointerAccessor(&RoutingProtocol::m_uniformRandomVariable),
+                          MakePointerChecker<UniformRandomVariable>());
+    return tid;
+}
+
+void
+RoutingProtocol::SetMaxQueueLen(uint32_t len)
+{
+    m_maxQueueLen = len;
+    m_queue.SetMaxQueueLen(len);
+}
+
+void
+RoutingProtocol::SetMaxQueueTime(Time t)
+{
+    m_maxQueueTime = t;
+    m_queue.SetQueueTimeout(t);
+}
+
+RoutingProtocol::~RoutingProtocol()
+{
+}
+
+void
+RoutingProtocol::DoDispose()
+{
+    m_ipv4 = nullptr;
+    for (auto iter = m_socketAddresses.begin(); iter != m_socketAddresses.end(); iter++)
+    {
+        iter->first->Close();
+    }
+    m_socketAddresses.clear();
+    for (auto iter = m_socketSubnetBroadcastAddresses.begin();
+         iter != m_socketSubnetBroadcastAddresses.end();
+         iter++)
+    {
+        iter->first->Close();
+    }
+    m_socketSubnetBroadcastAddresses.clear();
+    Ipv4RoutingProtocol::DoDispose();
+}
+
+void
+RoutingProtocol::PrintRoutingTable(Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
+{
+    *stream->GetStream() << "Node: " << m_ipv4->GetObject<Node>()->GetId()
+                         << "; Time: " << Now().As(unit)
+                         << ", Local time: " << m_ipv4->GetObject<Node>()->GetLocalTime().As(unit)
+                         << ", RAODV Routing table" << std::endl;
+
+    m_routingTable.Print(stream, unit);
+    *stream->GetStream() << std::endl;
+}
+
+int64_t
+RoutingProtocol::AssignStreams(int64_t stream)
+{
+    NS_LOG_FUNCTION(this << stream);
+    m_uniformRandomVariable->SetStream(stream);
+    return 1;
+}
+
+void
+RoutingProtocol::Start()
+{
+    NS_LOG_FUNCTION(this);
+    if (m_enableHello)
+    {
+        m_nb.ScheduleTimer();
+    }
+    m_rreqRateLimitTimer.SetFunction(&RoutingProtocol::RreqRateLimitTimerExpire, this);
+    m_rreqRateLimitTimer.Schedule(Seconds(1));
+
+    m_rerrRateLimitTimer.SetFunction(&RoutingProtocol::RerrRateLimitTimerExpire, this);
+    m_rerrRateLimitTimer.Schedule(Seconds(1));
+}
+
+Ptr<Ipv4Route>
+RoutingProtocol::RouteOutput(Ptr<Packet> p,
+                             const Ipv4Header& header,
+                             Ptr<NetDevice> oif,
+                             Socket::SocketErrno& sockerr)
+{
+    NS_LOG_FUNCTION(this << header << (oif ? oif->GetIfIndex() : 0));
+    if (!p)
+    {
+        NS_LOG_DEBUG("Packet is == 0");
+        return LoopbackRoute(header, oif); // later
+    }
+    if (m_socketAddresses.empty())
+    {
+        sockerr = Socket::ERROR_NOROUTETOHOST;
+        NS_LOG_LOGIC("No raodv interfaces");
+        Ptr<Ipv4Route> route;
+        return route;
+    }
+    sockerr = Socket::ERROR_NOTERROR;
+    Ptr<Ipv4Route> route;
+    Ipv4Address dst = header.GetDestination();
+    RoutingTableEntry rt;
+    if (m_routingTable.LookupValidRoute(dst, rt))
+    {
+        route = rt.GetRoute();
+        NS_ASSERT(route);
+        NS_LOG_DEBUG("Exist route to " << route->GetDestination() << " from interface "
+                                       << route->GetSource());
+        if (oif && route->GetOutputDevice() != oif)
+        {
+            NS_LOG_DEBUG("Output device doesn't match. Dropped.");
+            sockerr = Socket::ERROR_NOROUTETOHOST;
+            return Ptr<Ipv4Route>();
+        }
+        UpdateRouteLifeTime(dst, m_activeRouteTimeout);
+        UpdateRouteLifeTime(route->GetGateway(), m_activeRouteTimeout);
+        return route;
+    }
+
+    // Valid route not found, in this case we return loopback.
+    // Actual route request will be deferred until packet will be fully formed,
+    // routed to loopback, received from loopback and passed to RouteInput (see below)
+    uint32_t iif = (oif ? m_ipv4->GetInterfaceForDevice(oif) : -1);
+    DeferredRouteOutputTag tag(iif);
+    NS_LOG_DEBUG("Valid Route not found");
+    if (!p->PeekPacketTag(tag))
+    {
+        p->AddPacketTag(tag);
+    }
+    return LoopbackRoute(header, oif);
+}
+
+void
+RoutingProtocol::DeferredRouteOutput(Ptr<const Packet> p,
+                                     const Ipv4Header& header,
+                                     UnicastForwardCallback ucb,
+                                     ErrorCallback ecb)
+{
+    NS_LOG_FUNCTION(this << p << header);
+    NS_ASSERT(p && p != Ptr<Packet>());
+
+    QueueEntry newEntry(p, header, ucb, ecb);
+    bool result = m_queue.Enqueue(newEntry);
+    if (result)
+    {
+        NS_LOG_LOGIC("Add packet " << p->GetUid() << " to queue. Protocol "
+                                   << (uint16_t)header.GetProtocol());
+        RoutingTableEntry rt;
+        bool result = m_routingTable.LookupRoute(header.GetDestination(), rt);
+        if (!result || ((rt.GetFlag() != IN_SEARCH) && result))
+        {
+            NS_LOG_LOGIC("Send new RREQ for outbound packet to " << header.GetDestination());
+            SendRequest(header.GetDestination());
+        }
+    }
+}
+
+bool
+RoutingProtocol::RouteInput(Ptr<const Packet> p,
+                            const Ipv4Header& header,
+                            Ptr<const NetDevice> idev,
+                            const UnicastForwardCallback& ucb,
+                            const MulticastForwardCallback& mcb,
+                            const LocalDeliverCallback& lcb,
+                            const ErrorCallback& ecb)
+{
+    NS_LOG_FUNCTION(this << p->GetUid() << header.GetDestination() << idev->GetAddress());
+    if (m_socketAddresses.empty())
+    {
+        NS_LOG_LOGIC("No raodv interfaces");
+        return false;
+    }
+    NS_ASSERT(m_ipv4);
+    NS_ASSERT(p);
+    // Check if input device supports IP
+    NS_ASSERT(m_ipv4->GetInterfaceForDevice(idev) >= 0);
+    int32_t iif = m_ipv4->GetInterfaceForDevice(idev);
+
+    Ipv4Address dst = header.GetDestination();
+    Ipv4Address origin = header.GetSource();
+
+    // Deferred route request
+    if (idev == m_lo)
+    {
+        DeferredRouteOutputTag tag;
+        if (p->PeekPacketTag(tag))
+        {
+            DeferredRouteOutput(p, header, ucb, ecb);
+            return true;
+        }
+    }
+
+    // Duplicate of own packet
+    if (IsMyOwnAddress(origin))
+    {
+        return true;
+    }
+
+    // RAODV is not a multicast routing protocol
+    if (dst.IsMulticast())
+    {
+        return false;
+    }
+
+    // Broadcast local delivery/forwarding
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ipv4InterfaceAddress iface = j->second;
+        if (m_ipv4->GetInterfaceForAddress(iface.GetLocal()) == iif)
+        {
+            if (dst == iface.GetBroadcast() || dst.IsBroadcast())
+            {
+                if (m_dpd.IsDuplicate(p, header))
+                {
+                    NS_LOG_DEBUG("Duplicated packet " << p->GetUid() << " from " << origin
+                                                      << ". Drop.");
+                    return true;
+                }
+                UpdateRouteLifeTime(origin, m_activeRouteTimeout);
+                Ptr<Packet> packet = p->Copy();
+                if (!lcb.IsNull())
+                {
+                    NS_LOG_LOGIC("Broadcast local delivery to " << iface.GetLocal());
+                    lcb(p, header, iif);
+                    // Fall through to additional processing
+                }
+                else
+                {
+                    NS_LOG_ERROR("Unable to deliver packet locally due to null callback "
+                                 << p->GetUid() << " from " << origin);
+                    ecb(p, header, Socket::ERROR_NOROUTETOHOST);
+                }
+                if (!m_enableBroadcast)
+                {
+                    return true;
+                }
+                if (header.GetProtocol() == UdpL4Protocol::PROT_NUMBER)
+                {
+                    UdpHeader udpHeader;
+                    p->PeekHeader(udpHeader);
+                    if (udpHeader.GetDestinationPort() == RAODV_PORT)
+                    {
+                        // RAODV packets sent in broadcast are already managed
+                        return true;
+                    }
+                }
+                if (header.GetTtl() > 1)
+                {
+                    NS_LOG_LOGIC("Forward broadcast. TTL " << (uint16_t)header.GetTtl());
+                    RoutingTableEntry toBroadcast;
+                    if (m_routingTable.LookupRoute(dst, toBroadcast))
+                    {
+                        Ptr<Ipv4Route> route = toBroadcast.GetRoute();
+                        ucb(route, packet, header);
+                    }
+                    else
+                    {
+                        NS_LOG_DEBUG("No route to forward broadcast. Drop packet " << p->GetUid());
+                    }
+                }
+                else
+                {
+                    NS_LOG_DEBUG("TTL exceeded. Drop packet " << p->GetUid());
+                }
+                return true;
+            }
+        }
+    }
+
+    // Unicast local delivery
+    if (m_ipv4->IsDestinationAddress(dst, iif))
+    {
+        UpdateRouteLifeTime(origin, m_activeRouteTimeout);
+        RoutingTableEntry toOrigin;
+        if (m_routingTable.LookupValidRoute(origin, toOrigin))
+        {
+            UpdateRouteLifeTime(toOrigin.GetNextHop(), m_activeRouteTimeout);
+            m_nb.Update(toOrigin.GetNextHop(), m_activeRouteTimeout);
+        }
+        if (!lcb.IsNull())
+        {
+            NS_LOG_LOGIC("Unicast local delivery to " << dst);
+            lcb(p, header, iif);
+        }
+        else
+        {
+            NS_LOG_ERROR("Unable to deliver packet locally due to null callback "
+                         << p->GetUid() << " from " << origin);
+            ecb(p, header, Socket::ERROR_NOROUTETOHOST);
+        }
+        return true;
+    }
+
+    // Check if input device supports IP forwarding
+    if (!m_ipv4->IsForwarding(iif))
+    {
+        NS_LOG_LOGIC("Forwarding disabled for this interface");
+        ecb(p, header, Socket::ERROR_NOROUTETOHOST);
+        return true;
+    }
+
+    // Forwarding
+    return Forwarding(p, header, ucb, ecb);
+}
+
+bool
+RoutingProtocol::Forwarding(Ptr<const Packet> p,
+                            const Ipv4Header& header,
+                            UnicastForwardCallback ucb,
+                            ErrorCallback ecb)
+{
+    NS_LOG_FUNCTION(this);
+    Ipv4Address dst = header.GetDestination();
+    Ipv4Address origin = header.GetSource();
+    m_routingTable.Purge();
+    RoutingTableEntry toDst;
+    if (m_routingTable.LookupRoute(dst, toDst))
+    {
+        if (toDst.GetFlag() == VALID)
+        {
+            Ptr<Ipv4Route> route = toDst.GetRoute();
+            NS_LOG_LOGIC(route->GetSource() << " forwarding to " << dst << " from " << origin
+                                            << " packet " << p->GetUid());
+
+            /*
+             *  Each time a route is used to forward a data packet, its Active Route
+             *  Lifetime field of the source, destination and the next hop on the
+             *  path to the destination is updated to be no less than the current
+             *  time plus ActiveRouteTimeout.
+             */
+            UpdateRouteLifeTime(origin, m_activeRouteTimeout);
+            UpdateRouteLifeTime(dst, m_activeRouteTimeout);
+            UpdateRouteLifeTime(route->GetGateway(), m_activeRouteTimeout);
+            /*
+             *  Since the route between each originator and destination pair is expected to be
+             * symmetric, the Active Route Lifetime for the previous hop, along the reverse path
+             * back to the IP source, is also updated to be no less than the current time plus
+             * ActiveRouteTimeout
+             */
+            RoutingTableEntry toOrigin;
+            m_routingTable.LookupRoute(origin, toOrigin);
+            UpdateRouteLifeTime(toOrigin.GetNextHop(), m_activeRouteTimeout);
+
+            m_nb.Update(route->GetGateway(), m_activeRouteTimeout);
+            m_nb.Update(toOrigin.GetNextHop(), m_activeRouteTimeout);
+
+            ucb(route, p, header);
+            return true;
+        }
+        else
+        {
+            if (toDst.GetValidSeqNo())
+            {
+                SendRerrWhenNoRouteToForward(dst, toDst.GetSeqNo(), origin);
+                NS_LOG_DEBUG("Drop packet " << p->GetUid() << " because no route to forward it.");
+                return false;
+            }
+        }
+    }
+    NS_LOG_LOGIC("route not found to " << dst << ". Send RERR message.");
+    NS_LOG_DEBUG("Drop packet " << p->GetUid() << " because no route to forward it.");
+    SendRerrWhenNoRouteToForward(dst, 0, origin);
+    return false;
+}
+
+void
+RoutingProtocol::SetIpv4(Ptr<Ipv4> ipv4)
+{
+    NS_ASSERT(ipv4);
+    NS_ASSERT(!m_ipv4);
+
+    m_ipv4 = ipv4;
+
+    // Create lo route. It is asserted that the only one interface up for now is loopback
+    NS_ASSERT(m_ipv4->GetNInterfaces() == 1 &&
+              m_ipv4->GetAddress(0, 0).GetLocal() == Ipv4Address("127.0.0.1"));
+    m_lo = m_ipv4->GetNetDevice(0);
+    NS_ASSERT(m_lo);
+    // Remember lo route
+    RoutingTableEntry rt(
+        /*dev=*/m_lo,
+        /*dst=*/Ipv4Address::GetLoopback(),
+        /*vSeqNo=*/true,
+        /*seqNo=*/0,
+        /*iface=*/Ipv4InterfaceAddress(Ipv4Address::GetLoopback(), Ipv4Mask("255.0.0.0")),
+        /*hops=*/1,
+        /*nextHop=*/Ipv4Address::GetLoopback(),
+        /*lifetime=*/Simulator::GetMaximumSimulationTime());
+    m_routingTable.AddRoute(rt);
+
+    Simulator::ScheduleNow(&RoutingProtocol::Start, this);
+}
+
+void
+RoutingProtocol::NotifyInterfaceUp(uint32_t i)
+{
+    NS_LOG_FUNCTION(this << m_ipv4->GetAddress(i, 0).GetLocal());
+    Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
+    if (l3->GetNAddresses(i) > 1)
+    {
+        NS_LOG_WARN("RAODV does not work with more then one address per each interface.");
+    }
+    Ipv4InterfaceAddress iface = l3->GetAddress(i, 0);
+    if (iface.GetLocal() == Ipv4Address("127.0.0.1"))
+    {
+        return;
+    }
+
+    // Create a socket to listen only on this interface
+    Ptr<Socket> socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+    NS_ASSERT(socket);
+    socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+    socket->BindToNetDevice(l3->GetNetDevice(i));
+    socket->Bind(InetSocketAddress(iface.GetLocal(), RAODV_PORT));
+    socket->SetAllowBroadcast(true);
+    socket->SetIpRecvTtl(true);
+    m_socketAddresses.insert(std::make_pair(socket, iface));
+
+    // create also a subnet broadcast socket
+    socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+    NS_ASSERT(socket);
+    socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+    socket->BindToNetDevice(l3->GetNetDevice(i));
+    socket->Bind(InetSocketAddress(iface.GetBroadcast(), RAODV_PORT));
+    socket->SetAllowBroadcast(true);
+    socket->SetIpRecvTtl(true);
+    m_socketSubnetBroadcastAddresses.insert(std::make_pair(socket, iface));
+
+    // Add local broadcast record to the routing table
+    Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
+    RoutingTableEntry rt(/*dev=*/dev,
+                         /*dst=*/iface.GetBroadcast(),
+                         /*vSeqNo=*/true,
+                         /*seqNo=*/0,
+                         /*iface=*/iface,
+                         /*hops=*/1,
+                         /*nextHop=*/iface.GetBroadcast(),
+                         /*lifetime=*/Simulator::GetMaximumSimulationTime());
+    m_routingTable.AddRoute(rt);
+
+    if (l3->GetInterface(i)->GetArpCache())
+    {
+        m_nb.AddArpCache(l3->GetInterface(i)->GetArpCache());
+    }
+
+    // Allow neighbor manager use this interface for layer 2 feedback if possible
+    Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice>();
+    if (!wifi)
+    {
+        return;
+    }
+    Ptr<WifiMac> mac = wifi->GetMac();
+    if (!mac)
+    {
+        return;
+    }
+
+    mac->TraceConnectWithoutContext("DroppedMpdu",
+                                    MakeCallback(&RoutingProtocol::NotifyTxError, this));
+}
+
+void
+RoutingProtocol::NotifyTxError(WifiMacDropReason reason, Ptr<const WifiMpdu> mpdu)
+{
+    m_nb.GetTxErrorCallback()(mpdu->GetHeader());
+}
+
+void
+RoutingProtocol::NotifyInterfaceDown(uint32_t i)
+{
+    NS_LOG_FUNCTION(this << m_ipv4->GetAddress(i, 0).GetLocal());
+
+    // Disable layer 2 link state monitoring (if possible)
+    Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
+    Ptr<NetDevice> dev = l3->GetNetDevice(i);
+    Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice>();
+    if (wifi)
+    {
+        Ptr<WifiMac> mac = wifi->GetMac()->GetObject<AdhocWifiMac>();
+        if (mac)
+        {
+            mac->TraceDisconnectWithoutContext("DroppedMpdu",
+                                               MakeCallback(&RoutingProtocol::NotifyTxError, this));
+            m_nb.DelArpCache(l3->GetInterface(i)->GetArpCache());
+        }
+    }
+
+    // Close socket
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(m_ipv4->GetAddress(i, 0));
+    NS_ASSERT(socket);
+    socket->Close();
+    m_socketAddresses.erase(socket);
+
+    // Close socket
+    socket = FindSubnetBroadcastSocketWithInterfaceAddress(m_ipv4->GetAddress(i, 0));
+    NS_ASSERT(socket);
+    socket->Close();
+    m_socketSubnetBroadcastAddresses.erase(socket);
+
+    if (m_socketAddresses.empty())
+    {
+        NS_LOG_LOGIC("No raodv interfaces");
+        m_htimer.Cancel();
+        m_nb.Clear();
+        m_routingTable.Clear();
+        return;
+    }
+    m_routingTable.DeleteAllRoutesFromInterface(m_ipv4->GetAddress(i, 0));
+}
+
+void
+RoutingProtocol::NotifyAddAddress(uint32_t i, Ipv4InterfaceAddress address)
+{
+    NS_LOG_FUNCTION(this << " interface " << i << " address " << address);
+    Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
+    if (!l3->IsUp(i))
+    {
+        return;
+    }
+    if (l3->GetNAddresses(i) == 1)
+    {
+        Ipv4InterfaceAddress iface = l3->GetAddress(i, 0);
+        Ptr<Socket> socket = FindSocketWithInterfaceAddress(iface);
+        if (!socket)
+        {
+            if (iface.GetLocal() == Ipv4Address("127.0.0.1"))
+            {
+                return;
+            }
+            // Create a socket to listen only on this interface
+            Ptr<Socket> socket =
+                Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+            NS_ASSERT(socket);
+            socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+            socket->BindToNetDevice(l3->GetNetDevice(i));
+            socket->Bind(InetSocketAddress(iface.GetLocal(), RAODV_PORT));
+            socket->SetAllowBroadcast(true);
+            m_socketAddresses.insert(std::make_pair(socket, iface));
+
+            // create also a subnet directed broadcast socket
+            socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+            NS_ASSERT(socket);
+            socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+            socket->BindToNetDevice(l3->GetNetDevice(i));
+            socket->Bind(InetSocketAddress(iface.GetBroadcast(), RAODV_PORT));
+            socket->SetAllowBroadcast(true);
+            socket->SetIpRecvTtl(true);
+            m_socketSubnetBroadcastAddresses.insert(std::make_pair(socket, iface));
+
+            // Add local broadcast record to the routing table
+            Ptr<NetDevice> dev =
+                m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
+            RoutingTableEntry rt(/*dev=*/dev,
+                                 /*dst=*/iface.GetBroadcast(),
+                                 /*vSeqNo=*/true,
+                                 /*seqNo=*/0,
+                                 /*iface=*/iface,
+                                 /*hops=*/1,
+                                 /*nextHop=*/iface.GetBroadcast(),
+                                 /*lifetime=*/Simulator::GetMaximumSimulationTime());
+            m_routingTable.AddRoute(rt);
+        }
+    }
+    else
+    {
+        NS_LOG_LOGIC("RAODV does not work with more then one address per each interface. Ignore "
+                     "added address");
+    }
+}
+
+void
+RoutingProtocol::NotifyRemoveAddress(uint32_t i, Ipv4InterfaceAddress address)
+{
+    NS_LOG_FUNCTION(this);
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(address);
+    if (socket)
+    {
+        m_routingTable.DeleteAllRoutesFromInterface(address);
+        socket->Close();
+        m_socketAddresses.erase(socket);
+
+        Ptr<Socket> unicastSocket = FindSubnetBroadcastSocketWithInterfaceAddress(address);
+        if (unicastSocket)
+        {
+            unicastSocket->Close();
+            m_socketAddresses.erase(unicastSocket);
+        }
+
+        Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
+        if (l3->GetNAddresses(i))
+        {
+            Ipv4InterfaceAddress iface = l3->GetAddress(i, 0);
+            // Create a socket to listen only on this interface
+            Ptr<Socket> socket =
+                Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+            NS_ASSERT(socket);
+            socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+            // Bind to any IP address so that broadcasts can be received
+            socket->BindToNetDevice(l3->GetNetDevice(i));
+            socket->Bind(InetSocketAddress(iface.GetLocal(), RAODV_PORT));
+            socket->SetAllowBroadcast(true);
+            socket->SetIpRecvTtl(true);
+            m_socketAddresses.insert(std::make_pair(socket, iface));
+
+            // create also a unicast socket
+            socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
+            NS_ASSERT(socket);
+            socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvRAodv, this));
+            socket->BindToNetDevice(l3->GetNetDevice(i));
+            socket->Bind(InetSocketAddress(iface.GetBroadcast(), RAODV_PORT));
+            socket->SetAllowBroadcast(true);
+            socket->SetIpRecvTtl(true);
+            m_socketSubnetBroadcastAddresses.insert(std::make_pair(socket, iface));
+
+            // Add local broadcast record to the routing table
+            Ptr<NetDevice> dev =
+                m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
+            RoutingTableEntry rt(/*dev=*/dev,
+                                 /*dst=*/iface.GetBroadcast(),
+                                 /*vSeqNo=*/true,
+                                 /*seqNo=*/0,
+                                 /*iface=*/iface,
+                                 /*hops=*/1,
+                                 /*nextHop=*/iface.GetBroadcast(),
+                                 /*lifetime=*/Simulator::GetMaximumSimulationTime());
+            m_routingTable.AddRoute(rt);
+        }
+        if (m_socketAddresses.empty())
+        {
+            NS_LOG_LOGIC("No raodv interfaces");
+            m_htimer.Cancel();
+            m_nb.Clear();
+            m_routingTable.Clear();
+            return;
+        }
+    }
+    else
+    {
+        NS_LOG_LOGIC("Remove address not participating in RAODV operation");
+    }
+}
+
+bool
+RoutingProtocol::IsMyOwnAddress(Ipv4Address src)
+{
+    NS_LOG_FUNCTION(this << src);
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ipv4InterfaceAddress iface = j->second;
+        if (src == iface.GetLocal())
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+Ptr<Ipv4Route>
+RoutingProtocol::LoopbackRoute(const Ipv4Header& hdr, Ptr<NetDevice> oif) const
+{
+    NS_LOG_FUNCTION(this << hdr);
+    NS_ASSERT(m_lo);
+    Ptr<Ipv4Route> rt = Create<Ipv4Route>();
+    rt->SetDestination(hdr.GetDestination());
+    //
+    // Source address selection here is tricky.  The loopback route is
+    // returned when RAODV does not have a route; this causes the packet
+    // to be looped back and handled (cached) in RouteInput() method
+    // while a route is found. However, connection-oriented protocols
+    // like TCP need to create an endpoint four-tuple (src, src port,
+    // dst, dst port) and create a pseudo-header for checksumming.  So,
+    // RAODV needs to guess correctly what the eventual source address
+    // will be.
+    //
+    // For single interface, single address nodes, this is not a problem.
+    // When there are possibly multiple outgoing interfaces, the policy
+    // implemented here is to pick the first available RAODV interface.
+    // If RouteOutput() caller specified an outgoing interface, that
+    // further constrains the selection of source address
+    //
+    auto j = m_socketAddresses.begin();
+    if (oif)
+    {
+        // Iterate to find an address on the oif device
+        for (j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+        {
+            Ipv4Address addr = j->second.GetLocal();
+            int32_t interface = m_ipv4->GetInterfaceForAddress(addr);
+            if (oif == m_ipv4->GetNetDevice(static_cast<uint32_t>(interface)))
+            {
+                rt->SetSource(addr);
+                break;
+            }
+        }
+    }
+    else
+    {
+        rt->SetSource(j->second.GetLocal());
+    }
+    NS_ASSERT_MSG(rt->GetSource() != Ipv4Address(), "Valid RAODV source address not found");
+    rt->SetGateway(Ipv4Address("127.0.0.1"));
+    rt->SetOutputDevice(m_lo);
+    return rt;
+}
+
+void
+RoutingProtocol::SendRequest(Ipv4Address dst)
+{
+    NS_LOG_FUNCTION(this << dst);
+    // A node SHOULD NOT originate more than RREQ_RATELIMIT RREQ messages per second.
+    if (m_rreqCount == m_rreqRateLimit)
+    {
+        Simulator::Schedule(m_rreqRateLimitTimer.GetDelayLeft() + MicroSeconds(100),
+                            &RoutingProtocol::SendRequest,
+                            this,
+                            dst);
+        return;
+    }
+    else
+    {
+        m_rreqCount++;
+    }
+    // Create RREQ header
+    RreqHeader rreqHeader;
+    rreqHeader.SetDst(dst);
+
+    RoutingTableEntry rt;
+    // Using the Hop field in Routing Table to manage the expanding ring search
+    uint16_t ttl = m_ttlStart;
+    if (m_routingTable.LookupRoute(dst, rt))
+    {
+        if (rt.GetFlag() != IN_SEARCH)
+        {
+            ttl = std::min<uint16_t>(rt.GetHop() + m_ttlIncrement, m_netDiameter);
+        }
+        else
+        {
+            ttl = rt.GetHop() + m_ttlIncrement;
+            if (ttl > m_ttlThreshold)
+            {
+                ttl = m_netDiameter;
+            }
+        }
+        if (ttl == m_netDiameter)
+        {
+            rt.IncrementRreqCnt();
+        }
+        if (rt.GetValidSeqNo())
+        {
+            rreqHeader.SetDstSeqno(rt.GetSeqNo());
+        }
+        else
+        {
+            rreqHeader.SetUnknownSeqno(true);
+        }
+        rt.SetHop(ttl);
+        rt.SetFlag(IN_SEARCH);
+        rt.SetLifeTime(m_pathDiscoveryTime);
+        m_routingTable.Update(rt);
+    }
+    else
+    {
+        rreqHeader.SetUnknownSeqno(true);
+        Ptr<NetDevice> dev = nullptr;
+        RoutingTableEntry newEntry(/*dev=*/dev,
+                                   /*dst=*/dst,
+                                   /*vSeqNo=*/false,
+                                   /*seqNo=*/0,
+                                   /*iface=*/Ipv4InterfaceAddress(),
+                                   /*hops=*/ttl,
+                                   /*nextHop=*/Ipv4Address(),
+                                   /*lifetime=*/m_pathDiscoveryTime);
+        // Check if TtlStart == NetDiameter
+        if (ttl == m_netDiameter)
+        {
+            newEntry.IncrementRreqCnt();
+        }
+        newEntry.SetFlag(IN_SEARCH);
+        m_routingTable.AddRoute(newEntry);
+    }
+
+    if (m_gratuitousReply)
+    {
+        rreqHeader.SetGratuitousRrep(true);
+    }
+    if (m_destinationOnly)
+    {
+        rreqHeader.SetDestinationOnly(true);
+    }
+
+    m_seqNo++;
+    rreqHeader.SetOriginSeqno(m_seqNo);
+    m_requestId++;
+    rreqHeader.SetId(m_requestId);
+
+    // Send RREQ as subnet directed broadcast from each interface used by raodv
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ptr<Socket> socket = j->first;
+        Ipv4InterfaceAddress iface = j->second;
+
+        rreqHeader.SetOrigin(iface.GetLocal());
+        m_rreqIdCache.IsDuplicate(iface.GetLocal(), m_requestId);
+
+        Ptr<Packet> packet = Create<Packet>();
+        SocketIpTtlTag tag;
+        tag.SetTtl(ttl);
+        packet->AddPacketTag(tag);
+        packet->AddHeader(rreqHeader);
+        TypeHeader tHeader(AODVTYPE_RREQ);
+        packet->AddHeader(tHeader);
+        // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
+        Ipv4Address destination;
+        if (iface.GetMask() == Ipv4Mask::GetOnes())
+        {
+            destination = Ipv4Address("255.255.255.255");
+        }
+        else
+        {
+            destination = iface.GetBroadcast();
+        }
+        NS_LOG_DEBUG("Send RREQ with id " << rreqHeader.GetId() << " to socket");
+        m_lastBcastTime = Simulator::Now();
+        Simulator::Schedule(Time(MilliSeconds(m_uniformRandomVariable->GetInteger(0, 10))),
+                            &RoutingProtocol::SendTo,
+                            this,
+                            socket,
+                            packet,
+                            destination);
+    }
+    ScheduleRreqRetry(dst);
+}
+
+void
+RoutingProtocol::SendTo(Ptr<Socket> socket, Ptr<Packet> packet, Ipv4Address destination)
+{
+    socket->SendTo(packet, 0, InetSocketAddress(destination, RAODV_PORT));
+}
+
+void
+RoutingProtocol::ScheduleRreqRetry(Ipv4Address dst)
+{
+    NS_LOG_FUNCTION(this << dst);
+    if (m_addressReqTimer.find(dst) == m_addressReqTimer.end())
+    {
+        Timer timer(Timer::CANCEL_ON_DESTROY);
+        m_addressReqTimer[dst] = timer;
+    }
+    m_addressReqTimer[dst].SetFunction(&RoutingProtocol::RouteRequestTimerExpire, this);
+    m_addressReqTimer[dst].Cancel();
+    m_addressReqTimer[dst].SetArguments(dst);
+    RoutingTableEntry rt;
+    m_routingTable.LookupRoute(dst, rt);
+    Time retry;
+    if (rt.GetHop() < m_netDiameter)
+    {
+        retry = 2 * m_nodeTraversalTime * (rt.GetHop() + m_timeoutBuffer);
+    }
+    else
+    {
+        NS_ABORT_MSG_UNLESS(rt.GetRreqCnt() > 0, "Unexpected value for GetRreqCount ()");
+        uint16_t backoffFactor = rt.GetRreqCnt() - 1;
+        NS_LOG_LOGIC("Applying binary exponential backoff factor " << backoffFactor);
+        retry = m_netTraversalTime * (1 << backoffFactor);
+    }
+    m_addressReqTimer[dst].Schedule(retry);
+    NS_LOG_LOGIC("Scheduled RREQ retry in " << retry.As(Time::S));
+}
+
+void
+RoutingProtocol::RecvRAodv(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    Address sourceAddress;
+    Ptr<Packet> packet = socket->RecvFrom(sourceAddress);
+    InetSocketAddress inetSourceAddr = InetSocketAddress::ConvertFrom(sourceAddress);
+    Ipv4Address sender = inetSourceAddr.GetIpv4();
+    Ipv4Address receiver;
+
+    if (m_socketAddresses.find(socket) != m_socketAddresses.end())
+    {
+        receiver = m_socketAddresses[socket].GetLocal();
+    }
+    else if (m_socketSubnetBroadcastAddresses.find(socket) !=
+             m_socketSubnetBroadcastAddresses.end())
+    {
+        receiver = m_socketSubnetBroadcastAddresses[socket].GetLocal();
+    }
+    else
+    {
+        NS_ASSERT_MSG(false, "Received a packet from an unknown socket");
+    }
+    NS_LOG_DEBUG("RAODV node " << this << " received a RAODV packet from " << sender << " to "
+                              << receiver);
+
+    UpdateRouteToNeighbor(sender, receiver);
+    TypeHeader tHeader(AODVTYPE_RREQ);
+    packet->RemoveHeader(tHeader);
+    if (!tHeader.IsValid())
+    {
+        NS_LOG_DEBUG("RAODV message " << packet->GetUid() << " with unknown type received: "
+                                     << tHeader.Get() << ". Drop");
+        return; // drop
+    }
+    switch (tHeader.Get())
+    {
+    case AODVTYPE_RREQ: {
+        RecvRequest(packet, receiver, sender);
+        break;
+    }
+    case AODVTYPE_RREP: {
+        RecvReply(packet, receiver, sender);
+        break;
+    }
+    case AODVTYPE_RERR: {
+        RecvError(packet, sender);
+        break;
+    }
+    case AODVTYPE_RREP_ACK: {
+        RecvReplyAck(sender);
+        break;
+    }
+    }
+}
+
+bool
+RoutingProtocol::UpdateRouteLifeTime(Ipv4Address addr, Time lifetime)
+{
+    NS_LOG_FUNCTION(this << addr << lifetime);
+    RoutingTableEntry rt;
+    if (m_routingTable.LookupRoute(addr, rt))
+    {
+        if (rt.GetFlag() == VALID)
+        {
+            NS_LOG_DEBUG("Updating VALID route");
+            rt.SetRreqCnt(0);
+            rt.SetLifeTime(std::max(lifetime, rt.GetLifeTime()));
+            m_routingTable.Update(rt);
+            return true;
+        }
+    }
+    return false;
+}
+
+void
+RoutingProtocol::UpdateRouteToNeighbor(Ipv4Address sender, Ipv4Address receiver)
+{
+    NS_LOG_FUNCTION(this << "sender " << sender << " receiver " << receiver);
+    RoutingTableEntry toNeighbor;
+    if (!m_routingTable.LookupRoute(sender, toNeighbor))
+    {
+        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+        RoutingTableEntry newEntry(
+            /*dev=*/dev,
+            /*dst=*/sender,
+            /*vSeqNo=*/false,
+            /*seqNo=*/0,
+            /*iface=*/m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+            /*hops=*/1,
+            /*nextHop=*/sender,
+            /*lifetime=*/m_activeRouteTimeout);
+        m_routingTable.AddRoute(newEntry);
+    }
+    else
+    {
+        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+        if (toNeighbor.GetValidSeqNo() && (toNeighbor.GetHop() == 1) &&
+            (toNeighbor.GetOutputDevice() == dev))
+        {
+            toNeighbor.SetLifeTime(std::max(m_activeRouteTimeout, toNeighbor.GetLifeTime()));
+        }
+        else
+        {
+            RoutingTableEntry newEntry(
+                /*dev=*/dev,
+                /*dst=*/sender,
+                /*vSeqNo=*/false,
+                /*seqNo=*/0,
+                /*iface=*/m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+                /*hops=*/1,
+                /*nextHop=*/sender,
+                /*lifetime=*/std::max(m_activeRouteTimeout, toNeighbor.GetLifeTime()));
+            m_routingTable.Update(newEntry);
+        }
+    }
+}
+
+void
+RoutingProtocol::RecvRequest(Ptr<Packet> p, Ipv4Address receiver, Ipv4Address src)
+{
+    NS_LOG_FUNCTION(this);
+    RreqHeader rreqHeader;
+    p->RemoveHeader(rreqHeader);
+
+    // A node ignores all RREQs received from any node in its blacklist
+    RoutingTableEntry toPrev;
+    if (m_routingTable.LookupRoute(src, toPrev))
+    {
+        if (toPrev.IsUnidirectional())
+        {
+            NS_LOG_DEBUG("Ignoring RREQ from node in blacklist");
+            return;
+        }
+    }
+
+    uint32_t id = rreqHeader.GetId();
+    Ipv4Address origin = rreqHeader.GetOrigin();
+
+    /*
+     *  Node checks to determine whether it has received a RREQ with the same Originator IP Address
+     * and RREQ ID. If such a RREQ has been received, the node silently discards the newly received
+     * RREQ.
+     */
+    if (m_rreqIdCache.IsDuplicate(origin, id))
+    {
+        NS_LOG_DEBUG("Ignoring RREQ due to duplicate");
+        return;
+    }
+
+    // Increment RREQ hop count
+    uint8_t hop = rreqHeader.GetHopCount() + 1;
+    rreqHeader.SetHopCount(hop);
+
+    /*
+     *  When the reverse route is created or updated, the following actions on the route are also
+     * carried out:
+     *  1. the Originator Sequence Number from the RREQ is compared to the corresponding destination
+     * sequence number in the route table entry and copied if greater than the existing value there
+     *  2. the valid sequence number field is set to true;
+     *  3. the next hop in the routing table becomes the node from which the  RREQ was received
+     *  4. the hop count is copied from the Hop Count in the RREQ message;
+     *  5. the Lifetime is set to be the maximum of (ExistingLifetime, MinimalLifetime), where
+     *     MinimalLifetime = current time + 2*NetTraversalTime - 2*HopCount*NodeTraversalTime
+     */
+    RoutingTableEntry toOrigin;
+    if (!m_routingTable.LookupRoute(origin, toOrigin))
+    {
+        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+        RoutingTableEntry newEntry(
+            /*dev=*/dev,
+            /*dst=*/origin,
+            /*vSeqNo=*/true,
+            /*seqNo=*/rreqHeader.GetOriginSeqno(),
+            /*iface=*/m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+            /*hops=*/hop,
+            /*nextHop=*/src,
+            /*lifetime=*/Time(2 * m_netTraversalTime - 2 * hop * m_nodeTraversalTime));
+        m_routingTable.AddRoute(newEntry);
+    }
+    else
+    {
+        if (toOrigin.GetValidSeqNo())
+        {
+            if (int32_t(rreqHeader.GetOriginSeqno()) - int32_t(toOrigin.GetSeqNo()) > 0)
+            {
+                toOrigin.SetSeqNo(rreqHeader.GetOriginSeqno());
+            }
+        }
+        else
+        {
+            toOrigin.SetSeqNo(rreqHeader.GetOriginSeqno());
+        }
+        toOrigin.SetValidSeqNo(true);
+        toOrigin.SetNextHop(src);
+        toOrigin.SetOutputDevice(m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver)));
+        toOrigin.SetInterface(m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0));
+        toOrigin.SetHop(hop);
+        toOrigin.SetLifeTime(std::max(Time(2 * m_netTraversalTime - 2 * hop * m_nodeTraversalTime),
+                                      toOrigin.GetLifeTime()));
+        m_routingTable.Update(toOrigin);
+        // m_nb.Update (src, Time (AllowedHelloLoss * HelloInterval));
+    }
+
+    RoutingTableEntry toNeighbor;
+    if (!m_routingTable.LookupRoute(src, toNeighbor))
+    {
+        NS_LOG_DEBUG("Neighbor:" << src << " not found in routing table. Creating an entry");
+        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+        RoutingTableEntry newEntry(dev,
+                                   src,
+                                   false,
+                                   rreqHeader.GetOriginSeqno(),
+                                   m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+                                   1,
+                                   src,
+                                   m_activeRouteTimeout);
+        m_routingTable.AddRoute(newEntry);
+    }
+    else
+    {
+        toNeighbor.SetLifeTime(m_activeRouteTimeout);
+        toNeighbor.SetValidSeqNo(false);
+        toNeighbor.SetSeqNo(rreqHeader.GetOriginSeqno());
+        toNeighbor.SetFlag(VALID);
+        toNeighbor.SetOutputDevice(m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver)));
+        toNeighbor.SetInterface(m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0));
+        toNeighbor.SetHop(1);
+        toNeighbor.SetNextHop(src);
+        m_routingTable.Update(toNeighbor);
+    }
+    m_nb.Update(src, Time(m_allowedHelloLoss * m_helloInterval));
+
+    NS_LOG_LOGIC(receiver << " receive RREQ with hop count "
+                          << static_cast<uint32_t>(rreqHeader.GetHopCount()) << " ID "
+                          << rreqHeader.GetId() << " to destination " << rreqHeader.GetDst());
+
+    //  A node generates a RREP if either:
+    //  (i)  it is itself the destination,
+    if (IsMyOwnAddress(rreqHeader.GetDst()))
+    {
+        m_routingTable.LookupRoute(origin, toOrigin);
+        NS_LOG_DEBUG("Send reply since I am the destination");
+        SendReply(rreqHeader, toOrigin);
+        return;
+    }
+    /*
+     * (ii) or it has an active route to the destination, the destination sequence number in the
+     * node's existing route table entry for the destination is valid and greater than or equal to
+     * the Destination Sequence Number of the RREQ, and the "destination only" flag is NOT set.
+     */
+    RoutingTableEntry toDst;
+    Ipv4Address dst = rreqHeader.GetDst();
+    if (m_routingTable.LookupRoute(dst, toDst))
+    {
+        /*
+         * Drop RREQ, This node RREP will make a loop.
+         */
+        if (toDst.GetNextHop() == src)
+        {
+            NS_LOG_DEBUG("Drop RREQ from " << src << ", dest next hop " << toDst.GetNextHop());
+            return;
+        }
+        /*
+         * The Destination Sequence number for the requested destination is set to the maximum of
+         * the corresponding value received in the RREQ message, and the destination sequence value
+         * currently maintained by the node for the requested destination. However, the forwarding
+         * node MUST NOT modify its maintained value for the destination sequence number, even if
+         * the value received in the incoming RREQ is larger than the value currently maintained by
+         * the forwarding node.
+         */
+        if ((rreqHeader.GetUnknownSeqno() ||
+             (int32_t(toDst.GetSeqNo()) - int32_t(rreqHeader.GetDstSeqno()) >= 0)) &&
+            toDst.GetValidSeqNo())
+        {
+            if (!rreqHeader.GetDestinationOnly() && toDst.GetFlag() == VALID)
+            {
+                m_routingTable.LookupRoute(origin, toOrigin);
+                SendReplyByIntermediateNode(toDst, toOrigin, rreqHeader.GetGratuitousRrep());
+                return;
+            }
+            rreqHeader.SetDstSeqno(toDst.GetSeqNo());
+            rreqHeader.SetUnknownSeqno(false);
+        }
+    }
+
+    SocketIpTtlTag tag;
+    p->RemovePacketTag(tag);
+    if (tag.GetTtl() < 2)
+    {
+        NS_LOG_DEBUG("TTL exceeded. Drop RREQ origin " << src << " destination " << dst);
+        return;
+    }
+
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ptr<Socket> socket = j->first;
+        Ipv4InterfaceAddress iface = j->second;
+        Ptr<Packet> packet = Create<Packet>();
+        SocketIpTtlTag ttl;
+        ttl.SetTtl(tag.GetTtl() - 1);
+        packet->AddPacketTag(ttl);
+        packet->AddHeader(rreqHeader);
+        TypeHeader tHeader(AODVTYPE_RREQ);
+        packet->AddHeader(tHeader);
+        // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
+        Ipv4Address destination;
+        if (iface.GetMask() == Ipv4Mask::GetOnes())
+        {
+            destination = Ipv4Address("255.255.255.255");
+        }
+        else
+        {
+            destination = iface.GetBroadcast();
+        }
+        m_lastBcastTime = Simulator::Now();
+        Simulator::Schedule(Time(MilliSeconds(m_uniformRandomVariable->GetInteger(0, 10))),
+                            &RoutingProtocol::SendTo,
+                            this,
+                            socket,
+                            packet,
+                            destination);
+    }
+}
+
+void
+RoutingProtocol::SendReply(const RreqHeader& rreqHeader, const RoutingTableEntry& toOrigin)
+{
+    NS_LOG_FUNCTION(this << toOrigin.GetDestination());
+    /*
+     * Destination node MUST increment its own sequence number by one if the sequence number in the
+     * RREQ packet is equal to that incremented value. Otherwise, the destination does not change
+     * its sequence number before generating the  RREP message.
+     */
+    if (!rreqHeader.GetUnknownSeqno() && (rreqHeader.GetDstSeqno() == m_seqNo + 1))
+    {
+        m_seqNo++;
+    }
+    RrepHeader rrepHeader(/*prefixSize=*/0,
+                          /*hopCount=*/0,
+                          /*dst=*/rreqHeader.GetDst(),
+                          /*dstSeqNo=*/m_seqNo,
+                          /*origin=*/toOrigin.GetDestination(),
+                          /*lifetime=*/m_myRouteTimeout);
+    Ptr<Packet> packet = Create<Packet>();
+    SocketIpTtlTag tag;
+    tag.SetTtl(toOrigin.GetHop());
+    packet->AddPacketTag(tag);
+    packet->AddHeader(rrepHeader);
+    TypeHeader tHeader(AODVTYPE_RREP);
+    packet->AddHeader(tHeader);
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(toOrigin.GetInterface());
+    NS_ASSERT(socket);
+    socket->SendTo(packet, 0, InetSocketAddress(toOrigin.GetNextHop(), RAODV_PORT));
+}
+
+void
+RoutingProtocol::SendReplyByIntermediateNode(RoutingTableEntry& toDst,
+                                             RoutingTableEntry& toOrigin,
+                                             bool gratRep)
+{
+    NS_LOG_FUNCTION(this);
+    RrepHeader rrepHeader(/*prefixSize=*/0,
+                          /*hopCount=*/toDst.GetHop(),
+                          /*dst=*/toDst.GetDestination(),
+                          /*dstSeqNo=*/toDst.GetSeqNo(),
+                          /*origin=*/toOrigin.GetDestination(),
+                          /*lifetime=*/toDst.GetLifeTime());
+    /* If the node we received a RREQ for is a neighbor we are
+     * probably facing a unidirectional link... Better request a RREP-ack
+     */
+    if (toDst.GetHop() == 1)
+    {
+        rrepHeader.SetAckRequired(true);
+        RoutingTableEntry toNextHop;
+        m_routingTable.LookupRoute(toOrigin.GetNextHop(), toNextHop);
+        toNextHop.m_ackTimer.SetFunction(&RoutingProtocol::AckTimerExpire, this);
+        toNextHop.m_ackTimer.SetArguments(toNextHop.GetDestination(), m_blackListTimeout);
+        toNextHop.m_ackTimer.SetDelay(m_nextHopWait);
+    }
+    toDst.InsertPrecursor(toOrigin.GetNextHop());
+    toOrigin.InsertPrecursor(toDst.GetNextHop());
+    m_routingTable.Update(toDst);
+    m_routingTable.Update(toOrigin);
+
+    Ptr<Packet> packet = Create<Packet>();
+    SocketIpTtlTag tag;
+    tag.SetTtl(toOrigin.GetHop());
+    packet->AddPacketTag(tag);
+    packet->AddHeader(rrepHeader);
+    TypeHeader tHeader(AODVTYPE_RREP);
+    packet->AddHeader(tHeader);
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(toOrigin.GetInterface());
+    NS_ASSERT(socket);
+    socket->SendTo(packet, 0, InetSocketAddress(toOrigin.GetNextHop(), RAODV_PORT));
+
+    // Generating gratuitous RREPs
+    if (gratRep)
+    {
+        RrepHeader gratRepHeader(/*prefixSize=*/0,
+                                 /*hopCount=*/toOrigin.GetHop(),
+                                 /*dst=*/toOrigin.GetDestination(),
+                                 /*dstSeqNo=*/toOrigin.GetSeqNo(),
+                                 /*origin=*/toDst.GetDestination(),
+                                 /*lifetime=*/toOrigin.GetLifeTime());
+        Ptr<Packet> packetToDst = Create<Packet>();
+        SocketIpTtlTag gratTag;
+        gratTag.SetTtl(toDst.GetHop());
+        packetToDst->AddPacketTag(gratTag);
+        packetToDst->AddHeader(gratRepHeader);
+        TypeHeader type(AODVTYPE_RREP);
+        packetToDst->AddHeader(type);
+        Ptr<Socket> socket = FindSocketWithInterfaceAddress(toDst.GetInterface());
+        NS_ASSERT(socket);
+        NS_LOG_LOGIC("Send gratuitous RREP " << packet->GetUid());
+        socket->SendTo(packetToDst, 0, InetSocketAddress(toDst.GetNextHop(), RAODV_PORT));
+    }
+}
+
+void
+RoutingProtocol::SendReplyAck(Ipv4Address neighbor)
+{
+    NS_LOG_FUNCTION(this << " to " << neighbor);
+    RrepAckHeader h;
+    TypeHeader typeHeader(AODVTYPE_RREP_ACK);
+    Ptr<Packet> packet = Create<Packet>();
+    SocketIpTtlTag tag;
+    tag.SetTtl(1);
+    packet->AddPacketTag(tag);
+    packet->AddHeader(h);
+    packet->AddHeader(typeHeader);
+    RoutingTableEntry toNeighbor;
+    m_routingTable.LookupRoute(neighbor, toNeighbor);
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(toNeighbor.GetInterface());
+    NS_ASSERT(socket);
+    socket->SendTo(packet, 0, InetSocketAddress(neighbor, RAODV_PORT));
+}
+
+void
+RoutingProtocol::RecvReply(Ptr<Packet> p, Ipv4Address receiver, Ipv4Address sender)
+{
+    NS_LOG_FUNCTION(this << " src " << sender);
+    RrepHeader rrepHeader;
+    p->RemoveHeader(rrepHeader);
+    Ipv4Address dst = rrepHeader.GetDst();
+    NS_LOG_LOGIC("RREP destination " << dst << " RREP origin " << rrepHeader.GetOrigin());
+
+    uint8_t hop = rrepHeader.GetHopCount() + 1;
+    rrepHeader.SetHopCount(hop);
+
+    // If RREP is Hello message
+    if (dst == rrepHeader.GetOrigin())
+    {
+        ProcessHello(rrepHeader, receiver);
+        return;
+    }
+
+    /*
+     * If the route table entry to the destination is created or updated, then the following actions
+     * occur:
+     * -  the route is marked as active,
+     * -  the destination sequence number is marked as valid,
+     * -  the next hop in the route entry is assigned to be the node from which the RREP is
+     * received, which is indicated by the source IP address field in the IP header,
+     * -  the hop count is set to the value of the hop count from RREP message + 1
+     * -  the expiry time is set to the current time plus the value of the Lifetime in the RREP
+     * message,
+     * -  and the destination sequence number is the Destination Sequence Number in the RREP
+     * message.
+     */
+    Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+    RoutingTableEntry newEntry(
+        /*dev=*/dev,
+        /*dst=*/dst,
+        /*vSeqNo=*/true,
+        /*seqNo=*/rrepHeader.GetDstSeqno(),
+        /*iface=*/m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+        /*hops=*/hop,
+        /*nextHop=*/sender,
+        /*lifetime=*/rrepHeader.GetLifeTime());
+    RoutingTableEntry toDst;
+    if (m_routingTable.LookupRoute(dst, toDst))
+    {
+        // The existing entry is updated only in the following circumstances:
+        if (
+            // (i) the sequence number in the routing table is marked as invalid in route table
+            // entry.
+            (!toDst.GetValidSeqNo()) ||
+
+            // (ii) the Destination Sequence Number in the RREP is greater than the node's copy of
+            // the destination sequence number and the known value is valid,
+            ((int32_t(rrepHeader.GetDstSeqno()) - int32_t(toDst.GetSeqNo())) > 0) ||
+
+            // (iii) the sequence numbers are the same, but the route is marked as inactive.
+            (rrepHeader.GetDstSeqno() == toDst.GetSeqNo() && toDst.GetFlag() != VALID) ||
+
+            // (iv) the sequence numbers are the same, and the New Hop Count is smaller than the
+            // hop count in route table entry.
+            (rrepHeader.GetDstSeqno() == toDst.GetSeqNo() && hop < toDst.GetHop()))
+        {
+            m_routingTable.Update(newEntry);
+        }
+    }
+    else
+    {
+        // The forward route for this destination is created if it does not already exist.
+        NS_LOG_LOGIC("add new route");
+        m_routingTable.AddRoute(newEntry);
+    }
+    // Acknowledge receipt of the RREP by sending a RREP-ACK message back
+    if (rrepHeader.GetAckRequired())
+    {
+        SendReplyAck(sender);
+        rrepHeader.SetAckRequired(false);
+    }
+    NS_LOG_LOGIC("receiver " << receiver << " origin " << rrepHeader.GetOrigin());
+    if (IsMyOwnAddress(rrepHeader.GetOrigin()))
+    {
+        if (toDst.GetFlag() == IN_SEARCH)
+        {
+            m_routingTable.Update(newEntry);
+            m_addressReqTimer[dst].Cancel();
+            m_addressReqTimer.erase(dst);
+        }
+        m_routingTable.LookupRoute(dst, toDst);
+        SendPacketFromQueue(dst, toDst.GetRoute());
+        return;
+    }
+
+    RoutingTableEntry toOrigin;
+    if (!m_routingTable.LookupRoute(rrepHeader.GetOrigin(), toOrigin) ||
+        toOrigin.GetFlag() == IN_SEARCH)
+    {
+        return; // Impossible! drop.
+    }
+    toOrigin.SetLifeTime(std::max(m_activeRouteTimeout, toOrigin.GetLifeTime()));
+    m_routingTable.Update(toOrigin);
+
+    // Update information about precursors
+    if (m_routingTable.LookupValidRoute(rrepHeader.GetDst(), toDst))
+    {
+        toDst.InsertPrecursor(toOrigin.GetNextHop());
+        m_routingTable.Update(toDst);
+
+        RoutingTableEntry toNextHopToDst;
+        m_routingTable.LookupRoute(toDst.GetNextHop(), toNextHopToDst);
+        toNextHopToDst.InsertPrecursor(toOrigin.GetNextHop());
+        m_routingTable.Update(toNextHopToDst);
+
+        toOrigin.InsertPrecursor(toDst.GetNextHop());
+        m_routingTable.Update(toOrigin);
+
+        RoutingTableEntry toNextHopToOrigin;
+        m_routingTable.LookupRoute(toOrigin.GetNextHop(), toNextHopToOrigin);
+        toNextHopToOrigin.InsertPrecursor(toDst.GetNextHop());
+        m_routingTable.Update(toNextHopToOrigin);
+    }
+    SocketIpTtlTag tag;
+    p->RemovePacketTag(tag);
+    if (tag.GetTtl() < 2)
+    {
+        NS_LOG_DEBUG("TTL exceeded. Drop RREP destination " << dst << " origin "
+                                                            << rrepHeader.GetOrigin());
+        return;
+    }
+
+    Ptr<Packet> packet = Create<Packet>();
+    SocketIpTtlTag ttl;
+    ttl.SetTtl(tag.GetTtl() - 1);
+    packet->AddPacketTag(ttl);
+    packet->AddHeader(rrepHeader);
+    TypeHeader tHeader(AODVTYPE_RREP);
+    packet->AddHeader(tHeader);
+    Ptr<Socket> socket = FindSocketWithInterfaceAddress(toOrigin.GetInterface());
+    NS_ASSERT(socket);
+    socket->SendTo(packet, 0, InetSocketAddress(toOrigin.GetNextHop(), RAODV_PORT));
+}
+
+void
+RoutingProtocol::RecvReplyAck(Ipv4Address neighbor)
+{
+    NS_LOG_FUNCTION(this);
+    RoutingTableEntry rt;
+    if (m_routingTable.LookupRoute(neighbor, rt))
+    {
+        rt.m_ackTimer.Cancel();
+        rt.SetFlag(VALID);
+        m_routingTable.Update(rt);
+    }
+}
+
+void
+RoutingProtocol::ProcessHello(const RrepHeader& rrepHeader, Ipv4Address receiver)
+{
+    NS_LOG_FUNCTION(this << "from " << rrepHeader.GetDst());
+    /*
+     *  Whenever a node receives a Hello message from a neighbor, the node
+     * SHOULD make sure that it has an active route to the neighbor, and
+     * create one if necessary.
+     */
+    RoutingTableEntry toNeighbor;
+    if (!m_routingTable.LookupRoute(rrepHeader.GetDst(), toNeighbor))
+    {
+        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver));
+        RoutingTableEntry newEntry(
+            /*dev=*/dev,
+            /*dst=*/rrepHeader.GetDst(),
+            /*vSeqNo=*/true,
+            /*seqNo=*/rrepHeader.GetDstSeqno(),
+            /*iface=*/m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0),
+            /*hops=*/1,
+            /*nextHop=*/rrepHeader.GetDst(),
+            /*lifetime=*/rrepHeader.GetLifeTime());
+        m_routingTable.AddRoute(newEntry);
+    }
+    else
+    {
+        toNeighbor.SetLifeTime(
+            std::max(Time(m_allowedHelloLoss * m_helloInterval), toNeighbor.GetLifeTime()));
+        toNeighbor.SetSeqNo(rrepHeader.GetDstSeqno());
+        toNeighbor.SetValidSeqNo(true);
+        toNeighbor.SetFlag(VALID);
+        toNeighbor.SetOutputDevice(m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(receiver)));
+        toNeighbor.SetInterface(m_ipv4->GetAddress(m_ipv4->GetInterfaceForAddress(receiver), 0));
+        toNeighbor.SetHop(1);
+        toNeighbor.SetNextHop(rrepHeader.GetDst());
+        m_routingTable.Update(toNeighbor);
+    }
+    if (m_enableHello)
+    {
+        m_nb.Update(rrepHeader.GetDst(), Time(m_allowedHelloLoss * m_helloInterval));
+    }
+}
+
+void
+RoutingProtocol::RecvError(Ptr<Packet> p, Ipv4Address src)
+{
+    NS_LOG_FUNCTION(this << " from " << src);
+    RerrHeader rerrHeader;
+    p->RemoveHeader(rerrHeader);
+    std::map<Ipv4Address, uint32_t> dstWithNextHopSrc;
+    std::map<Ipv4Address, uint32_t> unreachable;
+    m_routingTable.GetListOfDestinationWithNextHop(src, dstWithNextHopSrc);
+    std::pair<Ipv4Address, uint32_t> un;
+    while (rerrHeader.RemoveUnDestination(un))
+    {
+        for (auto i = dstWithNextHopSrc.begin(); i != dstWithNextHopSrc.end(); ++i)
+        {
+            if (i->first == un.first)
+            {
+                unreachable.insert(un);
+            }
+        }
+    }
+
+    std::vector<Ipv4Address> precursors;
+    for (auto i = unreachable.begin(); i != unreachable.end();)
+    {
+        if (!rerrHeader.AddUnDestination(i->first, i->second))
+        {
+            TypeHeader typeHeader(AODVTYPE_RERR);
+            Ptr<Packet> packet = Create<Packet>();
+            SocketIpTtlTag tag;
+            tag.SetTtl(1);
+            packet->AddPacketTag(tag);
+            packet->AddHeader(rerrHeader);
+            packet->AddHeader(typeHeader);
+            SendRerrMessage(packet, precursors);
+            rerrHeader.Clear();
+        }
+        else
+        {
+            RoutingTableEntry toDst;
+            m_routingTable.LookupRoute(i->first, toDst);
+            toDst.GetPrecursors(precursors);
+            ++i;
+        }
+    }
+    if (rerrHeader.GetDestCount() != 0)
+    {
+        TypeHeader typeHeader(AODVTYPE_RERR);
+        Ptr<Packet> packet = Create<Packet>();
+        SocketIpTtlTag tag;
+        tag.SetTtl(1);
+        packet->AddPacketTag(tag);
+        packet->AddHeader(rerrHeader);
+        packet->AddHeader(typeHeader);
+        SendRerrMessage(packet, precursors);
+    }
+    m_routingTable.InvalidateRoutesWithDst(unreachable);
+}
+
+void
+RoutingProtocol::RouteRequestTimerExpire(Ipv4Address dst)
+{
+    NS_LOG_LOGIC(this);
+    RoutingTableEntry toDst;
+    if (m_routingTable.LookupValidRoute(dst, toDst))
+    {
+        SendPacketFromQueue(dst, toDst.GetRoute());
+        NS_LOG_LOGIC("route to " << dst << " found");
+        return;
+    }
+    /*
+     *  If a route discovery has been attempted RreqRetries times at the maximum TTL without
+     *  receiving any RREP, all data packets destined for the corresponding destination SHOULD be
+     *  dropped from the buffer and a Destination Unreachable message SHOULD be delivered to the
+     * application.
+     */
+    if (toDst.GetRreqCnt() == m_rreqRetries)
+    {
+        NS_LOG_LOGIC("route discovery to " << dst << " has been attempted RreqRetries ("
+                                           << m_rreqRetries << ") times with ttl "
+                                           << m_netDiameter);
+        m_addressReqTimer.erase(dst);
+        m_routingTable.DeleteRoute(dst);
+        NS_LOG_DEBUG("Route not found. Drop all packets with dst " << dst);
+        m_queue.DropPacketWithDst(dst);
+        return;
+    }
+
+    if (toDst.GetFlag() == IN_SEARCH)
+    {
+        NS_LOG_LOGIC("Resend RREQ to " << dst << " previous ttl " << toDst.GetHop());
+        SendRequest(dst);
+    }
+    else
+    {
+        NS_LOG_DEBUG("Route down. Stop search. Drop packet with destination " << dst);
+        m_addressReqTimer.erase(dst);
+        m_routingTable.DeleteRoute(dst);
+        m_queue.DropPacketWithDst(dst);
+    }
+}
+
+void
+RoutingProtocol::HelloTimerExpire()
+{
+    NS_LOG_FUNCTION(this);
+    Time offset = Time(Seconds(0));
+    if (m_lastBcastTime > Time(Seconds(0)))
+    {
+        offset = Simulator::Now() - m_lastBcastTime;
+        NS_LOG_DEBUG("Hello deferred due to last bcast at:" << m_lastBcastTime);
+    }
+    else
+    {
+        SendHello();
+    }
+    m_htimer.Cancel();
+    Time diff = m_helloInterval - offset;
+    m_htimer.Schedule(std::max(Time(Seconds(0)), diff));
+    m_lastBcastTime = Time(Seconds(0));
+}
+
+void
+RoutingProtocol::RreqRateLimitTimerExpire()
+{
+    NS_LOG_FUNCTION(this);
+    m_rreqCount = 0;
+    m_rreqRateLimitTimer.Schedule(Seconds(1));
+}
+
+void
+RoutingProtocol::RerrRateLimitTimerExpire()
+{
+    NS_LOG_FUNCTION(this);
+    m_rerrCount = 0;
+    m_rerrRateLimitTimer.Schedule(Seconds(1));
+}
+
+void
+RoutingProtocol::AckTimerExpire(Ipv4Address neighbor, Time blacklistTimeout)
+{
+    NS_LOG_FUNCTION(this);
+    m_routingTable.MarkLinkAsUnidirectional(neighbor, blacklistTimeout);
+}
+
+void
+RoutingProtocol::SendHello()
+{
+    NS_LOG_FUNCTION(this);
+    /* Broadcast a RREP with TTL = 1 with the RREP message fields set as follows:
+     *   Destination IP Address         The node's IP address.
+     *   Destination Sequence Number    The node's latest sequence number.
+     *   Hop Count                      0
+     *   Lifetime                       AllowedHelloLoss * HelloInterval
+     */
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ptr<Socket> socket = j->first;
+        Ipv4InterfaceAddress iface = j->second;
+        RrepHeader helloHeader(/*prefixSize=*/0,
+                               /*hopCount=*/0,
+                               /*dst=*/iface.GetLocal(),
+                               /*dstSeqNo=*/m_seqNo,
+                               /*origin=*/iface.GetLocal(),
+                               /*lifetime=*/Time(m_allowedHelloLoss * m_helloInterval));
+        Ptr<Packet> packet = Create<Packet>();
+        SocketIpTtlTag tag;
+        tag.SetTtl(1);
+        packet->AddPacketTag(tag);
+        packet->AddHeader(helloHeader);
+        TypeHeader tHeader(AODVTYPE_RREP);
+        packet->AddHeader(tHeader);
+        // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
+        Ipv4Address destination;
+        if (iface.GetMask() == Ipv4Mask::GetOnes())
+        {
+            destination = Ipv4Address("255.255.255.255");
+        }
+        else
+        {
+            destination = iface.GetBroadcast();
+        }
+        Time jitter = Time(MilliSeconds(m_uniformRandomVariable->GetInteger(0, 10)));
+        Simulator::Schedule(jitter, &RoutingProtocol::SendTo, this, socket, packet, destination);
+    }
+}
+
+void
+RoutingProtocol::SendPacketFromQueue(Ipv4Address dst, Ptr<Ipv4Route> route)
+{
+    NS_LOG_FUNCTION(this);
+    QueueEntry queueEntry;
+    while (m_queue.Dequeue(dst, queueEntry))
+    {
+        DeferredRouteOutputTag tag;
+        Ptr<Packet> p = ConstCast<Packet>(queueEntry.GetPacket());
+        if (p->RemovePacketTag(tag) && tag.GetInterface() != -1 &&
+            tag.GetInterface() != m_ipv4->GetInterfaceForDevice(route->GetOutputDevice()))
+        {
+            NS_LOG_DEBUG("Output device doesn't match. Dropped.");
+            return;
+        }
+        UnicastForwardCallback ucb = queueEntry.GetUnicastForwardCallback();
+        Ipv4Header header = queueEntry.GetIpv4Header();
+        header.SetSource(route->GetSource());
+        header.SetTtl(header.GetTtl() +
+                      1); // compensate extra TTL decrement by fake loopback routing
+        ucb(route, p, header);
+    }
+}
+
+void
+RoutingProtocol::SendRerrWhenBreaksLinkToNextHop(Ipv4Address nextHop)
+{
+    NS_LOG_FUNCTION(this << nextHop);
+    RerrHeader rerrHeader;
+    std::vector<Ipv4Address> precursors;
+    std::map<Ipv4Address, uint32_t> unreachable;
+
+    RoutingTableEntry toNextHop;
+    if (!m_routingTable.LookupRoute(nextHop, toNextHop))
+    {
+        return;
+    }
+    toNextHop.GetPrecursors(precursors);
+    rerrHeader.AddUnDestination(nextHop, toNextHop.GetSeqNo());
+    m_routingTable.GetListOfDestinationWithNextHop(nextHop, unreachable);
+    for (auto i = unreachable.begin(); i != unreachable.end();)
+    {
+        if (!rerrHeader.AddUnDestination(i->first, i->second))
+        {
+            NS_LOG_LOGIC("Send RERR message with maximum size.");
+            TypeHeader typeHeader(AODVTYPE_RERR);
+            Ptr<Packet> packet = Create<Packet>();
+            SocketIpTtlTag tag;
+            tag.SetTtl(1);
+            packet->AddPacketTag(tag);
+            packet->AddHeader(rerrHeader);
+            packet->AddHeader(typeHeader);
+            SendRerrMessage(packet, precursors);
+            rerrHeader.Clear();
+        }
+        else
+        {
+            RoutingTableEntry toDst;
+            m_routingTable.LookupRoute(i->first, toDst);
+            toDst.GetPrecursors(precursors);
+            ++i;
+        }
+    }
+    if (rerrHeader.GetDestCount() != 0)
+    {
+        TypeHeader typeHeader(AODVTYPE_RERR);
+        Ptr<Packet> packet = Create<Packet>();
+        SocketIpTtlTag tag;
+        tag.SetTtl(1);
+        packet->AddPacketTag(tag);
+        packet->AddHeader(rerrHeader);
+        packet->AddHeader(typeHeader);
+        SendRerrMessage(packet, precursors);
+    }
+    unreachable.insert(std::make_pair(nextHop, toNextHop.GetSeqNo()));
+    m_routingTable.InvalidateRoutesWithDst(unreachable);
+}
+
+void
+RoutingProtocol::SendRerrWhenNoRouteToForward(Ipv4Address dst,
+                                              uint32_t dstSeqNo,
+                                              Ipv4Address origin)
+{
+    NS_LOG_FUNCTION(this);
+    // A node SHOULD NOT originate more than RERR_RATELIMIT RERR messages per second.
+    if (m_rerrCount == m_rerrRateLimit)
+    {
+        // Just make sure that the RerrRateLimit timer is running and will expire
+        NS_ASSERT(m_rerrRateLimitTimer.IsRunning());
+        // discard the packet and return
+        NS_LOG_LOGIC("RerrRateLimit reached at "
+                     << Simulator::Now().As(Time::S) << " with timer delay left "
+                     << m_rerrRateLimitTimer.GetDelayLeft().As(Time::S) << "; suppressing RERR");
+        return;
+    }
+    RerrHeader rerrHeader;
+    rerrHeader.AddUnDestination(dst, dstSeqNo);
+    RoutingTableEntry toOrigin;
+    Ptr<Packet> packet = Create<Packet>();
+    SocketIpTtlTag tag;
+    tag.SetTtl(1);
+    packet->AddPacketTag(tag);
+    packet->AddHeader(rerrHeader);
+    packet->AddHeader(TypeHeader(AODVTYPE_RERR));
+    if (m_routingTable.LookupValidRoute(origin, toOrigin))
+    {
+        Ptr<Socket> socket = FindSocketWithInterfaceAddress(toOrigin.GetInterface());
+        NS_ASSERT(socket);
+        NS_LOG_LOGIC("Unicast RERR to the source of the data transmission");
+        socket->SendTo(packet, 0, InetSocketAddress(toOrigin.GetNextHop(), RAODV_PORT));
+    }
+    else
+    {
+        for (auto i = m_socketAddresses.begin(); i != m_socketAddresses.end(); ++i)
+        {
+            Ptr<Socket> socket = i->first;
+            Ipv4InterfaceAddress iface = i->second;
+            NS_ASSERT(socket);
+            NS_LOG_LOGIC("Broadcast RERR message from interface " << iface.GetLocal());
+            // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
+            Ipv4Address destination;
+            if (iface.GetMask() == Ipv4Mask::GetOnes())
+            {
+                destination = Ipv4Address("255.255.255.255");
+            }
+            else
+            {
+                destination = iface.GetBroadcast();
+            }
+            socket->SendTo(packet->Copy(), 0, InetSocketAddress(destination, RAODV_PORT));
+        }
+    }
+}
+
+void
+RoutingProtocol::SendRerrMessage(Ptr<Packet> packet, std::vector<Ipv4Address> precursors)
+{
+    NS_LOG_FUNCTION(this);
+
+    if (precursors.empty())
+    {
+        NS_LOG_LOGIC("No precursors");
+        return;
+    }
+    // A node SHOULD NOT originate more than RERR_RATELIMIT RERR messages per second.
+    if (m_rerrCount == m_rerrRateLimit)
+    {
+        // Just make sure that the RerrRateLimit timer is running and will expire
+        NS_ASSERT(m_rerrRateLimitTimer.IsRunning());
+        // discard the packet and return
+        NS_LOG_LOGIC("RerrRateLimit reached at "
+                     << Simulator::Now().As(Time::S) << " with timer delay left "
+                     << m_rerrRateLimitTimer.GetDelayLeft().As(Time::S) << "; suppressing RERR");
+        return;
+    }
+    // If there is only one precursor, RERR SHOULD be unicast toward that precursor
+    if (precursors.size() == 1)
+    {
+        RoutingTableEntry toPrecursor;
+        if (m_routingTable.LookupValidRoute(precursors.front(), toPrecursor))
+        {
+            Ptr<Socket> socket = FindSocketWithInterfaceAddress(toPrecursor.GetInterface());
+            NS_ASSERT(socket);
+            NS_LOG_LOGIC("one precursor => unicast RERR to "
+                         << toPrecursor.GetDestination() << " from "
+                         << toPrecursor.GetInterface().GetLocal());
+            Simulator::Schedule(Time(MilliSeconds(m_uniformRandomVariable->GetInteger(0, 10))),
+                                &RoutingProtocol::SendTo,
+                                this,
+                                socket,
+                                packet,
+                                precursors.front());
+            m_rerrCount++;
+        }
+        return;
+    }
+
+    //  Should only transmit RERR on those interfaces which have precursor nodes for the broken
+    //  route
+    std::vector<Ipv4InterfaceAddress> ifaces;
+    RoutingTableEntry toPrecursor;
+    for (auto i = precursors.begin(); i != precursors.end(); ++i)
+    {
+        if (m_routingTable.LookupValidRoute(*i, toPrecursor) &&
+            std::find(ifaces.begin(), ifaces.end(), toPrecursor.GetInterface()) == ifaces.end())
+        {
+            ifaces.push_back(toPrecursor.GetInterface());
+        }
+    }
+
+    for (auto i = ifaces.begin(); i != ifaces.end(); ++i)
+    {
+        Ptr<Socket> socket = FindSocketWithInterfaceAddress(*i);
+        NS_ASSERT(socket);
+        NS_LOG_LOGIC("Broadcast RERR message from interface " << i->GetLocal());
+        // std::cout << "Broadcast RERR message from interface " << i->GetLocal () << std::endl;
+        // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
+        Ptr<Packet> p = packet->Copy();
+        Ipv4Address destination;
+        if (i->GetMask() == Ipv4Mask::GetOnes())
+        {
+            destination = Ipv4Address("255.255.255.255");
+        }
+        else
+        {
+            destination = i->GetBroadcast();
+        }
+        Simulator::Schedule(Time(MilliSeconds(m_uniformRandomVariable->GetInteger(0, 10))),
+                            &RoutingProtocol::SendTo,
+                            this,
+                            socket,
+                            p,
+                            destination);
+    }
+}
+
+Ptr<Socket>
+RoutingProtocol::FindSocketWithInterfaceAddress(Ipv4InterfaceAddress addr) const
+{
+    NS_LOG_FUNCTION(this << addr);
+    for (auto j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
+    {
+        Ptr<Socket> socket = j->first;
+        Ipv4InterfaceAddress iface = j->second;
+        if (iface == addr)
+        {
+            return socket;
+        }
+    }
+    Ptr<Socket> socket;
+    return socket;
+}
+
+Ptr<Socket>
+RoutingProtocol::FindSubnetBroadcastSocketWithInterfaceAddress(Ipv4InterfaceAddress addr) const
+{
+    NS_LOG_FUNCTION(this << addr);
+    for (auto j = m_socketSubnetBroadcastAddresses.begin();
+         j != m_socketSubnetBroadcastAddresses.end();
+         ++j)
+    {
+        Ptr<Socket> socket = j->first;
+        Ipv4InterfaceAddress iface = j->second;
+        if (iface == addr)
+        {
+            return socket;
+        }
+    }
+    Ptr<Socket> socket;
+    return socket;
+}
+
+void
+RoutingProtocol::DoInitialize()
+{
+    NS_LOG_FUNCTION(this);
+    uint32_t startTime;
+    if (m_enableHello)
+    {
+        m_htimer.SetFunction(&RoutingProtocol::HelloTimerExpire, this);
+        startTime = m_uniformRandomVariable->GetInteger(0, 100);
+        NS_LOG_DEBUG("Starting at time " << startTime << "ms");
+        m_htimer.Schedule(MilliSeconds(startTime));
+    }
+    Ipv4RoutingProtocol::DoInitialize();
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-routing-protocol.h b/src/raodv/model/raodv-routing-protocol.h
new file mode 100644
index 000000000..1aa823e69
--- /dev/null
+++ b/src/raodv/model/raodv-routing-protocol.h
@@ -0,0 +1,500 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#ifndef RAODVROUTINGPROTOCOL_H
+#define RAODVROUTINGPROTOCOL_H
+
+#include "raodv-dpd.h"
+#include "raodv-neighbor.h"
+#include "raodv-packet.h"
+#include "raodv-rqueue.h"
+#include "raodv-rtable.h"
+
+#include "ns3/ipv4-interface.h"
+#include "ns3/ipv4-l3-protocol.h"
+#include "ns3/ipv4-routing-protocol.h"
+#include "ns3/node.h"
+#include "ns3/output-stream-wrapper.h"
+#include "ns3/random-variable-stream.h"
+
+#include <map>
+
+namespace ns3
+{
+
+class WifiMpdu;
+enum WifiMacDropReason : uint8_t; // opaque enum declaration
+
+namespace raodv
+{
+/**
+ * \ingroup raodv
+ *
+ * \brief RAODV routing protocol
+ */
+class RoutingProtocol : public Ipv4RoutingProtocol
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+    static const uint32_t RAODV_PORT;
+
+    /// constructor
+    RoutingProtocol();
+    ~RoutingProtocol() override;
+    void DoDispose() override;
+
+    // Inherited from Ipv4RoutingProtocol
+    Ptr<Ipv4Route> RouteOutput(Ptr<Packet> p,
+                               const Ipv4Header& header,
+                               Ptr<NetDevice> oif,
+                               Socket::SocketErrno& sockerr) override;
+    bool RouteInput(Ptr<const Packet> p,
+                    const Ipv4Header& header,
+                    Ptr<const NetDevice> idev,
+                    const UnicastForwardCallback& ucb,
+                    const MulticastForwardCallback& mcb,
+                    const LocalDeliverCallback& lcb,
+                    const ErrorCallback& ecb) override;
+    void NotifyInterfaceUp(uint32_t interface) override;
+    void NotifyInterfaceDown(uint32_t interface) override;
+    void NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address) override;
+    void NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address) override;
+    void SetIpv4(Ptr<Ipv4> ipv4) override;
+    void PrintRoutingTable(Ptr<OutputStreamWrapper> stream,
+                           Time::Unit unit = Time::S) const override;
+
+    // Handle protocol parameters
+    /**
+     * Get maximum queue time
+     * \returns the maximum queue time
+     */
+    Time GetMaxQueueTime() const
+    {
+        return m_maxQueueTime;
+    }
+
+    /**
+     * Set the maximum queue time
+     * \param t the maximum queue time
+     */
+    void SetMaxQueueTime(Time t);
+
+    /**
+     * Get the maximum queue length
+     * \returns the maximum queue length
+     */
+    uint32_t GetMaxQueueLen() const
+    {
+        return m_maxQueueLen;
+    }
+
+    /**
+     * Set the maximum queue length
+     * \param len the maximum queue length
+     */
+    void SetMaxQueueLen(uint32_t len);
+
+    /**
+     * Get destination only flag
+     * \returns the destination only flag
+     */
+    bool GetDestinationOnlyFlag() const
+    {
+        return m_destinationOnly;
+    }
+
+    /**
+     * Set destination only flag
+     * \param f the destination only flag
+     */
+    void SetDestinationOnlyFlag(bool f)
+    {
+        m_destinationOnly = f;
+    }
+
+    /**
+     * Get gratuitous reply flag
+     * \returns the gratuitous reply flag
+     */
+    bool GetGratuitousReplyFlag() const
+    {
+        return m_gratuitousReply;
+    }
+
+    /**
+     * Set gratuitous reply flag
+     * \param f the gratuitous reply flag
+     */
+    void SetGratuitousReplyFlag(bool f)
+    {
+        m_gratuitousReply = f;
+    }
+
+    /**
+     * Set hello enable
+     * \param f the hello enable flag
+     */
+    void SetHelloEnable(bool f)
+    {
+        m_enableHello = f;
+    }
+
+    /**
+     * Get hello enable flag
+     * \returns the enable hello flag
+     */
+    bool GetHelloEnable() const
+    {
+        return m_enableHello;
+    }
+
+    /**
+     * Set broadcast enable flag
+     * \param f enable broadcast flag
+     */
+    void SetBroadcastEnable(bool f)
+    {
+        m_enableBroadcast = f;
+    }
+
+    /**
+     * Get broadcast enable flag
+     * \returns the broadcast enable flag
+     */
+    bool GetBroadcastEnable() const
+    {
+        return m_enableBroadcast;
+    }
+
+    /**
+     * Assign a fixed random variable stream number to the random variables
+     * used by this model.  Return the number of streams (possibly zero) that
+     * have been assigned.
+     *
+     * \param stream first stream index to use
+     * \return the number of stream indices assigned by this model
+     */
+    int64_t AssignStreams(int64_t stream);
+
+  protected:
+    void DoInitialize() override;
+
+  private:
+    /**
+     * Notify that an MPDU was dropped.
+     *
+     * \param reason the reason why the MPDU was dropped
+     * \param mpdu the dropped MPDU
+     */
+    void NotifyTxError(WifiMacDropReason reason, Ptr<const WifiMpdu> mpdu);
+
+    // Protocol parameters.
+    uint32_t m_rreqRetries; ///< Maximum number of retransmissions of RREQ with TTL = NetDiameter to
+                            ///< discover a route
+    uint16_t m_ttlStart;    ///< Initial TTL value for RREQ.
+    uint16_t m_ttlIncrement; ///< TTL increment for each attempt using the expanding ring search for
+                             ///< RREQ dissemination.
+    uint16_t m_ttlThreshold; ///< Maximum TTL value for expanding ring search, TTL = NetDiameter is
+                             ///< used beyond this value.
+    uint16_t m_timeoutBuffer;  ///< Provide a buffer for the timeout.
+    uint16_t m_rreqRateLimit;  ///< Maximum number of RREQ per second.
+    uint16_t m_rerrRateLimit;  ///< Maximum number of REER per second.
+    Time m_activeRouteTimeout; ///< Period of time during which the route is considered to be valid.
+    uint32_t m_netDiameter; ///< Net diameter measures the maximum possible number of hops between
+                            ///< two nodes in the network
+    /**
+     * NodeTraversalTime is a conservative estimate of the average one hop traversal time for
+     * packets and should include queuing delays, interrupt processing times and transfer times.
+     */
+    Time m_nodeTraversalTime;
+    Time m_netTraversalTime;  ///< Estimate of the average net traversal time.
+    Time m_pathDiscoveryTime; ///< Estimate of maximum time needed to find route in network.
+    Time m_myRouteTimeout;    ///< Value of lifetime field in RREP generating by this node.
+    /**
+     * Every HelloInterval the node checks whether it has sent a broadcast  within the last
+     * HelloInterval. If it has not, it MAY broadcast a  Hello message
+     */
+    Time m_helloInterval;
+    uint32_t m_allowedHelloLoss; ///< Number of hello messages which may be loss for valid link
+    /**
+     * DeletePeriod is intended to provide an upper bound on the time for which an upstream node A
+     * can have a neighbor B as an active next hop for destination D, while B has invalidated the
+     * route to D.
+     */
+    Time m_deletePeriod;
+    Time m_nextHopWait;      ///< Period of our waiting for the neighbour's RREP_ACK
+    Time m_blackListTimeout; ///< Time for which the node is put into the blacklist
+    uint32_t m_maxQueueLen;  ///< The maximum number of packets that we allow a routing protocol to
+                             ///< buffer.
+    Time m_maxQueueTime;     ///< The maximum period of time that a routing protocol is allowed to
+                             ///< buffer a packet for.
+    bool m_destinationOnly;  ///< Indicates only the destination may respond to this RREQ.
+    bool m_gratuitousReply;  ///< Indicates whether a gratuitous RREP should be unicast to the node
+                             ///< originated route discovery.
+    bool m_enableHello;      ///< Indicates whether a hello messages enable
+    bool m_enableBroadcast;  ///< Indicates whether a a broadcast data packets forwarding enable
+
+    /// IP protocol
+    Ptr<Ipv4> m_ipv4;
+    /// Raw unicast socket per each IP interface, map socket -> iface address (IP + mask)
+    std::map<Ptr<Socket>, Ipv4InterfaceAddress> m_socketAddresses;
+    /// Raw subnet directed broadcast socket per each IP interface, map socket -> iface address (IP
+    /// + mask)
+    std::map<Ptr<Socket>, Ipv4InterfaceAddress> m_socketSubnetBroadcastAddresses;
+    /// Loopback device used to defer RREQ until packet will be fully formed
+    Ptr<NetDevice> m_lo;
+
+    /// Routing table
+    RoutingTable m_routingTable;
+    /// A "drop-front" queue used by the routing layer to buffer packets to which it does not have a
+    /// route.
+    RequestQueue m_queue;
+    /// Broadcast ID
+    uint32_t m_requestId;
+    /// Request sequence number
+    uint32_t m_seqNo;
+    /// Handle duplicated RREQ
+    IdCache m_rreqIdCache;
+    /// Handle duplicated broadcast/multicast packets
+    DuplicatePacketDetection m_dpd;
+    /// Handle neighbors
+    Neighbors m_nb;
+    /// Number of RREQs used for RREQ rate control
+    uint16_t m_rreqCount;
+    /// Number of RERRs used for RERR rate control
+    uint16_t m_rerrCount;
+
+  private:
+    /// Start protocol operation
+    void Start();
+    /**
+     * Queue packet and send route request
+     *
+     * \param p the packet to route
+     * \param header the IP header
+     * \param ucb the UnicastForwardCallback function
+     * \param ecb the ErrorCallback function
+     */
+    void DeferredRouteOutput(Ptr<const Packet> p,
+                             const Ipv4Header& header,
+                             UnicastForwardCallback ucb,
+                             ErrorCallback ecb);
+    /**
+     * If route exists and is valid, forward packet.
+     *
+     * \param p the packet to route
+     * \param header the IP header
+     * \param ucb the UnicastForwardCallback function
+     * \param ecb the ErrorCallback function
+     * \returns true if forwarded
+     */
+    bool Forwarding(Ptr<const Packet> p,
+                    const Ipv4Header& header,
+                    UnicastForwardCallback ucb,
+                    ErrorCallback ecb);
+    /**
+     * Repeated attempts by a source node at route discovery for a single destination
+     * use the expanding ring search technique.
+     * \param dst the destination IP address
+     */
+    void ScheduleRreqRetry(Ipv4Address dst);
+    /**
+     * Set lifetime field in routing table entry to the maximum of existing lifetime and lt, if the
+     * entry exists
+     * \param addr destination address
+     * \param lt proposed time for lifetime field in routing table entry for destination with
+     * address addr.
+     * \return true if route to destination address addr exist
+     */
+    bool UpdateRouteLifeTime(Ipv4Address addr, Time lt);
+    /**
+     * Update neighbor record.
+     * \param receiver is supposed to be my interface
+     * \param sender is supposed to be IP address of my neighbor.
+     */
+    void UpdateRouteToNeighbor(Ipv4Address sender, Ipv4Address receiver);
+    /**
+     * Test whether the provided address is assigned to an interface on this node
+     * \param src the source IP address
+     * \returns true if the IP address is the node's IP address
+     */
+    bool IsMyOwnAddress(Ipv4Address src);
+    /**
+     * Find unicast socket with local interface address iface
+     *
+     * \param iface the interface
+     * \returns the socket associated with the interface
+     */
+    Ptr<Socket> FindSocketWithInterfaceAddress(Ipv4InterfaceAddress iface) const;
+    /**
+     * Find subnet directed broadcast socket with local interface address iface
+     *
+     * \param iface the interface
+     * \returns the socket associated with the interface
+     */
+    Ptr<Socket> FindSubnetBroadcastSocketWithInterfaceAddress(Ipv4InterfaceAddress iface) const;
+    /**
+     * Process hello message
+     *
+     * \param rrepHeader RREP message header
+     * \param receiverIfaceAddr receiver interface IP address
+     */
+    void ProcessHello(const RrepHeader& rrepHeader, Ipv4Address receiverIfaceAddr);
+    /**
+     * Create loopback route for given header
+     *
+     * \param header the IP header
+     * \param oif the output interface net device
+     * \returns the route
+     */
+    Ptr<Ipv4Route> LoopbackRoute(const Ipv4Header& header, Ptr<NetDevice> oif) const;
+
+    /**
+     * \name Receive control packets
+     * @{
+     */
+    /**
+     * Receive and process control packet
+     * \param socket input socket
+     */
+    void RecvRAodv(Ptr<Socket> socket);
+    /**
+     * Receive RREQ
+     * \param p packet
+     * \param receiver receiver address
+     * \param src sender address
+     */
+    void RecvRequest(Ptr<Packet> p, Ipv4Address receiver, Ipv4Address src);
+    /**
+     * Receive RREP
+     * \param p packet
+     * \param my destination address
+     * \param src sender address
+     */
+    void RecvReply(Ptr<Packet> p, Ipv4Address my, Ipv4Address src);
+    /**
+     * Receive RREP_ACK
+     * \param neighbor neighbor address
+     */
+    void RecvReplyAck(Ipv4Address neighbor);
+    /**
+     * Receive RERR
+     * \param p packet
+     * \param src sender address
+     */
+    /// Receive  from node with address src
+    void RecvError(Ptr<Packet> p, Ipv4Address src);
+    /** @} */
+
+    /**
+     * \name Send
+     * @{
+     */
+    /** Forward packet from route request queue
+     * \param dst destination address
+     * \param route route to use
+     */
+    void SendPacketFromQueue(Ipv4Address dst, Ptr<Ipv4Route> route);
+    /// Send hello
+    void SendHello();
+    /** Send RREQ
+     * \param dst destination address
+     */
+    void SendRequest(Ipv4Address dst);
+    /** Send RREP
+     * \param rreqHeader route request header
+     * \param toOrigin routing table entry to originator
+     */
+    void SendReply(const RreqHeader& rreqHeader, const RoutingTableEntry& toOrigin);
+    /** Send RREP by intermediate node
+     * \param toDst routing table entry to destination
+     * \param toOrigin routing table entry to originator
+     * \param gratRep indicates whether a gratuitous RREP should be unicast to destination
+     */
+    void SendReplyByIntermediateNode(RoutingTableEntry& toDst,
+                                     RoutingTableEntry& toOrigin,
+                                     bool gratRep);
+    /** Send RREP_ACK
+     * \param neighbor neighbor address
+     */
+    void SendReplyAck(Ipv4Address neighbor);
+    /** Initiate RERR
+     * \param nextHop next hop address
+     */
+    void SendRerrWhenBreaksLinkToNextHop(Ipv4Address nextHop);
+    /** Forward RERR
+     * \param packet packet
+     * \param precursors list of addresses of the visited nodes
+     */
+    void SendRerrMessage(Ptr<Packet> packet, std::vector<Ipv4Address> precursors);
+    /**
+     * Send RERR message when no route to forward input packet. Unicast if there is reverse route to
+     * originating node, broadcast otherwise.
+     * \param dst destination node IP address
+     * \param dstSeqNo destination node sequence number
+     * \param origin originating node IP address
+     */
+    void SendRerrWhenNoRouteToForward(Ipv4Address dst, uint32_t dstSeqNo, Ipv4Address origin);
+    /** @} */
+
+    /**
+     * Send packet to destination socket
+     * \param socket destination node socket
+     * \param packet packet to send
+     * \param destination destination node IP address
+     */
+    void SendTo(Ptr<Socket> socket, Ptr<Packet> packet, Ipv4Address destination);
+
+    /// Hello timer
+    Timer m_htimer;
+    /// Schedule next send of hello message
+    void HelloTimerExpire();
+    /// RREQ rate limit timer
+    Timer m_rreqRateLimitTimer;
+    /// Reset RREQ count and schedule RREQ rate limit timer with delay 1 sec.
+    void RreqRateLimitTimerExpire();
+    /// RERR rate limit timer
+    Timer m_rerrRateLimitTimer;
+    /// Reset RERR count and schedule RERR rate limit timer with delay 1 sec.
+    void RerrRateLimitTimerExpire();
+    /// Map IP address + RREQ timer.
+    std::map<Ipv4Address, Timer> m_addressReqTimer;
+    /**
+     * Handle route discovery process
+     * \param dst the destination IP address
+     */
+    void RouteRequestTimerExpire(Ipv4Address dst);
+    /**
+     * Mark link to neighbor node as unidirectional for blacklistTimeout
+     *
+     * \param neighbor the IP address of the neighbor node
+     * \param blacklistTimeout the black list timeout time
+     */
+    void AckTimerExpire(Ipv4Address neighbor, Time blacklistTimeout);
+
+    /// Provides uniform random variables.
+    Ptr<UniformRandomVariable> m_uniformRandomVariable;
+    /// Keep track of the last bcast time
+    Time m_lastBcastTime;
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODVROUTINGPROTOCOL_H */
diff --git a/src/raodv/model/raodv-rqueue.cc b/src/raodv/model/raodv-rqueue.cc
new file mode 100644
index 000000000..f8fd8ddc1
--- /dev/null
+++ b/src/raodv/model/raodv-rqueue.cc
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#include "raodv-rqueue.h"
+
+#include "ns3/ipv4-route.h"
+#include "ns3/log.h"
+#include "ns3/socket.h"
+
+#include <algorithm>
+#include <functional>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("RAodvRequestQueue");
+
+namespace raodv
+{
+uint32_t
+RequestQueue::GetSize()
+{
+    Purge();
+    return m_queue.size();
+}
+
+bool
+RequestQueue::Enqueue(QueueEntry& entry)
+{
+    Purge();
+    for (auto i = m_queue.begin(); i != m_queue.end(); ++i)
+    {
+        if ((i->GetPacket()->GetUid() == entry.GetPacket()->GetUid()) &&
+            (i->GetIpv4Header().GetDestination() == entry.GetIpv4Header().GetDestination()))
+        {
+            return false;
+        }
+    }
+    entry.SetExpireTime(m_queueTimeout);
+    if (m_queue.size() == m_maxLen)
+    {
+        Drop(m_queue.front(), "Drop the most aged packet"); // Drop the most aged packet
+        m_queue.erase(m_queue.begin());
+    }
+    m_queue.push_back(entry);
+    return true;
+}
+
+void
+RequestQueue::DropPacketWithDst(Ipv4Address dst)
+{
+    NS_LOG_FUNCTION(this << dst);
+    Purge();
+    for (auto i = m_queue.begin(); i != m_queue.end(); ++i)
+    {
+        if (i->GetIpv4Header().GetDestination() == dst)
+        {
+            Drop(*i, "DropPacketWithDst ");
+        }
+    }
+    auto new_end = std::remove_if(m_queue.begin(), m_queue.end(), [&](const QueueEntry& en) {
+        return en.GetIpv4Header().GetDestination() == dst;
+    });
+    m_queue.erase(new_end, m_queue.end());
+}
+
+bool
+RequestQueue::Dequeue(Ipv4Address dst, QueueEntry& entry)
+{
+    Purge();
+    for (auto i = m_queue.begin(); i != m_queue.end(); ++i)
+    {
+        if (i->GetIpv4Header().GetDestination() == dst)
+        {
+            entry = *i;
+            m_queue.erase(i);
+            return true;
+        }
+    }
+    return false;
+}
+
+bool
+RequestQueue::Find(Ipv4Address dst)
+{
+    for (auto i = m_queue.begin(); i != m_queue.end(); ++i)
+    {
+        if (i->GetIpv4Header().GetDestination() == dst)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+/**
+ * \brief IsExpired structure
+ */
+struct IsExpired
+{
+    /**
+     * Check if the entry is expired
+     *
+     * \param e QueueEntry entry
+     * \return true if expired, false otherwise
+     */
+    bool operator()(const QueueEntry& e) const
+    {
+        return (e.GetExpireTime() < Seconds(0));
+    }
+};
+
+void
+RequestQueue::Purge()
+{
+    IsExpired pred;
+    for (auto i = m_queue.begin(); i != m_queue.end(); ++i)
+    {
+        if (pred(*i))
+        {
+            Drop(*i, "Drop outdated packet ");
+        }
+    }
+    m_queue.erase(std::remove_if(m_queue.begin(), m_queue.end(), pred), m_queue.end());
+}
+
+void
+RequestQueue::Drop(QueueEntry en, std::string reason)
+{
+    NS_LOG_LOGIC(reason << en.GetPacket()->GetUid() << " " << en.GetIpv4Header().GetDestination());
+    en.GetErrorCallback()(en.GetPacket(), en.GetIpv4Header(), Socket::ERROR_NOROUTETOHOST);
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-rqueue.h b/src/raodv/model/raodv-rqueue.h
new file mode 100644
index 000000000..565c04673
--- /dev/null
+++ b/src/raodv/model/raodv-rqueue.h
@@ -0,0 +1,290 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#ifndef RAODV_RQUEUE_H
+#define RAODV_RQUEUE_H
+
+#include "ns3/ipv4-routing-protocol.h"
+#include "ns3/simulator.h"
+
+#include <vector>
+
+namespace ns3
+{
+namespace raodv
+{
+
+/**
+ * \ingroup raodv
+ * \brief RAODV Queue Entry
+ */
+class QueueEntry
+{
+  public:
+    /// IPv4 routing unicast forward callback typedef
+    typedef Ipv4RoutingProtocol::UnicastForwardCallback UnicastForwardCallback;
+    /// IPv4 routing error callback typedef
+    typedef Ipv4RoutingProtocol::ErrorCallback ErrorCallback;
+
+    /**
+     * constructor
+     *
+     * \param pa the packet to add to the queue
+     * \param h the Ipv4Header
+     * \param ucb the UnicastForwardCallback function
+     * \param ecb the ErrorCallback function
+     * \param exp the expiration time
+     */
+    QueueEntry(Ptr<const Packet> pa = nullptr,
+               const Ipv4Header& h = Ipv4Header(),
+               UnicastForwardCallback ucb = UnicastForwardCallback(),
+               ErrorCallback ecb = ErrorCallback(),
+               Time exp = Simulator::Now())
+        : m_packet(pa),
+          m_header(h),
+          m_ucb(ucb),
+          m_ecb(ecb),
+          m_expire(exp + Simulator::Now())
+    {
+    }
+
+    /**
+     * \brief Compare queue entries
+     * \param o QueueEntry to compare
+     * \return true if equal
+     */
+    bool operator==(const QueueEntry& o) const
+    {
+        return ((m_packet == o.m_packet) &&
+                (m_header.GetDestination() == o.m_header.GetDestination()) &&
+                (m_expire == o.m_expire));
+    }
+
+    // Fields
+    /**
+     * Get unicast forward callback
+     * \returns unicast callback
+     */
+    UnicastForwardCallback GetUnicastForwardCallback() const
+    {
+        return m_ucb;
+    }
+
+    /**
+     * Set unicast forward callback
+     * \param ucb The unicast callback
+     */
+    void SetUnicastForwardCallback(UnicastForwardCallback ucb)
+    {
+        m_ucb = ucb;
+    }
+
+    /**
+     * Get error callback
+     * \returns the error callback
+     */
+    ErrorCallback GetErrorCallback() const
+    {
+        return m_ecb;
+    }
+
+    /**
+     * Set error callback
+     * \param ecb The error callback
+     */
+    void SetErrorCallback(ErrorCallback ecb)
+    {
+        m_ecb = ecb;
+    }
+
+    /**
+     * Get packet from entry
+     * \returns the packet
+     */
+    Ptr<const Packet> GetPacket() const
+    {
+        return m_packet;
+    }
+
+    /**
+     * Set packet in entry
+     * \param p The packet
+     */
+    void SetPacket(Ptr<const Packet> p)
+    {
+        m_packet = p;
+    }
+
+    /**
+     * Get IPv4 header
+     * \returns the IPv4 header
+     */
+    Ipv4Header GetIpv4Header() const
+    {
+        return m_header;
+    }
+
+    /**
+     * Set IPv4 header
+     * \param h the IPv4 header
+     */
+    void SetIpv4Header(Ipv4Header h)
+    {
+        m_header = h;
+    }
+
+    /**
+     * Set expire time
+     * \param exp The expiration time
+     */
+    void SetExpireTime(Time exp)
+    {
+        m_expire = exp + Simulator::Now();
+    }
+
+    /**
+     * Get expire time
+     * \returns the expiration time
+     */
+    Time GetExpireTime() const
+    {
+        return m_expire - Simulator::Now();
+    }
+
+  private:
+    /// Data packet
+    Ptr<const Packet> m_packet;
+    /// IP header
+    Ipv4Header m_header;
+    /// Unicast forward callback
+    UnicastForwardCallback m_ucb;
+    /// Error callback
+    ErrorCallback m_ecb;
+    /// Expire time for queue entry
+    Time m_expire;
+};
+
+/**
+ * \ingroup raodv
+ * \brief RAODV route request queue
+ *
+ * Since RAODV is an on demand routing we queue requests while looking for route.
+ */
+class RequestQueue
+{
+  public:
+    /**
+     * constructor
+     *
+     * \param maxLen the maximum length
+     * \param routeToQueueTimeout the route to queue timeout
+     */
+    RequestQueue(uint32_t maxLen, Time routeToQueueTimeout)
+        : m_maxLen(maxLen),
+          m_queueTimeout(routeToQueueTimeout)
+    {
+    }
+
+    /**
+     * Push entry in queue, if there is no entry with the same packet and destination address in
+     * queue.
+     * \param entry the queue entry
+     * \returns true if the entry is queued
+     */
+    bool Enqueue(QueueEntry& entry);
+    /**
+     * Return first found (the earliest) entry for given destination
+     *
+     * \param dst the destination IP address
+     * \param entry the queue entry
+     * \returns true if the entry is dequeued
+     */
+    bool Dequeue(Ipv4Address dst, QueueEntry& entry);
+    /**
+     * Remove all packets with destination IP address dst
+     * \param dst the destination IP address
+     */
+    void DropPacketWithDst(Ipv4Address dst);
+    /**
+     * Finds whether a packet with destination dst exists in the queue
+     *
+     * \param dst the destination IP address
+     * \returns true if an entry with the IP address is found
+     */
+    bool Find(Ipv4Address dst);
+    /**
+     * \returns the number of entries
+     */
+    uint32_t GetSize();
+
+    // Fields
+    /**
+     * Get maximum queue length
+     * \returns the maximum queue length
+     */
+    uint32_t GetMaxQueueLen() const
+    {
+        return m_maxLen;
+    }
+
+    /**
+     * Set maximum queue length
+     * \param len The maximum queue length
+     */
+    void SetMaxQueueLen(uint32_t len)
+    {
+        m_maxLen = len;
+    }
+
+    /**
+     * Get queue timeout
+     * \returns the queue timeout
+     */
+    Time GetQueueTimeout() const
+    {
+        return m_queueTimeout;
+    }
+
+    /**
+     * Set queue timeout
+     * \param t The queue timeout
+     */
+    void SetQueueTimeout(Time t)
+    {
+        m_queueTimeout = t;
+    }
+
+  private:
+    /// The queue
+    std::vector<QueueEntry> m_queue;
+    /// Remove all expired entries
+    void Purge();
+    /**
+     * Notify that packet is dropped from queue by timeout
+     * \param en the queue entry to drop
+     * \param reason the reason to drop the entry
+     */
+    void Drop(QueueEntry en, std::string reason);
+    /// The maximum number of packets that we allow a routing protocol to buffer.
+    uint32_t m_maxLen;
+    /// The maximum period of time that a routing protocol is allowed to buffer a packet for,
+    /// seconds.
+    Time m_queueTimeout;
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODV_RQUEUE_H */
diff --git a/src/raodv/model/raodv-rtable.cc b/src/raodv/model/raodv-rtable.cc
new file mode 100644
index 000000000..9bbb8696d
--- /dev/null
+++ b/src/raodv/model/raodv-rtable.cc
@@ -0,0 +1,491 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "raodv-rtable.h"
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+#include <algorithm>
+#include <iomanip>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("RAodvRoutingTable");
+
+namespace raodv
+{
+
+/*
+ The Routing Table
+ */
+
+RoutingTableEntry::RoutingTableEntry(Ptr<NetDevice> dev,
+                                     Ipv4Address dst,
+                                     bool vSeqNo,
+                                     uint32_t seqNo,
+                                     Ipv4InterfaceAddress iface,
+                                     uint16_t hops,
+                                     Ipv4Address nextHop,
+                                     Time lifetime)
+    : m_ackTimer(Timer::CANCEL_ON_DESTROY),
+      m_validSeqNo(vSeqNo),
+      m_seqNo(seqNo),
+      m_hops(hops),
+      m_lifeTime(lifetime + Simulator::Now()),
+      m_iface(iface),
+      m_flag(VALID),
+      m_reqCount(0),
+      m_blackListState(false),
+      m_blackListTimeout(Simulator::Now())
+{
+    m_ipv4Route = Create<Ipv4Route>();
+    m_ipv4Route->SetDestination(dst);
+    m_ipv4Route->SetGateway(nextHop);
+    m_ipv4Route->SetSource(m_iface.GetLocal());
+    m_ipv4Route->SetOutputDevice(dev);
+}
+
+RoutingTableEntry::~RoutingTableEntry()
+{
+}
+
+bool
+RoutingTableEntry::InsertPrecursor(Ipv4Address id)
+{
+    NS_LOG_FUNCTION(this << id);
+    if (!LookupPrecursor(id))
+    {
+        m_precursorList.push_back(id);
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool
+RoutingTableEntry::LookupPrecursor(Ipv4Address id)
+{
+    NS_LOG_FUNCTION(this << id);
+    for (auto i = m_precursorList.begin(); i != m_precursorList.end(); ++i)
+    {
+        if (*i == id)
+        {
+            NS_LOG_LOGIC("Precursor " << id << " found");
+            return true;
+        }
+    }
+    NS_LOG_LOGIC("Precursor " << id << " not found");
+    return false;
+}
+
+bool
+RoutingTableEntry::DeletePrecursor(Ipv4Address id)
+{
+    NS_LOG_FUNCTION(this << id);
+    auto i = std::remove(m_precursorList.begin(), m_precursorList.end(), id);
+    if (i == m_precursorList.end())
+    {
+        NS_LOG_LOGIC("Precursor " << id << " not found");
+        return false;
+    }
+    else
+    {
+        NS_LOG_LOGIC("Precursor " << id << " found");
+        m_precursorList.erase(i, m_precursorList.end());
+    }
+    return true;
+}
+
+void
+RoutingTableEntry::DeleteAllPrecursors()
+{
+    NS_LOG_FUNCTION(this);
+    m_precursorList.clear();
+}
+
+bool
+RoutingTableEntry::IsPrecursorListEmpty() const
+{
+    return m_precursorList.empty();
+}
+
+void
+RoutingTableEntry::GetPrecursors(std::vector<Ipv4Address>& prec) const
+{
+    NS_LOG_FUNCTION(this);
+    if (IsPrecursorListEmpty())
+    {
+        return;
+    }
+    for (auto i = m_precursorList.begin(); i != m_precursorList.end(); ++i)
+    {
+        bool result = true;
+        for (auto j = prec.begin(); j != prec.end(); ++j)
+        {
+            if (*j == *i)
+            {
+                result = false;
+                break;
+            }
+        }
+        if (result)
+        {
+            prec.push_back(*i);
+        }
+    }
+}
+
+void
+RoutingTableEntry::Invalidate(Time badLinkLifetime)
+{
+    NS_LOG_FUNCTION(this << badLinkLifetime.As(Time::S));
+    if (m_flag == INVALID)
+    {
+        return;
+    }
+    m_flag = INVALID;
+    m_reqCount = 0;
+    m_lifeTime = badLinkLifetime + Simulator::Now();
+}
+
+void
+RoutingTableEntry::Print(Ptr<OutputStreamWrapper> stream, Time::Unit unit /* = Time::S */) const
+{
+    std::ostream* os = stream->GetStream();
+    // Copy the current ostream state
+    std::ios oldState(nullptr);
+    oldState.copyfmt(*os);
+
+    *os << std::resetiosflags(std::ios::adjustfield) << std::setiosflags(std::ios::left);
+
+    std::ostringstream dest;
+    std::ostringstream gw;
+    std::ostringstream iface;
+    std::ostringstream expire;
+    dest << m_ipv4Route->GetDestination();
+    gw << m_ipv4Route->GetGateway();
+    iface << m_iface.GetLocal();
+    expire << std::setprecision(2) << (m_lifeTime - Simulator::Now()).As(unit);
+    *os << std::setw(16) << dest.str();
+    *os << std::setw(16) << gw.str();
+    *os << std::setw(16) << iface.str();
+    *os << std::setw(16);
+    switch (m_flag)
+    {
+    case VALID: {
+        *os << "UP";
+        break;
+    }
+    case INVALID: {
+        *os << "DOWN";
+        break;
+    }
+    case IN_SEARCH: {
+        *os << "IN_SEARCH";
+        break;
+    }
+    }
+
+    *os << std::setw(16) << expire.str();
+    *os << m_hops << std::endl;
+    // Restore the previous ostream state
+    (*os).copyfmt(oldState);
+}
+
+/*
+ The Routing Table
+ */
+
+RoutingTable::RoutingTable(Time t)
+    : m_badLinkLifetime(t)
+{
+}
+
+bool
+RoutingTable::LookupRoute(Ipv4Address id, RoutingTableEntry& rt)
+{
+    NS_LOG_FUNCTION(this << id);
+    Purge();
+    if (m_ipv4AddressEntry.empty())
+    {
+        NS_LOG_LOGIC("Route to " << id << " not found; m_ipv4AddressEntry is empty");
+        return false;
+    }
+    auto i = m_ipv4AddressEntry.find(id);
+    if (i == m_ipv4AddressEntry.end())
+    {
+        NS_LOG_LOGIC("Route to " << id << " not found");
+        return false;
+    }
+    rt = i->second;
+    NS_LOG_LOGIC("Route to " << id << " found");
+    return true;
+}
+
+bool
+RoutingTable::LookupValidRoute(Ipv4Address id, RoutingTableEntry& rt)
+{
+    NS_LOG_FUNCTION(this << id);
+    if (!LookupRoute(id, rt))
+    {
+        NS_LOG_LOGIC("Route to " << id << " not found");
+        return false;
+    }
+    NS_LOG_LOGIC("Route to " << id << " flag is "
+                             << ((rt.GetFlag() == VALID) ? "valid" : "not valid"));
+    return (rt.GetFlag() == VALID);
+}
+
+bool
+RoutingTable::DeleteRoute(Ipv4Address dst)
+{
+    NS_LOG_FUNCTION(this << dst);
+    Purge();
+    if (m_ipv4AddressEntry.erase(dst) != 0)
+    {
+        NS_LOG_LOGIC("Route deletion to " << dst << " successful");
+        return true;
+    }
+    NS_LOG_LOGIC("Route deletion to " << dst << " not successful");
+    return false;
+}
+
+bool
+RoutingTable::AddRoute(RoutingTableEntry& rt)
+{
+    NS_LOG_FUNCTION(this);
+    Purge();
+    if (rt.GetFlag() != IN_SEARCH)
+    {
+        rt.SetRreqCnt(0);
+    }
+    auto result = m_ipv4AddressEntry.insert(std::make_pair(rt.GetDestination(), rt));
+    return result.second;
+}
+
+bool
+RoutingTable::Update(RoutingTableEntry& rt)
+{
+    NS_LOG_FUNCTION(this);
+    auto i = m_ipv4AddressEntry.find(rt.GetDestination());
+    if (i == m_ipv4AddressEntry.end())
+    {
+        NS_LOG_LOGIC("Route update to " << rt.GetDestination() << " fails; not found");
+        return false;
+    }
+    i->second = rt;
+    if (i->second.GetFlag() != IN_SEARCH)
+    {
+        NS_LOG_LOGIC("Route update to " << rt.GetDestination() << " set RreqCnt to 0");
+        i->second.SetRreqCnt(0);
+    }
+    return true;
+}
+
+bool
+RoutingTable::SetEntryState(Ipv4Address id, RouteFlags state)
+{
+    NS_LOG_FUNCTION(this);
+    auto i = m_ipv4AddressEntry.find(id);
+    if (i == m_ipv4AddressEntry.end())
+    {
+        NS_LOG_LOGIC("Route set entry state to " << id << " fails; not found");
+        return false;
+    }
+    i->second.SetFlag(state);
+    i->second.SetRreqCnt(0);
+    NS_LOG_LOGIC("Route set entry state to " << id << ": new state is " << state);
+    return true;
+}
+
+void
+RoutingTable::GetListOfDestinationWithNextHop(Ipv4Address nextHop,
+                                              std::map<Ipv4Address, uint32_t>& unreachable)
+{
+    NS_LOG_FUNCTION(this);
+    Purge();
+    unreachable.clear();
+    for (auto i = m_ipv4AddressEntry.begin(); i != m_ipv4AddressEntry.end(); ++i)
+    {
+        if (i->second.GetNextHop() == nextHop)
+        {
+            NS_LOG_LOGIC("Unreachable insert " << i->first << " " << i->second.GetSeqNo());
+            unreachable.insert(std::make_pair(i->first, i->second.GetSeqNo()));
+        }
+    }
+}
+
+void
+RoutingTable::InvalidateRoutesWithDst(const std::map<Ipv4Address, uint32_t>& unreachable)
+{
+    NS_LOG_FUNCTION(this);
+    Purge();
+    for (auto i = m_ipv4AddressEntry.begin(); i != m_ipv4AddressEntry.end(); ++i)
+    {
+        for (auto j = unreachable.begin(); j != unreachable.end(); ++j)
+        {
+            if ((i->first == j->first) && (i->second.GetFlag() == VALID))
+            {
+                NS_LOG_LOGIC("Invalidate route with destination address " << i->first);
+                i->second.Invalidate(m_badLinkLifetime);
+            }
+        }
+    }
+}
+
+void
+RoutingTable::DeleteAllRoutesFromInterface(Ipv4InterfaceAddress iface)
+{
+    NS_LOG_FUNCTION(this);
+    if (m_ipv4AddressEntry.empty())
+    {
+        return;
+    }
+    for (auto i = m_ipv4AddressEntry.begin(); i != m_ipv4AddressEntry.end();)
+    {
+        if (i->second.GetInterface() == iface)
+        {
+            auto tmp = i;
+            ++i;
+            m_ipv4AddressEntry.erase(tmp);
+        }
+        else
+        {
+            ++i;
+        }
+    }
+}
+
+void
+RoutingTable::Purge()
+{
+    NS_LOG_FUNCTION(this);
+    if (m_ipv4AddressEntry.empty())
+    {
+        return;
+    }
+    for (auto i = m_ipv4AddressEntry.begin(); i != m_ipv4AddressEntry.end();)
+    {
+        if (i->second.GetLifeTime() < Seconds(0))
+        {
+            if (i->second.GetFlag() == INVALID)
+            {
+                auto tmp = i;
+                ++i;
+                m_ipv4AddressEntry.erase(tmp);
+            }
+            else if (i->second.GetFlag() == VALID)
+            {
+                NS_LOG_LOGIC("Invalidate route with destination address " << i->first);
+                i->second.Invalidate(m_badLinkLifetime);
+                ++i;
+            }
+            else
+            {
+                ++i;
+            }
+        }
+        else
+        {
+            ++i;
+        }
+    }
+}
+
+void
+RoutingTable::Purge(std::map<Ipv4Address, RoutingTableEntry>& table) const
+{
+    NS_LOG_FUNCTION(this);
+    if (table.empty())
+    {
+        return;
+    }
+    for (auto i = table.begin(); i != table.end();)
+    {
+        if (i->second.GetLifeTime() < Seconds(0))
+        {
+            if (i->second.GetFlag() == INVALID)
+            {
+                auto tmp = i;
+                ++i;
+                table.erase(tmp);
+            }
+            else if (i->second.GetFlag() == VALID)
+            {
+                NS_LOG_LOGIC("Invalidate route with destination address " << i->first);
+                i->second.Invalidate(m_badLinkLifetime);
+                ++i;
+            }
+            else
+            {
+                ++i;
+            }
+        }
+        else
+        {
+            ++i;
+        }
+    }
+}
+
+bool
+RoutingTable::MarkLinkAsUnidirectional(Ipv4Address neighbor, Time blacklistTimeout)
+{
+    NS_LOG_FUNCTION(this << neighbor << blacklistTimeout.As(Time::S));
+    auto i = m_ipv4AddressEntry.find(neighbor);
+    if (i == m_ipv4AddressEntry.end())
+    {
+        NS_LOG_LOGIC("Mark link unidirectional to  " << neighbor << " fails; not found");
+        return false;
+    }
+    i->second.SetUnidirectional(true);
+    i->second.SetBlacklistTimeout(blacklistTimeout);
+    i->second.SetRreqCnt(0);
+    NS_LOG_LOGIC("Set link to " << neighbor << " to unidirectional");
+    return true;
+}
+
+void
+RoutingTable::Print(Ptr<OutputStreamWrapper> stream, Time::Unit unit /* = Time::S */) const
+{
+    std::map<Ipv4Address, RoutingTableEntry> table = m_ipv4AddressEntry;
+    Purge(table);
+    std::ostream* os = stream->GetStream();
+    // Copy the current ostream state
+    std::ios oldState(nullptr);
+    oldState.copyfmt(*os);
+
+    *os << std::resetiosflags(std::ios::adjustfield) << std::setiosflags(std::ios::left);
+    *os << "\nRAODV Routing table\n";
+    *os << std::setw(16) << "Destination";
+    *os << std::setw(16) << "Gateway";
+    *os << std::setw(16) << "Interface";
+    *os << std::setw(16) << "Flag";
+    *os << std::setw(16) << "Expire";
+    *os << "Hops" << std::endl;
+    for (auto i = table.begin(); i != table.end(); ++i)
+    {
+        i->second.Print(stream, unit);
+    }
+    *stream->GetStream() << "\n";
+}
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/model/raodv-rtable.h b/src/raodv/model/raodv-rtable.h
new file mode 100644
index 000000000..21b4ecc9b
--- /dev/null
+++ b/src/raodv/model/raodv-rtable.h
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#ifndef RAODV_RTABLE_H
+#define RAODV_RTABLE_H
+
+#include "ns3/ipv4-route.h"
+#include "ns3/ipv4.h"
+#include "ns3/net-device.h"
+#include "ns3/output-stream-wrapper.h"
+#include "ns3/timer.h"
+
+#include <cassert>
+#include <map>
+#include <stdint.h>
+#include <sys/types.h>
+
+namespace ns3
+{
+namespace raodv
+{
+
+/**
+ * \ingroup raodv
+ * \brief Route record states
+ */
+enum RouteFlags
+{
+    VALID = 0,     //!< VALID
+    INVALID = 1,   //!< INVALID
+    IN_SEARCH = 2, //!< IN_SEARCH
+};
+
+/**
+ * \ingroup raodv
+ * \brief Routing table entry
+ */
+class RoutingTableEntry
+{
+  public:
+    /**
+     * constructor
+     *
+     * \param dev the device
+     * \param dst the destination IP address
+     * \param vSeqNo verify sequence number flag
+     * \param seqNo the sequence number
+     * \param iface the interface
+     * \param hops the number of hops
+     * \param nextHop the IP address of the next hop
+     * \param lifetime the lifetime of the entry
+     */
+    RoutingTableEntry(Ptr<NetDevice> dev = nullptr,
+                      Ipv4Address dst = Ipv4Address(),
+                      bool vSeqNo = false,
+                      uint32_t seqNo = 0,
+                      Ipv4InterfaceAddress iface = Ipv4InterfaceAddress(),
+                      uint16_t hops = 0,
+                      Ipv4Address nextHop = Ipv4Address(),
+                      Time lifetime = Simulator::Now());
+
+    ~RoutingTableEntry();
+
+    /// \name Precursors management
+    //\{
+    /**
+     * Insert precursor in precursor list if it doesn't yet exist in the list
+     * \param id precursor address
+     * \return true on success
+     */
+    bool InsertPrecursor(Ipv4Address id);
+    /**
+     * Lookup precursor by address
+     * \param id precursor address
+     * \return true on success
+     */
+    bool LookupPrecursor(Ipv4Address id);
+    /**
+     * \brief Delete precursor
+     * \param id precursor address
+     * \return true on success
+     */
+    bool DeletePrecursor(Ipv4Address id);
+    /// Delete all precursors
+    void DeleteAllPrecursors();
+    /**
+     * Check that precursor list is empty
+     * \return true if precursor list is empty
+     */
+    bool IsPrecursorListEmpty() const;
+    /**
+     * Inserts precursors in output parameter prec if they do not yet exist in vector
+     * \param prec vector of precursor addresses
+     */
+    void GetPrecursors(std::vector<Ipv4Address>& prec) const;
+    //\}
+
+    /**
+     * Mark entry as "down" (i.e. disable it)
+     * \param badLinkLifetime duration to keep entry marked as invalid
+     */
+    void Invalidate(Time badLinkLifetime);
+
+    // Fields
+    /**
+     * Get destination address function
+     * \returns the IPv4 destination address
+     */
+    Ipv4Address GetDestination() const
+    {
+        return m_ipv4Route->GetDestination();
+    }
+
+    /**
+     * Get route function
+     * \returns The IPv4 route
+     */
+    Ptr<Ipv4Route> GetRoute() const
+    {
+        return m_ipv4Route;
+    }
+
+    /**
+     * Set route function
+     * \param r the IPv4 route
+     */
+    void SetRoute(Ptr<Ipv4Route> r)
+    {
+        m_ipv4Route = r;
+    }
+
+    /**
+     * Set next hop address
+     * \param nextHop the next hop IPv4 address
+     */
+    void SetNextHop(Ipv4Address nextHop)
+    {
+        m_ipv4Route->SetGateway(nextHop);
+    }
+
+    /**
+     * Get next hop address
+     * \returns the next hop address
+     */
+    Ipv4Address GetNextHop() const
+    {
+        return m_ipv4Route->GetGateway();
+    }
+
+    /**
+     * Set output device
+     * \param dev The output device
+     */
+    void SetOutputDevice(Ptr<NetDevice> dev)
+    {
+        m_ipv4Route->SetOutputDevice(dev);
+    }
+
+    /**
+     * Get output device
+     * \returns the output device
+     */
+    Ptr<NetDevice> GetOutputDevice() const
+    {
+        return m_ipv4Route->GetOutputDevice();
+    }
+
+    /**
+     * Get the Ipv4InterfaceAddress
+     * \returns the Ipv4InterfaceAddress
+     */
+    Ipv4InterfaceAddress GetInterface() const
+    {
+        return m_iface;
+    }
+
+    /**
+     * Set the Ipv4InterfaceAddress
+     * \param iface The Ipv4InterfaceAddress
+     */
+    void SetInterface(Ipv4InterfaceAddress iface)
+    {
+        m_iface = iface;
+    }
+
+    /**
+     * Set the valid sequence number
+     * \param s the sequence number
+     */
+    void SetValidSeqNo(bool s)
+    {
+        m_validSeqNo = s;
+    }
+
+    /**
+     * Get the valid sequence number
+     * \returns the valid sequence number
+     */
+    bool GetValidSeqNo() const
+    {
+        return m_validSeqNo;
+    }
+
+    /**
+     * Set the sequence number
+     * \param sn the sequence number
+     */
+    void SetSeqNo(uint32_t sn)
+    {
+        m_seqNo = sn;
+    }
+
+    /**
+     * Get the sequence number
+     * \returns the sequence number
+     */
+    uint32_t GetSeqNo() const
+    {
+        return m_seqNo;
+    }
+
+    /**
+     * Set the number of hops
+     * \param hop the number of hops
+     */
+    void SetHop(uint16_t hop)
+    {
+        m_hops = hop;
+    }
+
+    /**
+     * Get the number of hops
+     * \returns the number of hops
+     */
+    uint16_t GetHop() const
+    {
+        return m_hops;
+    }
+
+    /**
+     * Set the lifetime
+     * \param lt The lifetime
+     */
+    void SetLifeTime(Time lt)
+    {
+        m_lifeTime = lt + Simulator::Now();
+    }
+
+    /**
+     * Get the lifetime
+     * \returns the lifetime
+     */
+    Time GetLifeTime() const
+    {
+        return m_lifeTime - Simulator::Now();
+    }
+
+    /**
+     * Set the route flags
+     * \param flag the route flags
+     */
+    void SetFlag(RouteFlags flag)
+    {
+        m_flag = flag;
+    }
+
+    /**
+     * Get the route flags
+     * \returns the route flags
+     */
+    RouteFlags GetFlag() const
+    {
+        return m_flag;
+    }
+
+    /**
+     * Set the RREQ count
+     * \param n the RREQ count
+     */
+    void SetRreqCnt(uint8_t n)
+    {
+        m_reqCount = n;
+    }
+
+    /**
+     * Get the RREQ count
+     * \returns the RREQ count
+     */
+    uint8_t GetRreqCnt() const
+    {
+        return m_reqCount;
+    }
+
+    /**
+     * Increment the RREQ count
+     */
+    void IncrementRreqCnt()
+    {
+        m_reqCount++;
+    }
+
+    /**
+     * Set the unidirectional flag
+     * \param u the uni directional flag
+     */
+    void SetUnidirectional(bool u)
+    {
+        m_blackListState = u;
+    }
+
+    /**
+     * Get the unidirectional flag
+     * \returns the unidirectional flag
+     */
+    bool IsUnidirectional() const
+    {
+        return m_blackListState;
+    }
+
+    /**
+     * Set the blacklist timeout
+     * \param t the blacklist timeout value
+     */
+    void SetBlacklistTimeout(Time t)
+    {
+        m_blackListTimeout = t;
+    }
+
+    /**
+     * Get the blacklist timeout value
+     * \returns the blacklist timeout value
+     */
+    Time GetBlacklistTimeout() const
+    {
+        return m_blackListTimeout;
+    }
+
+    /// RREP_ACK timer
+    Timer m_ackTimer;
+
+    /**
+     * \brief Compare destination address
+     * \param dst IP address to compare
+     * \return true if equal
+     */
+    bool operator==(const Ipv4Address dst) const
+    {
+        return (m_ipv4Route->GetDestination() == dst);
+    }
+
+    /**
+     * Print packet to trace file
+     * \param stream The output stream
+     * \param unit The time unit to use (default Time::S)
+     */
+    void Print(Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
+
+  private:
+    /// Valid Destination Sequence Number flag
+    bool m_validSeqNo;
+    /// Destination Sequence Number, if m_validSeqNo = true
+    uint32_t m_seqNo;
+    /// Hop Count (number of hops needed to reach destination)
+    uint16_t m_hops;
+    /**
+     * \brief Expiration or deletion time of the route
+     * Lifetime field in the routing table plays dual role:
+     * for an active route it is the expiration time, and for an invalid route
+     * it is the deletion time.
+     */
+    Time m_lifeTime;
+    /** Ip route, include
+     *   - destination address
+     *   - source address
+     *   - next hop address (gateway)
+     *   - output device
+     */
+    Ptr<Ipv4Route> m_ipv4Route;
+    /// Output interface address
+    Ipv4InterfaceAddress m_iface;
+    /// Routing flags: valid, invalid or in search
+    RouteFlags m_flag;
+
+    /// List of precursors
+    std::vector<Ipv4Address> m_precursorList;
+    /// When I can send another request
+    Time m_routeRequestTimeout;
+    /// Number of route requests
+    uint8_t m_reqCount;
+    /// Indicate if this entry is in "blacklist"
+    bool m_blackListState;
+    /// Time for which the node is put into the blacklist
+    Time m_blackListTimeout;
+};
+
+/**
+ * \ingroup raodv
+ * \brief The Routing table used by RAODV protocol
+ */
+class RoutingTable
+{
+  public:
+    /**
+     * constructor
+     * \param t the routing table entry lifetime
+     */
+    RoutingTable(Time t);
+
+    /// \name Handle lifetime of invalid route
+    //\{
+    /**
+     * Get the lifetime of a bad link
+     *
+     * \return the lifetime of a bad link
+     */
+    Time GetBadLinkLifetime() const
+    {
+        return m_badLinkLifetime;
+    }
+
+    /**
+     * Set the lifetime of a bad link
+     *
+     * \param t the lifetime of a bad link
+     */
+    void SetBadLinkLifetime(Time t)
+    {
+        m_badLinkLifetime = t;
+    }
+
+    //\}
+    /**
+     * Add routing table entry if it doesn't yet exist in routing table
+     * \param r routing table entry
+     * \return true in success
+     */
+    bool AddRoute(RoutingTableEntry& r);
+    /**
+     * Delete routing table entry with destination address dst, if it exists.
+     * \param dst destination address
+     * \return true on success
+     */
+    bool DeleteRoute(Ipv4Address dst);
+    /**
+     * Lookup routing table entry with destination address dst
+     * \param dst destination address
+     * \param rt entry with destination address dst, if exists
+     * \return true on success
+     */
+    bool LookupRoute(Ipv4Address dst, RoutingTableEntry& rt);
+    /**
+     * Lookup route in VALID state
+     * \param dst destination address
+     * \param rt entry with destination address dst, if exists
+     * \return true on success
+     */
+    bool LookupValidRoute(Ipv4Address dst, RoutingTableEntry& rt);
+    /**
+     * Update routing table
+     * \param rt entry with destination address dst, if exists
+     * \return true on success
+     */
+    bool Update(RoutingTableEntry& rt);
+    /**
+     * Set routing table entry flags
+     * \param dst destination address
+     * \param state the routing flags
+     * \return true on success
+     */
+    bool SetEntryState(Ipv4Address dst, RouteFlags state);
+    /**
+     * Lookup routing entries with next hop Address dst and not empty list of precursors.
+     *
+     * \param nextHop the next hop IP address
+     * \param unreachable
+     */
+    void GetListOfDestinationWithNextHop(Ipv4Address nextHop,
+                                         std::map<Ipv4Address, uint32_t>& unreachable);
+    /**
+     * Update routing entries with this destination as follows:
+     * 1. The destination sequence number of this routing entry, if it
+     *    exists and is valid, is incremented.
+     * 2. The entry is invalidated by marking the route entry as invalid
+     * 3. The Lifetime field is updated to current time plus DELETE_PERIOD.
+     * \param unreachable routes to invalidate
+     */
+    void InvalidateRoutesWithDst(const std::map<Ipv4Address, uint32_t>& unreachable);
+    /**
+     * Delete all route from interface with address iface
+     * \param iface the interface IP address
+     */
+    void DeleteAllRoutesFromInterface(Ipv4InterfaceAddress iface);
+
+    /// Delete all entries from routing table
+    void Clear()
+    {
+        m_ipv4AddressEntry.clear();
+    }
+
+    /// Delete all outdated entries and invalidate valid entry if Lifetime is expired
+    void Purge();
+    /** Mark entry as unidirectional (e.g. add this neighbor to "blacklist" for blacklistTimeout
+     * period)
+     * \param neighbor neighbor address link to which assumed to be unidirectional
+     * \param blacklistTimeout time for which the neighboring node is put into the blacklist
+     * \return true on success
+     */
+    bool MarkLinkAsUnidirectional(Ipv4Address neighbor, Time blacklistTimeout);
+    /**
+     * Print routing table
+     * \param stream the output stream
+     * \param unit The time unit to use (default Time::S)
+     */
+    void Print(Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
+
+  private:
+    /// The routing table
+    std::map<Ipv4Address, RoutingTableEntry> m_ipv4AddressEntry;
+    /// Deletion time for invalid routes
+    Time m_badLinkLifetime;
+    /**
+     * const version of Purge, for use by Print() method
+     * \param table the routing table entry to purge
+     */
+    void Purge(std::map<Ipv4Address, RoutingTableEntry>& table) const;
+};
+
+} // namespace raodv
+} // namespace ns3
+
+#endif /* RAODV_RTABLE_H */
diff --git a/src/raodv/test/bug-772.cc b/src/raodv/test/bug-772.cc
new file mode 100644
index 000000000..928b119b3
--- /dev/null
+++ b/src/raodv/test/bug-772.cc
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "bug-772.h"
+
+#include "ns3/abort.h"
+#include "ns3/raodv-helper.h"
+#include "ns3/boolean.h"
+#include "ns3/config.h"
+#include "ns3/data-rate.h"
+#include "ns3/double.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/internet-stack-helper.h"
+#include "ns3/ipv4-address-helper.h"
+#include "ns3/mobility-helper.h"
+#include "ns3/mobility-model.h"
+#include "ns3/pcap-file.h"
+#include "ns3/pcap-test.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/rng-seed-manager.h"
+#include "ns3/simulator.h"
+#include "ns3/string.h"
+#include "ns3/uinteger.h"
+#include "ns3/yans-wifi-helper.h"
+
+#include <sstream>
+
+using namespace ns3;
+
+//-----------------------------------------------------------------------------
+// UdpChainTest
+//-----------------------------------------------------------------------------
+Bug772ChainTest::Bug772ChainTest(const char* const prefix,
+                                 const char* const proto,
+                                 Time t,
+                                 uint32_t size)
+    : TestCase("Bug 772 UDP and TCP chain regression test"),
+      m_nodes(nullptr),
+      m_prefix(prefix),
+      m_proto(proto),
+      m_time(t),
+      m_size(size),
+      m_step(120),
+      m_port(9),
+      m_receivedPackets(0)
+{
+}
+
+Bug772ChainTest::~Bug772ChainTest()
+{
+    delete m_nodes;
+}
+
+void
+Bug772ChainTest::SendData(Ptr<Socket> socket)
+{
+    if (Simulator::Now() < m_time)
+    {
+        socket->Send(Create<Packet>(1000));
+        Simulator::ScheduleWithContext(socket->GetNode()->GetId(),
+                                       Seconds(0.25),
+                                       &Bug772ChainTest::SendData,
+                                       this,
+                                       socket);
+    }
+}
+
+void
+Bug772ChainTest::HandleRead(Ptr<Socket> socket)
+{
+    m_receivedPackets++;
+}
+
+void
+Bug772ChainTest::DoRun()
+{
+    RngSeedManager::SetSeed(1);
+    RngSeedManager::SetRun(2);
+
+    // Default of 3 will cause packet loss
+    Config::SetDefault("ns3::ArpCache::PendingQueueSize", UintegerValue(10));
+
+    CreateNodes();
+    CreateDevices();
+
+    Simulator::Stop(m_time + Seconds(1)); // Allow buffered packets to clear
+    Simulator::Run();
+    Simulator::Destroy();
+
+    CheckResults();
+
+    delete m_nodes, m_nodes = nullptr;
+}
+
+void
+Bug772ChainTest::CreateNodes()
+{
+    m_nodes = new NodeContainer;
+    m_nodes->Create(m_size);
+    MobilityHelper mobility;
+    mobility.SetPositionAllocator("ns3::GridPositionAllocator",
+                                  "MinX",
+                                  DoubleValue(0.0),
+                                  "MinY",
+                                  DoubleValue(0.0),
+                                  "DeltaX",
+                                  DoubleValue(m_step),
+                                  "DeltaY",
+                                  DoubleValue(0),
+                                  "GridWidth",
+                                  UintegerValue(m_size),
+                                  "LayoutType",
+                                  StringValue("RowFirst"));
+    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    mobility.Install(*m_nodes);
+}
+
+void
+Bug772ChainTest::CreateDevices()
+{
+    int64_t streamsUsed = 0;
+    // 1. Setup WiFi
+    WifiMacHelper wifiMac;
+    wifiMac.SetType("ns3::AdhocWifiMac");
+    YansWifiPhyHelper wifiPhy;
+    wifiPhy.DisablePreambleDetectionModel();
+    // This test suite output was originally based on YansErrorRateModel
+    wifiPhy.SetErrorRateModel("ns3::YansErrorRateModel");
+    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();
+    Ptr<YansWifiChannel> chan = wifiChannel.Create();
+    wifiPhy.SetChannel(chan);
+    wifiPhy.Set(
+        "TxGain",
+        DoubleValue(1.0)); // this configuration should go away in future revision to the test
+    wifiPhy.Set(
+        "RxGain",
+        DoubleValue(1.0)); // this configuration should go away in future revision to the test
+    WifiHelper wifi;
+    wifi.SetStandard(WIFI_STANDARD_80211a);
+    wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
+                                 "DataMode",
+                                 StringValue("OfdmRate6Mbps"),
+                                 "RtsCtsThreshold",
+                                 StringValue("2200"),
+                                 "MaxSlrc",
+                                 UintegerValue(7));
+    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, *m_nodes);
+
+    // Assign fixed stream numbers to wifi and channel random variables
+    streamsUsed += WifiHelper::AssignStreams(devices, streamsUsed);
+    // Assign 6 streams per device
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed, (devices.GetN() * 2), "Stream assignment mismatch");
+    streamsUsed += wifiChannel.AssignStreams(chan, streamsUsed);
+    // Assign 0 streams per channel for this configuration
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed, (devices.GetN() * 2), "Stream assignment mismatch");
+
+    // 2. Setup TCP/IP & RAODV
+    RAodvHelper raodv; // Use default parameters here
+    InternetStackHelper internetStack;
+    internetStack.SetRoutingHelper(raodv);
+    internetStack.Install(*m_nodes);
+    streamsUsed += internetStack.AssignStreams(*m_nodes, streamsUsed);
+    // Expect to use (3*m_size) more streams for internet stack random variables
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed,
+                          ((devices.GetN() * 3) + (3 * m_size)),
+                          "Stream assignment mismatch");
+    streamsUsed += raodv.AssignStreams(*m_nodes, streamsUsed);
+    // Expect to use m_size more streams for RAODV
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed,
+                          ((devices.GetN() * 3) + (3 * m_size) + m_size),
+                          "Stream assignment mismatch");
+    Ipv4AddressHelper address;
+    address.SetBase("10.1.1.0", "255.255.255.0");
+    Ipv4InterfaceContainer interfaces = address.Assign(devices);
+
+    // 3. Setup UDP source and sink
+    m_sendSocket = Socket::CreateSocket(m_nodes->Get(0), TypeId::LookupByName(m_proto));
+    m_sendSocket->Bind();
+    m_sendSocket->Connect(InetSocketAddress(interfaces.GetAddress(m_size - 1), m_port));
+    m_sendSocket->SetAllowBroadcast(true);
+    Simulator::ScheduleWithContext(m_sendSocket->GetNode()->GetId(),
+                                   Seconds(1.0),
+                                   &Bug772ChainTest::SendData,
+                                   this,
+                                   m_sendSocket);
+
+    m_recvSocket = Socket::CreateSocket(m_nodes->Get(m_size - 1), TypeId::LookupByName(m_proto));
+    m_recvSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), m_port));
+    m_recvSocket->Listen();
+    m_recvSocket->ShutdownSend();
+    m_recvSocket->SetRecvCallback(MakeCallback(&Bug772ChainTest::HandleRead, this));
+}
+
+void
+Bug772ChainTest::CheckResults()
+{
+    // We should have sent 8 packets (every 0.25 seconds from time 1 to time 3)
+    // Check that the received packet count is 8
+    NS_TEST_EXPECT_MSG_EQ(m_receivedPackets, 8, "Did not receive expected 8 packets");
+}
diff --git a/src/raodv/test/bug-772.h b/src/raodv/test/bug-772.h
new file mode 100644
index 000000000..c44f4ebf6
--- /dev/null
+++ b/src/raodv/test/bug-772.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef BUG_772_H
+#define BUG_772_H
+
+#include "ns3/node-container.h"
+#include "ns3/nstime.h"
+#include "ns3/socket.h"
+#include "ns3/test.h"
+
+using namespace ns3;
+
+/**
+ * \ingroup raodv
+ *
+ * \brief RAODV deferred route lookup test case (see \bugid{772})
+ *
+ * UDP packet transfers are delayed while a route is found and then while
+ * ARP completes.  Eight packets should be sent, queued until the path
+ * becomes functional, and then delivered.
+ */
+class Bug772ChainTest : public TestCase
+{
+  public:
+    /**
+     * Create test case
+     *
+     * \param prefix              Unique file names prefix
+     * \param proto               ns3::UdpSocketFactory or ns3::TcpSocketFactory
+     * \param size                Number of nodes in the chain
+     * \param time                Simulation time
+     */
+    Bug772ChainTest(const char* const prefix, const char* const proto, Time time, uint32_t size);
+    ~Bug772ChainTest() override;
+
+  private:
+    /// \internal It is important to have pointers here
+    NodeContainer* m_nodes;
+
+    /// PCAP file names prefix
+    const std::string m_prefix;
+    /// Socket factory TID
+    const std::string m_proto;
+    /// Total simulation time
+    const Time m_time;
+    /// Chain size
+    const uint32_t m_size;
+    /// Chain step, meters
+    const double m_step;
+    /// port number
+    const uint16_t m_port;
+
+    /// Create test topology
+    void CreateNodes();
+    /// Create devices, install TCP/IP stack and applications
+    void CreateDevices();
+    /// Compare traces with reference ones
+    void CheckResults();
+    /// Go
+    void DoRun() override;
+    /**
+     * Receive data function
+     * \param socket the socket to receive from
+     */
+    void HandleRead(Ptr<Socket> socket);
+
+    /// Receiving socket
+    Ptr<Socket> m_recvSocket;
+    /// Transmitting socket
+    Ptr<Socket> m_sendSocket;
+
+    /// Received packet count
+    uint32_t m_receivedPackets;
+
+    /**
+     * Send data
+     * \param socket the sending socket
+     */
+    void SendData(Ptr<Socket> socket);
+};
+
+#endif /* BUG_772_H */
diff --git a/src/raodv/test/examples-to-run.py b/src/raodv/test/examples-to-run.py
new file mode 100644
index 000000000..452a040eb
--- /dev/null
+++ b/src/raodv/test/examples-to-run.py
@@ -0,0 +1,19 @@
+#! /usr/bin/env python3
+
+# A list of C++ examples to run in order to ensure that they remain
+# buildable and runnable over time.  Each tuple in the list contains
+#
+#     (example_name, do_run, do_valgrind_run).
+#
+# See test.py for more information.
+cpp_examples = [
+    ("raodv", "True", "True"),
+]
+
+# A list of Python examples to run in order to ensure that they remain
+# runnable over time.  Each tuple in the list contains
+#
+#     (example_name, do_run).
+#
+# See test.py for more information.
+python_examples = []
diff --git a/src/raodv/test/loopback.cc b/src/raodv/test/loopback.cc
new file mode 100644
index 000000000..5fa87c55b
--- /dev/null
+++ b/src/raodv/test/loopback.cc
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2010 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "ns3/abort.h"
+#include "ns3/raodv-helper.h"
+#include "ns3/boolean.h"
+#include "ns3/config.h"
+#include "ns3/constant-position-mobility-model.h"
+#include "ns3/double.h"
+#include "ns3/internet-stack-helper.h"
+#include "ns3/ipv4-address-helper.h"
+#include "ns3/mobility-helper.h"
+#include "ns3/mobility-model.h"
+#include "ns3/names.h"
+#include "ns3/pcap-file.h"
+#include "ns3/simulator.h"
+#include "ns3/socket-factory.h"
+#include "ns3/string.h"
+#include "ns3/test.h"
+#include "ns3/udp-echo-helper.h"
+#include "ns3/udp-socket-factory.h"
+#include "ns3/uinteger.h"
+#include "ns3/yans-wifi-helper.h"
+
+#include <sstream>
+
+namespace ns3
+{
+namespace raodv
+{
+
+/**
+ * \ingroup raodv
+ *
+ * \brief RAODV loopback UDP echo test case
+ */
+class LoopbackTestCase : public TestCase
+{
+    uint32_t m_count;         //!< number of packet received;
+    Ptr<Socket> m_txSocket;   //!< transmit socket;
+    Ptr<Socket> m_echoSocket; //!< echo socket;
+    Ptr<Socket> m_rxSocket;   //!< receive socket;
+    uint16_t m_echoSendPort;  //!< echo send port;
+    uint16_t m_echoReplyPort; //!< echo reply port;
+
+    /**
+     * Send data function
+     * \param socket The socket to send data
+     */
+    void SendData(Ptr<Socket> socket);
+    /**
+     * Receive packet function
+     * \param socket The socket to receive data
+     */
+    void ReceivePkt(Ptr<Socket> socket);
+    /**
+     * Echo data function
+     * \param socket The socket to echo data
+     */
+    void EchoData(Ptr<Socket> socket) const;
+
+  public:
+    LoopbackTestCase();
+    void DoRun() override;
+};
+
+LoopbackTestCase::LoopbackTestCase()
+    : TestCase("UDP Echo 127.0.0.1 test"),
+      m_count(0)
+{
+    m_echoSendPort = 1233;
+    m_echoReplyPort = 1234;
+}
+
+void
+LoopbackTestCase::ReceivePkt(Ptr<Socket> socket)
+{
+    Ptr<Packet> receivedPacket = socket->Recv(std::numeric_limits<uint32_t>::max(), 0);
+
+    m_count++;
+}
+
+void
+LoopbackTestCase::EchoData(Ptr<Socket> socket) const
+{
+    Address from;
+    Ptr<Packet> receivedPacket = socket->RecvFrom(std::numeric_limits<uint32_t>::max(), 0, from);
+
+    Ipv4Address src = InetSocketAddress::ConvertFrom(from).GetIpv4();
+    Address to = InetSocketAddress(src, m_echoReplyPort);
+
+    receivedPacket->RemoveAllPacketTags();
+    receivedPacket->RemoveAllByteTags();
+
+    socket->SendTo(receivedPacket, 0, to);
+}
+
+void
+LoopbackTestCase::SendData(Ptr<Socket> socket)
+{
+    Address realTo = InetSocketAddress(Ipv4Address::GetLoopback(), m_echoSendPort);
+    socket->SendTo(Create<Packet>(123), 0, realTo);
+
+    Simulator::ScheduleWithContext(socket->GetNode()->GetId(),
+                                   Seconds(1.0),
+                                   &LoopbackTestCase::SendData,
+                                   this,
+                                   socket);
+}
+
+void
+LoopbackTestCase::DoRun()
+{
+    NodeContainer nodes;
+    nodes.Create(1);
+    Ptr<MobilityModel> m = CreateObject<ConstantPositionMobilityModel>();
+    m->SetPosition(Vector(0, 0, 0));
+    nodes.Get(0)->AggregateObject(m);
+    // Setup WiFi
+    WifiMacHelper wifiMac;
+    wifiMac.SetType("ns3::AdhocWifiMac");
+    YansWifiPhyHelper wifiPhy;
+    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();
+    wifiPhy.SetChannel(wifiChannel.Create());
+    WifiHelper wifi;
+    wifi.SetStandard(WIFI_STANDARD_80211a);
+    wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
+                                 "DataMode",
+                                 StringValue("OfdmRate6Mbps"),
+                                 "RtsCtsThreshold",
+                                 StringValue("2200"));
+    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);
+
+    // Setup TCP/IP & RAODV
+    RAodvHelper raodv; // Use default parameters here
+    InternetStackHelper internetStack;
+    internetStack.SetRoutingHelper(raodv);
+    internetStack.Install(nodes);
+    Ipv4AddressHelper address;
+    address.SetBase("10.1.1.0", "255.255.255.0");
+    Ipv4InterfaceContainer interfaces = address.Assign(devices);
+
+    // Setup echos
+    Ptr<SocketFactory> socketFactory = nodes.Get(0)->GetObject<UdpSocketFactory>();
+    m_rxSocket = socketFactory->CreateSocket();
+    m_rxSocket->Bind(InetSocketAddress(Ipv4Address::GetLoopback(), m_echoReplyPort));
+    m_rxSocket->SetRecvCallback(MakeCallback(&LoopbackTestCase::ReceivePkt, this));
+
+    m_echoSocket = socketFactory->CreateSocket();
+    m_echoSocket->Bind(InetSocketAddress(Ipv4Address::GetLoopback(), m_echoSendPort));
+    m_echoSocket->SetRecvCallback(MakeCallback(&LoopbackTestCase::EchoData, this));
+
+    m_txSocket = socketFactory->CreateSocket();
+
+    Simulator::ScheduleWithContext(m_txSocket->GetNode()->GetId(),
+                                   Seconds(1.0),
+                                   &LoopbackTestCase::SendData,
+                                   this,
+                                   m_txSocket);
+
+    // Run
+    Simulator::Stop(Seconds(5));
+    Simulator::Run();
+
+    m_txSocket->Close();
+    m_echoSocket->Close();
+    m_rxSocket->Close();
+
+    Simulator::Destroy();
+
+    // Check that 4 packets delivered
+    NS_TEST_ASSERT_MSG_EQ(m_count, 4, "Exactly 4 echo replies must be delivered.");
+}
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief RAODV Loopback test suite
+ */
+class RAodvLoopbackTestSuite : public TestSuite
+{
+  public:
+    RAodvLoopbackTestSuite()
+        : TestSuite("routing-raodv-loopback", Type::SYSTEM)
+    {
+        SetDataDir(NS_TEST_SOURCEDIR);
+        // UDP Echo loopback test case
+        AddTestCase(new LoopbackTestCase(), TestCase::Duration::QUICK);
+    }
+} g_raodvLoopbackTestSuite; ///< the test suite
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/test/raodv-id-cache-test-suite.cc b/src/raodv/test/raodv-id-cache-test-suite.cc
new file mode 100644
index 000000000..939972139
--- /dev/null
+++ b/src/raodv/test/raodv-id-cache-test-suite.cc
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Based on
+ *      NS-2 RAODV model developed by the CMU/MONARCH group and optimized and
+ *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;
+ *
+ *      RAODV-UU implementation by Erik Nordström of Uppsala University
+ *      https://web.archive.org/web/20100527072022/http://core.it.uu.se/core/index.php/RAODV-UU
+ *
+ * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>
+ *          Pavel Boyko <boyko@iitp.ru>
+ */
+#include "ns3/raodv-id-cache.h"
+#include "ns3/test.h"
+
+namespace ns3
+{
+namespace raodv
+{
+
+/**
+ * \defgroup raodv-test RAODV module tests
+ * \ingroup raodv
+ * \ingroup tests
+ */
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for id cache
+ */
+class IdCacheTest : public TestCase
+{
+  public:
+    IdCacheTest()
+        : TestCase("Id Cache"),
+          cache(Seconds(10))
+    {
+    }
+
+    void DoRun() override;
+
+  private:
+    /// Timeout test function #1
+    void CheckTimeout1();
+    /// Timeout test function #2
+    void CheckTimeout2();
+    /// Timeout test function #3
+    void CheckTimeout3();
+
+    /// ID cache
+    IdCache cache;
+};
+
+void
+IdCacheTest::DoRun()
+{
+    NS_TEST_EXPECT_MSG_EQ(cache.GetLifeTime(), Seconds(10), "Lifetime");
+    NS_TEST_EXPECT_MSG_EQ(cache.IsDuplicate(Ipv4Address("1.2.3.4"), 3),
+                          false,
+                          "Unknown ID & address");
+    NS_TEST_EXPECT_MSG_EQ(cache.IsDuplicate(Ipv4Address("1.2.3.4"), 4), false, "Unknown ID");
+    NS_TEST_EXPECT_MSG_EQ(cache.IsDuplicate(Ipv4Address("4.3.2.1"), 3), false, "Unknown address");
+    NS_TEST_EXPECT_MSG_EQ(cache.IsDuplicate(Ipv4Address("1.2.3.4"), 3), true, "Known address & ID");
+    cache.SetLifetime(Seconds(15));
+    NS_TEST_EXPECT_MSG_EQ(cache.GetLifeTime(), Seconds(15), "New lifetime");
+    cache.IsDuplicate(Ipv4Address("1.1.1.1"), 4);
+    cache.IsDuplicate(Ipv4Address("1.1.1.1"), 4);
+    cache.IsDuplicate(Ipv4Address("2.2.2.2"), 5);
+    cache.IsDuplicate(Ipv4Address("3.3.3.3"), 6);
+    NS_TEST_EXPECT_MSG_EQ(cache.GetSize(), 6, "trivial");
+
+    Simulator::Schedule(Seconds(5), &IdCacheTest::CheckTimeout1, this);
+    Simulator::Schedule(Seconds(11), &IdCacheTest::CheckTimeout2, this);
+    Simulator::Schedule(Seconds(30), &IdCacheTest::CheckTimeout3, this);
+    Simulator::Run();
+    Simulator::Destroy();
+}
+
+void
+IdCacheTest::CheckTimeout1()
+{
+    NS_TEST_EXPECT_MSG_EQ(cache.GetSize(), 6, "Nothing expire");
+}
+
+void
+IdCacheTest::CheckTimeout2()
+{
+    NS_TEST_EXPECT_MSG_EQ(cache.GetSize(), 3, "3 records left");
+}
+
+void
+IdCacheTest::CheckTimeout3()
+{
+    NS_TEST_EXPECT_MSG_EQ(cache.GetSize(), 0, "All records expire");
+}
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Id Cache Test Suite
+ */
+class IdCacheTestSuite : public TestSuite
+{
+  public:
+    IdCacheTestSuite()
+        : TestSuite("raodv-routing-id-cache", Type::UNIT)
+    {
+        AddTestCase(new IdCacheTest, TestCase::Duration::QUICK);
+    }
+} g_idCacheTestSuite; ///< the test suite
+
+} // namespace raodv
+} // namespace ns3
diff --git a/src/raodv/test/raodv-regression.cc b/src/raodv/test/raodv-regression.cc
new file mode 100644
index 000000000..c44eb7a22
--- /dev/null
+++ b/src/raodv/test/raodv-regression.cc
@@ -0,0 +1,232 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#include "raodv-regression.h"
+
+#include "bug-772.h"
+
+#include "ns3/abort.h"
+#include "ns3/raodv-helper.h"
+#include "ns3/boolean.h"
+#include "ns3/config.h"
+#include "ns3/double.h"
+#include "ns3/icmpv4.h"
+#include "ns3/internet-stack-helper.h"
+#include "ns3/ipv4-address-helper.h"
+#include "ns3/mobility-helper.h"
+#include "ns3/mobility-model.h"
+#include "ns3/pcap-file.h"
+#include "ns3/pcap-test.h"
+#include "ns3/rng-seed-manager.h"
+#include "ns3/simulator.h"
+#include "ns3/string.h"
+#include "ns3/uinteger.h"
+#include "ns3/yans-wifi-helper.h"
+
+#include <sstream>
+
+using namespace ns3;
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief RAODV regression test suite
+ */
+class RAodvRegressionTestSuite : public TestSuite
+{
+  public:
+    RAodvRegressionTestSuite()
+        : TestSuite("routing-raodv-regression", Type::SYSTEM)
+    {
+        SetDataDir(NS_TEST_SOURCEDIR);
+        // General RREQ-RREP-RRER test case
+        AddTestCase(new ChainRegressionTest("raodv-chain-regression-test"),
+                    TestCase::Duration::QUICK);
+        // \bugid{606} test case, should crash if bug is not fixed
+        AddTestCase(new ChainRegressionTest("bug-606-test", Seconds(10), 3, Seconds(1)),
+                    TestCase::Duration::QUICK);
+        // \bugid{772} UDP test case
+        AddTestCase(new Bug772ChainTest("udp-chain-test", "ns3::UdpSocketFactory", Seconds(3), 10),
+                    TestCase::Duration::QUICK);
+    }
+} g_raodvRegressionTestSuite; ///< the test suite
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Chain Regression Test
+ */
+ChainRegressionTest::ChainRegressionTest(const char* const prefix,
+                                         Time t,
+                                         uint32_t size,
+                                         Time arpAliveTimeout)
+    : TestCase("RAODV chain regression test"),
+      m_nodes(nullptr),
+      m_prefix(prefix),
+      m_time(t),
+      m_size(size),
+      m_step(120),
+      m_arpAliveTimeout(arpAliveTimeout),
+      m_seq(0)
+{
+}
+
+ChainRegressionTest::~ChainRegressionTest()
+{
+    delete m_nodes;
+}
+
+void
+ChainRegressionTest::SendPing()
+{
+    if (Simulator::Now() >= m_time)
+    {
+        return;
+    }
+
+    Ptr<Packet> p = Create<Packet>();
+    Icmpv4Echo echo;
+    echo.SetSequenceNumber(m_seq);
+    m_seq++;
+    echo.SetIdentifier(0);
+
+    Ptr<Packet> dataPacket = Create<Packet>(56);
+    echo.SetData(dataPacket);
+    p->AddHeader(echo);
+    Icmpv4Header header;
+    header.SetType(Icmpv4Header::ICMPV4_ECHO);
+    header.SetCode(0);
+    if (Node::ChecksumEnabled())
+    {
+        header.EnableChecksum();
+    }
+    p->AddHeader(header);
+    m_socket->Send(p, 0);
+    Simulator::Schedule(Seconds(1), &ChainRegressionTest::SendPing, this);
+}
+
+void
+ChainRegressionTest::DoRun()
+{
+    RngSeedManager::SetSeed(12345);
+    RngSeedManager::SetRun(7);
+    Config::SetDefault("ns3::ArpCache::AliveTimeout", TimeValue(m_arpAliveTimeout));
+
+    CreateNodes();
+    CreateDevices();
+
+    // At m_time / 3 move central node away and see what will happen
+    Ptr<Node> node = m_nodes->Get(m_size / 2);
+    Ptr<MobilityModel> mob = node->GetObject<MobilityModel>();
+    Simulator::Schedule(Time(m_time / 3), &MobilityModel::SetPosition, mob, Vector(1e5, 1e5, 1e5));
+
+    Simulator::Stop(m_time);
+    Simulator::Run();
+    Simulator::Destroy();
+
+    CheckResults();
+
+    delete m_nodes, m_nodes = nullptr;
+}
+
+void
+ChainRegressionTest::CreateNodes()
+{
+    m_nodes = new NodeContainer;
+    m_nodes->Create(m_size);
+    MobilityHelper mobility;
+    mobility.SetPositionAllocator("ns3::GridPositionAllocator",
+                                  "MinX",
+                                  DoubleValue(0.0),
+                                  "MinY",
+                                  DoubleValue(0.0),
+                                  "DeltaX",
+                                  DoubleValue(m_step),
+                                  "DeltaY",
+                                  DoubleValue(0),
+                                  "GridWidth",
+                                  UintegerValue(m_size),
+                                  "LayoutType",
+                                  StringValue("RowFirst"));
+    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    mobility.Install(*m_nodes);
+}
+
+void
+ChainRegressionTest::CreateDevices()
+{
+    // 1. Setup WiFi
+    int64_t streamsUsed = 0;
+    WifiMacHelper wifiMac;
+    wifiMac.SetType("ns3::AdhocWifiMac");
+    YansWifiPhyHelper wifiPhy;
+    wifiPhy.DisablePreambleDetectionModel();
+    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();
+    Ptr<YansWifiChannel> chan = wifiChannel.Create();
+    wifiPhy.SetChannel(chan);
+
+    // This test suite output was originally based on YansErrorRateModel
+    wifiPhy.SetErrorRateModel("ns3::YansErrorRateModel");
+    WifiHelper wifi;
+    wifi.SetStandard(WIFI_STANDARD_80211a);
+    wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
+                                 "DataMode",
+                                 StringValue("OfdmRate6Mbps"),
+                                 "RtsCtsThreshold",
+                                 StringValue("2200"));
+    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, *m_nodes);
+
+    // Assign fixed stream numbers to wifi and channel random variables
+    streamsUsed += WifiHelper::AssignStreams(devices, streamsUsed);
+    // Assign 6 streams per device
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed, (devices.GetN() * 2), "Stream assignment mismatch");
+    streamsUsed += wifiChannel.AssignStreams(chan, streamsUsed);
+    // Assign 0 streams per channel for this configuration
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed, (devices.GetN() * 2), "Stream assignment mismatch");
+
+    // 2. Setup TCP/IP & RAODV
+    RAodvHelper raodv; // Use default parameters here
+    InternetStackHelper internetStack;
+    internetStack.SetRoutingHelper(raodv);
+    internetStack.Install(*m_nodes);
+    streamsUsed += internetStack.AssignStreams(*m_nodes, streamsUsed);
+    // InternetStack uses m_size more streams
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed, (devices.GetN() * 5) + m_size, "Stream assignment mismatch");
+    streamsUsed += raodv.AssignStreams(*m_nodes, streamsUsed);
+    // RAODV uses m_size more streams
+    NS_TEST_ASSERT_MSG_EQ(streamsUsed,
+                          ((devices.GetN() * 5) + (2 * m_size)),
+                          "Stream assignment mismatch");
+
+    Ipv4AddressHelper address;
+    address.SetBase("10.1.1.0", "255.255.255.0");
+    Ipv4InterfaceContainer interfaces = address.Assign(devices);
+
+    // 3. Setup ping
+    m_socket =
+        Socket::CreateSocket(m_nodes->Get(0), TypeId::LookupByName("ns3::Ipv4RawSocketFactory"));
+    m_socket->SetAttribute("Protocol", UintegerValue(1)); // icmp
+    InetSocketAddress src = InetSocketAddress(Ipv4Address::GetAny(), 0);
+    m_socket->Bind(src);
+    InetSocketAddress dst = InetSocketAddress(interfaces.GetAddress(m_size - 1), 0);
+    m_socket->Connect(dst);
+
+    SendPing();
+
+    // 4. write PCAP
+    wifiPhy.EnablePcapAll(CreateTempDirFilename(m_prefix));
+}
+
+void
+ChainRegressionTest::CheckResults()
+{
+    for (uint32_t i = 0; i < m_size; ++i)
+    {
+        NS_PCAP_TEST_EXPECT_EQ(m_prefix << "-" << i << "-0.pcap");
+    }
+}
diff --git a/src/raodv/test/raodv-regression.h b/src/raodv/test/raodv-regression.h
new file mode 100644
index 000000000..aee088776
--- /dev/null
+++ b/src/raodv/test/raodv-regression.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+
+#ifndef RAODV_REGRESSION_H
+#define RAODV_REGRESSION_H
+
+#include "ns3/node-container.h"
+#include "ns3/nstime.h"
+#include "ns3/socket.h"
+#include "ns3/test.h"
+
+using namespace ns3;
+
+/**
+ * \ingroup raodv
+ *
+ * \brief RAODV chain regression test
+ *
+ * This script creates 1-dimensional grid topology and then ping last node from the first one:
+ */
+// clang-format off
+/**
+ *     [10.1.1.1] <-- step --> [10.1.1.2] <-- step --> [10.1.1.3] <-- step --> [10.1.1.4] <-- step --> [10.1.1.5]
+ */
+// clang-format on
+/**
+ * Each node can hear only his right and his left neighbor, if they exist.
+ * When one third of total time expired, central node moves away.
+ * After this, node 3 doesn't hear any packets from other nodes and nobody hears his packets.
+ * We want to demonstrate in this script
+ * 1) route establishing
+ * 2) broken link detection both from layer 2 information and hello messages.
+ *
+ */
+// clang-format off
+/**
+ * \verbatim
+   Expected packets time diagram.
+
+           1       2       3       4       5
+   <-------|------>|       |       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, U=1, hop=0, ID=1, org_seqno=1) src = 10.1.1.1
+           |<------|------>|       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, U=1, hop=1, ID=1, org_seqno=1) src = 10.1.1.2
+           |       |<------|------>|       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, U=1, hop=2, ID=1, org_seqno=1) src = 10.1.1.3
+           |       |       |<------|------>|        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, U=1, hop=3, ID=1, org_seqno=1) src = 10.1.1.4
+           |       |       |       |<------|------> ARP request. Who has 10.1.1.4? Tell 10.1.1.5
+           |       |       |       |======>|        ARP reply
+           |       |       |       |<======|        RREP (orig 10.1.1.1, dst 10.1.1.5, hop=0, dst_seqno=0) src=10.1.1.5
+           |       |       |<------|------>|        ARP request. Who has 10.1.1.3? Tell 10.1.1.4
+           |       |       |======>|       |        ARP reply
+           |       |       |<======|       |        RREP (orig 10.1.1.1, dst 10.1.1.5, hop=1, dst_seqno=0) src=10.1.1.4
+           |       |<------|------>|       |        ARP request. Who has 10.1.1.2? Tell 10.1.1.3
+           |       |======>|       |       |        ARP reply
+           |       |<======|       |       |        RREP (orig 10.1.1.1, dst 10.1.1.5, hop=2, dst_seqno=0) src=10.1.1.3
+           |<------|------>|       |       |        ARP request. Who has 10.1.1.1? Tell 10.1.1.2
+           |======>|       |       |       |        ARP reply
+           |<======|       |       |       |        RREP (orig 10.1.1.1, dst 10.1.1.5, hop=3, dst_seqno=0) src=10.1.1.2
+   <-------|------>|       |       |       |        ARP request. Who has 10.1.1.2? Tell 10.1.1.1
+           |<======|       |       |       |
+           |======>|       |       |       |        ICMP (ping) request 0 from 10.1.1.1 to 10.1.1.5; src=10.1.1.1 next_hop=10.1.1.2
+           |<------|------>|       |       |        ARP request. Who has 10.1.1.3? Tell 10.1.1.2
+           |       |<======|       |       |        ARP reply
+           |       |======>|       |       |        ICMP (ping) request 0 from 10.1.1.1 to 10.1.1.5; src=10.1.1.2 next_hop=10.1.1.3
+           |       |<------|------>|       |        ARP request. Who has 10.1.1.4? Tell 10.1.1.3
+           |       |       |<======|       |        ARP reply
+           |       |       |======>|       |        ICMP (ping) request 0 from 10.1.1.1 to 10.1.1.5; src=10.1.1.3 next_hop=10.1.1.4
+           |       |       |<------|------>|        ARP request. Who has 10.1.1.5? Tell 10.1.1.4
+           |       |       |       |<======|        ARP reply
+           |       |       |       |======>|        ICMP (ping) request 0; src=10.1.1.4 next_hop=10.1.1.5
+           |       |       |       |<======|        ICMP (ping) reply 0; src=10.1.1.5 next_hop=10.1.1.4
+           |       |       |<======|       |        ICMP (ping) reply 0; src=10.1.1.4 next_hop=10.1.1.3
+           |       |<======|       |       |        ICMP (ping) reply 0; src=10.1.1.3 next_hop=10.1.1.2
+           |<======|       |       |       |        ICMP (ping) reply 0; src=10.1.1.2 next_hop=10.1.1.1
+           |       |       |       |<------|------> Hello
+           |<------|------>|       |       |        Hello
+   <-------|------>|       |       |       |        Hello
+           |       |<------|------>|       |        Hello
+           |======>|       |       |       |        ICMP (ping) request 1; src=10.1.1.1 next_hop=10.1.1.2
+           |       |       |<------|------>|        Hello
+           |       |======>|       |       |        ICMP (ping) request 1; src=10.1.1.2 next_hop=10.1.1.3
+           |       |       |======>|       |        ICMP (ping) request 1; src=10.1.1.3 next_hop=10.1.1.4
+           |       |       |       |======>|        ICMP (ping) request 1; src=10.1.1.4 next_hop=10.1.1.5
+           |       |       |       |<======|        ICMP (ping) reply 1; src=10.1.1.5 next_hop=10.1.1.4
+           |       |       |<======|       |        ICMP (ping) reply 1; src=10.1.1.4 next_hop=10.1.1.3
+           |       |<======|       |       |        ICMP (ping) reply 11; src=10.1.1.3 next_hop=10.1.1.2
+           |<======|       |       |       |        ICMP (ping) reply 1; src=10.1.1.2 next_hop=10.1.1.1
+           |       |       |       |<------|------> Hello
+           |<------|------>|       |       |        Hello
+   <-------|------>|       |       |       |        Hello
+           |       |       |<------|------>|        Hello
+           |       |<------|------>|       |        Hello
+           |======>|       |       |       |        ICMP (ping) request 2; src=10.1.1.1 next_hop=10.1.1.2
+           |       |======>|       |       |        ICMP (ping) request 2; src=10.1.1.2 next_hop=10.1.1.3
+           |       |       |======>|       |        ICMP (ping) request 2; src=10.1.1.3 next_hop=10.1.1.4
+           |       |       |       |======>|        ICMP (ping) request 2; src=10.1.1.4 next_hop=10.1.1.5
+           |       |       |       |<======|        ICMP (ping) reply 2; src=10.1.1.5 next_hop=10.1.1.4
+           |       |       |<======|       |        ICMP (ping) reply 2; src=10.1.1.4 next_hop=10.1.1.3
+           |       |<======|       |       |        ICMP (ping) reply 2; src=10.1.1.3 next_hop=10.1.1.2
+           |<======|       |       |       |        ICMP (ping) reply 2; src=10.1.1.2 next_hop=10.1.1.1
+           |       |       |       |<------|------> Hello
+   <-------|------>|       |       |       |        Hello
+           |       |<------|------>|       |        Hello
+           |<------|------>|       |       |        Hello
+           |       |       |<------|------>|        Hello
+           |======>|       |       |       |        ICMP (ping) request 3; src=10.1.1.1 next_hop=10.1.1.2
+           |       |======>|       |       |        ICMP (ping) request 3; src=10.1.1.2 next_hop=10.1.1.3
+           |       |       |======>|       |        ICMP (ping) request 3; src=10.1.1.3 next_hop=10.1.1.4
+           |       |       |       |======>|        ICMP (ping) request 3; src=10.1.1.4 next_hop=10.1.1.5
+           |       |       |       |<======|        ICMP (ping) reply 3; src=10.1.1.5 next_hop=10.1.1.4
+           |       |       |<======|       |        ICMP (ping) reply 3; src=10.1.1.4 next_hop=10.1.1.3
+           |       |<======|       |       |        ICMP (ping) reply 3; src=10.1.1.3 next_hop=10.1.1.2
+           |<======|       |       |       |        ICMP (ping) reply 3; src=10.1.1.2 next_hop=10.1.1.1
+           |       |       |       |<------|------> Hello
+   <-------|------>|       |       |       |        Hello
+           |<------|-->    |       |       |        Hello   |
+           |       |    <--|-->    |       |        Hello   |Node 3 move away => nobody hear his packets and node 3 doesn't hear anything !
+           |       |       |    <--|------>|        Hello   |
+           |======>|       |       |       |        ICMP (ping) request 4; src=10.1.1.1 next_hop=10.1.1.2
+           |       |==>    |       |       |        ICMP (ping) request 4; src=10.1.1.2 next_hop=10.1.1.3.   7 retries.
+           |<======|       |       |       |        RERR (unreachable dst 10.1.1.3 & 10.1.1.5) src=10.1.1.2
+           |       |       |       |<------|------> Hello
+   <-------|------>|       |       |       |        Hello
+           |<------|-->    |       |       |        Hello
+           |       |    <--|-->    |       |        Hello
+           |       |       |    <--|------>|        Hello
+   <-------|------>|       |       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, hop=0, ID=2, org_seqno=2) src = 10.1.1.1
+           |<------|-->    |       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, hop=1, ID=2, org_seqno=2) src = 10.1.1.2
+           |       |       |       |<------|------> Hello
+           |       |       |    <--|------>|        Hello
+           |       |    <--|-->    |       |        Hello
+           |<------|-->    |       |       |        Hello
+   <-------|------>|       |       |       |        Hello
+           |       |       |       |======>|        RERR (unreachable dst 10.1.1.1 & 10.1.1.3) src=10.1.1.4
+           |       |       |       |<------|------> Hello
+           |       |       |    <--|------>|        Hello
+           |       |    <--|-->    |       |        Hello
+           |<------|-->    |       |       |        Hello
+   <-------|------>|       |       |       |        Hello
+           |       |       |       |<------|------> Hello
+   <-------|------>|       |       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, hop=0, ID=4, org_seqno=3) src = 10.1.1.1
+           |<------|-->    |       |       |        RREQ (orig 10.1.1.1, dst 10.1.1.5, G=1, hop=1, ID=4, org_seqno=3) src = 10.1.1.2
+   .................................................
+   \endverbatim
+ */
+//clang-format on
+class ChainRegressionTest : public TestCase
+{
+  public:
+    /**
+     * Create test case
+     *
+     * \param prefix              Unique file names prefix
+     * \param size                Number of nodes in the chain
+     * \param time                Simulation time
+     * \param arpAliveTimeout     ARP alive timeout, this is used to check that ARP and routing do
+     * not interfere
+     */
+    ChainRegressionTest(const char* const prefix,
+                        Time time = Seconds(10),
+                        uint32_t size = 5,
+                        Time arpAliveTimeout = Seconds(120));
+    ~ChainRegressionTest() override;
+
+  private:
+    /// \internal It is important to have pointers here
+    NodeContainer* m_nodes;
+
+    /// PCAP file names prefix
+    const std::string m_prefix;
+    /// Total simulation time
+    const Time m_time;
+    /// Chain size
+    const uint32_t m_size;
+    /// Chain step, meters
+    const double m_step;
+    /// ARP alive timeout
+    const Time m_arpAliveTimeout;
+    /// Socket
+    Ptr<Socket> m_socket;
+    /// Sequence number
+    uint16_t m_seq;
+
+    /// Create test topology
+    void CreateNodes();
+    /// Create devices, install TCP/IP stack and applications
+    void CreateDevices();
+    /// Compare traces with reference ones
+    void CheckResults();
+    /// Go
+    void DoRun() override;
+    /// Send one ping
+    void SendPing();
+};
+
+#endif /* RAODV_REGRESSION_H */
diff --git a/src/raodv/test/raodv-test-suite.cc b/src/raodv/test/raodv-test-suite.cc
new file mode 100644
index 000000000..6d510820c
--- /dev/null
+++ b/src/raodv/test/raodv-test-suite.cc
@@ -0,0 +1,747 @@
+/*
+ * Copyright (c) 2009 IITP RAS
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors: Pavel Boyko <boyko@iitp.ru>
+ */
+#include "ns3/raodv-neighbor.h"
+#include "ns3/raodv-packet.h"
+#include "ns3/raodv-rqueue.h"
+#include "ns3/raodv-rtable.h"
+#include "ns3/ipv4-route.h"
+#include "ns3/test.h"
+
+namespace ns3
+{
+namespace raodv
+{
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for neighbors
+ */
+struct NeighborTest : public TestCase
+{
+    NeighborTest()
+        : TestCase("Neighbor"),
+          neighbor(nullptr)
+    {
+    }
+
+    void DoRun() override;
+    /**
+     * Handler test function
+     * \param addr the IPv4 address of the neighbor
+     */
+    void Handler(Ipv4Address addr);
+    /// Check timeout function 1
+    void CheckTimeout1();
+    /// Check timeout function 2
+    void CheckTimeout2();
+    /// Check timeout function 3
+    void CheckTimeout3();
+    /// The Neighbors
+    Neighbors* neighbor;
+};
+
+void
+NeighborTest::Handler(Ipv4Address addr)
+{
+}
+
+void
+NeighborTest::CheckTimeout1()
+{
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.2.3.4")), true, "Neighbor exists");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.1.1.1")), true, "Neighbor exists");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("2.2.2.2")), true, "Neighbor exists");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("3.3.3.3")), true, "Neighbor exists");
+}
+
+void
+NeighborTest::CheckTimeout2()
+{
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.2.3.4")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.1.1.1")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("2.2.2.2")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("3.3.3.3")), true, "Neighbor exists");
+}
+
+void
+NeighborTest::CheckTimeout3()
+{
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.2.3.4")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.1.1.1")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("2.2.2.2")),
+                          false,
+                          "Neighbor doesn't exist");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("3.3.3.3")),
+                          false,
+                          "Neighbor doesn't exist");
+}
+
+void
+NeighborTest::DoRun()
+{
+    Neighbors nb(Seconds(1));
+    neighbor = &nb;
+    neighbor->SetCallback(MakeCallback(&NeighborTest::Handler, this));
+    neighbor->Update(Ipv4Address("1.2.3.4"), Seconds(1));
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.2.3.4")), true, "Neighbor exists");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("4.3.2.1")),
+                          false,
+                          "Neighbor doesn't exist");
+    neighbor->Update(Ipv4Address("1.2.3.4"), Seconds(10));
+    NS_TEST_EXPECT_MSG_EQ(neighbor->IsNeighbor(Ipv4Address("1.2.3.4")), true, "Neighbor exists");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->GetExpireTime(Ipv4Address("1.2.3.4")),
+                          Seconds(10),
+                          "Known expire time");
+    NS_TEST_EXPECT_MSG_EQ(neighbor->GetExpireTime(Ipv4Address("4.3.2.1")),
+                          Seconds(0),
+                          "Known expire time");
+    neighbor->Update(Ipv4Address("1.1.1.1"), Seconds(5));
+    neighbor->Update(Ipv4Address("2.2.2.2"), Seconds(10));
+    neighbor->Update(Ipv4Address("3.3.3.3"), Seconds(20));
+
+    Simulator::Schedule(Seconds(2), &NeighborTest::CheckTimeout1, this);
+    Simulator::Schedule(Seconds(15), &NeighborTest::CheckTimeout2, this);
+    Simulator::Schedule(Seconds(30), &NeighborTest::CheckTimeout3, this);
+    Simulator::Run();
+    Simulator::Destroy();
+}
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Type header test case
+ */
+struct TypeHeaderTest : public TestCase
+{
+    TypeHeaderTest()
+        : TestCase("RAODV TypeHeader")
+    {
+    }
+
+    void DoRun() override
+    {
+        TypeHeader h(AODVTYPE_RREQ);
+        NS_TEST_EXPECT_MSG_EQ(h.IsValid(), true, "Default header is valid");
+        NS_TEST_EXPECT_MSG_EQ(h.Get(), AODVTYPE_RREQ, "Default header is RREQ");
+
+        Ptr<Packet> p = Create<Packet>();
+        p->AddHeader(h);
+        TypeHeader h2(AODVTYPE_RREP);
+        uint32_t bytes = p->RemoveHeader(h2);
+        NS_TEST_EXPECT_MSG_EQ(bytes, 1, "Type header is 1 byte long");
+        NS_TEST_EXPECT_MSG_EQ(h, h2, "Round trip serialization works");
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RREQ
+ */
+struct RreqHeaderTest : public TestCase
+{
+    RreqHeaderTest()
+        : TestCase("RAODV RREQ")
+    {
+    }
+
+    void DoRun() override
+    {
+        RreqHeader h(/*flags*/ 0,
+                     /*reserved*/ 0,
+                     /*hopCount*/ 6,
+                     /*requestID*/ 1,
+                     /*dst*/ Ipv4Address("1.2.3.4"),
+                     /*dstSeqNo*/ 40,
+                     /*origin*/ Ipv4Address("4.3.2.1"),
+                     /*originSeqNo*/ 10);
+        NS_TEST_EXPECT_MSG_EQ(h.GetGratuitousRrep(), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDestinationOnly(), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetHopCount(), 6, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetId(), 1, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDst(), Ipv4Address("1.2.3.4"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDstSeqno(), 40, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetOrigin(), Ipv4Address("4.3.2.1"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetOriginSeqno(), 10, "trivial");
+
+        h.SetGratuitousRrep(true);
+        NS_TEST_EXPECT_MSG_EQ(h.GetGratuitousRrep(), true, "trivial");
+        h.SetDestinationOnly(true);
+        NS_TEST_EXPECT_MSG_EQ(h.GetDestinationOnly(), true, "trivial");
+        h.SetUnknownSeqno(true);
+        NS_TEST_EXPECT_MSG_EQ(h.GetUnknownSeqno(), true, "trivial");
+        h.SetDst(Ipv4Address("1.1.1.1"));
+        NS_TEST_EXPECT_MSG_EQ(h.GetDst(), Ipv4Address("1.1.1.1"), "trivial");
+        h.SetDstSeqno(5);
+        NS_TEST_EXPECT_MSG_EQ(h.GetDstSeqno(), 5, "trivial");
+        h.SetHopCount(7);
+        NS_TEST_EXPECT_MSG_EQ(h.GetHopCount(), 7, "trivial");
+        h.SetId(55);
+        NS_TEST_EXPECT_MSG_EQ(h.GetId(), 55, "trivial");
+        h.SetOrigin(Ipv4Address("4.4.4.4"));
+        NS_TEST_EXPECT_MSG_EQ(h.GetOrigin(), Ipv4Address("4.4.4.4"), "trivial");
+        h.SetOriginSeqno(23);
+        NS_TEST_EXPECT_MSG_EQ(h.GetOriginSeqno(), 23, "trivial");
+
+        Ptr<Packet> p = Create<Packet>();
+        p->AddHeader(h);
+        RreqHeader h2;
+        uint32_t bytes = p->RemoveHeader(h2);
+        NS_TEST_EXPECT_MSG_EQ(bytes, 23, "RREP is 23 bytes long");
+        NS_TEST_EXPECT_MSG_EQ(h, h2, "Round trip serialization works");
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RREP
+ */
+struct RrepHeaderTest : public TestCase
+{
+    RrepHeaderTest()
+        : TestCase("RAODV RREP")
+    {
+    }
+
+    void DoRun() override
+    {
+        RrepHeader h(/*prefixSize*/ 0,
+                     /*hopCount*/ 12,
+                     /*dst*/ Ipv4Address("1.2.3.4"),
+                     /*dstSeqNo*/ 2,
+                     /*origin*/ Ipv4Address("4.3.2.1"),
+                     /*lifetime*/ Seconds(3));
+        NS_TEST_EXPECT_MSG_EQ(h.GetPrefixSize(), 0, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetHopCount(), 12, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDst(), Ipv4Address("1.2.3.4"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDstSeqno(), 2, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetOrigin(), Ipv4Address("4.3.2.1"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetLifeTime(), Seconds(3), "trivial");
+        h.SetDst(Ipv4Address("1.1.1.1"));
+        NS_TEST_EXPECT_MSG_EQ(h.GetDst(), Ipv4Address("1.1.1.1"), "trivial");
+        h.SetDstSeqno(123);
+        NS_TEST_EXPECT_MSG_EQ(h.GetDstSeqno(), 123, "trivial");
+        h.SetOrigin(Ipv4Address("4.4.4.4"));
+        NS_TEST_EXPECT_MSG_EQ(h.GetOrigin(), Ipv4Address("4.4.4.4"), "trivial");
+        h.SetLifeTime(MilliSeconds(1200));
+        NS_TEST_EXPECT_MSG_EQ(h.GetLifeTime(), MilliSeconds(1200), "trivial");
+        h.SetAckRequired(true);
+        NS_TEST_EXPECT_MSG_EQ(h.GetAckRequired(), true, "trivial");
+        h.SetAckRequired(false);
+        NS_TEST_EXPECT_MSG_EQ(h.GetAckRequired(), false, "trivial");
+        h.SetPrefixSize(2);
+        NS_TEST_EXPECT_MSG_EQ(h.GetPrefixSize(), 2, "trivial");
+        h.SetHopCount(15);
+        NS_TEST_EXPECT_MSG_EQ(h.GetHopCount(), 15, "trivial");
+
+        h.SetHello(Ipv4Address("10.0.0.2"), 9, Seconds(15));
+        NS_TEST_EXPECT_MSG_EQ(h.GetDst(), h.GetOrigin(), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDstSeqno(), 9, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetLifeTime(), Seconds(15), "trivial");
+
+        Ptr<Packet> p = Create<Packet>();
+        p->AddHeader(h);
+        RrepHeader h2;
+        uint32_t bytes = p->RemoveHeader(h2);
+        NS_TEST_EXPECT_MSG_EQ(bytes, 19, "RREP is 19 bytes long");
+        NS_TEST_EXPECT_MSG_EQ(h, h2, "Round trip serialization works");
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RREP-ACK
+ */
+struct RrepAckHeaderTest : public TestCase
+{
+    RrepAckHeaderTest()
+        : TestCase("RAODV RREP-ACK")
+    {
+    }
+
+    void DoRun() override
+    {
+        RrepAckHeader h;
+        Ptr<Packet> p = Create<Packet>();
+        p->AddHeader(h);
+        RrepAckHeader h2;
+        uint32_t bytes = p->RemoveHeader(h2);
+        NS_TEST_EXPECT_MSG_EQ(bytes, 1, "ACK is 1 byte long");
+        NS_TEST_EXPECT_MSG_EQ(h, h2, "Round trip serialization works");
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RERR
+ */
+struct RerrHeaderTest : public TestCase
+{
+    RerrHeaderTest()
+        : TestCase("RAODV RERR")
+    {
+    }
+
+    void DoRun() override
+    {
+        RerrHeader h;
+        h.SetNoDelete(true);
+        NS_TEST_EXPECT_MSG_EQ(h.GetNoDelete(), true, "trivial");
+        Ipv4Address dst("1.2.3.4");
+        NS_TEST_EXPECT_MSG_EQ(h.AddUnDestination(dst, 12), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDestCount(), 1, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.AddUnDestination(dst, 13), true, "trivial");
+        Ipv4Address dst2("4.3.2.1");
+        NS_TEST_EXPECT_MSG_EQ(h.AddUnDestination(dst2, 12), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetDestCount(), 2, "trivial");
+
+        Ptr<Packet> p = Create<Packet>();
+        p->AddHeader(h);
+        RerrHeader h2;
+        uint32_t bytes = p->RemoveHeader(h2);
+        NS_TEST_EXPECT_MSG_EQ(bytes, h.GetSerializedSize(), "(De)Serialized size match");
+        NS_TEST_EXPECT_MSG_EQ(h, h2, "Round trip serialization works");
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RAODV routing table entry
+ */
+struct QueueEntryTest : public TestCase
+{
+    QueueEntryTest()
+        : TestCase("QueueEntry")
+    {
+    }
+
+    /**
+     * Unicast test function
+     * \param route the IPv4 route
+     * \param packet the packet
+     * \param header the IPv4 header
+     */
+    void Unicast(Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header& header)
+    {
+    }
+
+    /**
+     * Error test function
+     * \param p The packet
+     * \param h The header
+     * \param e the socket error
+     */
+    void Error(Ptr<const Packet> p, const Ipv4Header& h, Socket::SocketErrno e)
+    {
+    }
+
+    /**
+     * Unicast 2 testfunction
+     * \param route The IPv4 route
+     * \param packet The packet
+     * \param header The header
+     */
+    void Unicast2(Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header& header)
+    {
+    }
+
+    /**
+     * Error2 test function
+     * \param p The packet
+     * \param h The header
+     * \param e the socket error
+     */
+    void Error2(Ptr<const Packet> p, const Ipv4Header& h, Socket::SocketErrno e)
+    {
+    }
+
+    void DoRun() override
+    {
+        Ptr<const Packet> packet = Create<Packet>();
+        Ipv4Header h;
+        h.SetDestination(Ipv4Address("1.2.3.4"));
+        h.SetSource(Ipv4Address("4.3.2.1"));
+        Ipv4RoutingProtocol::UnicastForwardCallback ucb =
+            MakeCallback(&QueueEntryTest::Unicast, this);
+        Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback(&QueueEntryTest::Error, this);
+        QueueEntry entry(packet, h, ucb, ecb, Seconds(1));
+        NS_TEST_EXPECT_MSG_EQ(h.GetDestination(),
+                              entry.GetIpv4Header().GetDestination(),
+                              "trivial");
+        NS_TEST_EXPECT_MSG_EQ(h.GetSource(), entry.GetIpv4Header().GetSource(), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(ucb.IsEqual(entry.GetUnicastForwardCallback()), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(ecb.IsEqual(entry.GetErrorCallback()), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(entry.GetExpireTime(), Seconds(1), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(entry.GetPacket(), packet, "trivial");
+        entry.SetExpireTime(Seconds(3));
+        NS_TEST_EXPECT_MSG_EQ(entry.GetExpireTime(), Seconds(3), "trivial");
+        Ipv4Header h2;
+        h2.SetDestination(Ipv4Address("1.1.1.1"));
+        entry.SetIpv4Header(h2);
+        NS_TEST_EXPECT_MSG_EQ(entry.GetIpv4Header().GetDestination(),
+                              Ipv4Address("1.1.1.1"),
+                              "trivial");
+        Ipv4RoutingProtocol::UnicastForwardCallback ucb2 =
+            MakeCallback(&QueueEntryTest::Unicast2, this);
+        Ipv4RoutingProtocol::ErrorCallback ecb2 = MakeCallback(&QueueEntryTest::Error2, this);
+        entry.SetErrorCallback(ecb2);
+        NS_TEST_EXPECT_MSG_EQ(ecb2.IsEqual(entry.GetErrorCallback()), true, "trivial");
+        entry.SetUnicastForwardCallback(ucb2);
+        NS_TEST_EXPECT_MSG_EQ(ucb2.IsEqual(entry.GetUnicastForwardCallback()), true, "trivial");
+    }
+};
+
+//-----------------------------------------------------------------------------
+/// Unit test for RequestQueue
+struct RAodvRqueueTest : public TestCase
+{
+    RAodvRqueueTest()
+        : TestCase("Rqueue"),
+          q(64, Seconds(30))
+    {
+    }
+
+    void DoRun() override;
+
+    /**
+     * Unicast test function
+     * \param route the IPv4 route
+     * \param packet the packet
+     * \param header the IPv4 header
+     */
+    void Unicast(Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header& header)
+    {
+    }
+
+    /**
+     * Error test function
+     * \param p The packet
+     * \param h The header
+     * \param e the socket error
+     */
+    void Error(Ptr<const Packet> p, const Ipv4Header& h, Socket::SocketErrno e)
+    {
+    }
+
+    /// Check size limit function
+    void CheckSizeLimit();
+    /// Check timeout function
+    void CheckTimeout();
+
+    /// Request queue
+    RequestQueue q;
+};
+
+void
+RAodvRqueueTest::DoRun()
+{
+    NS_TEST_EXPECT_MSG_EQ(q.GetMaxQueueLen(), 64, "trivial");
+    q.SetMaxQueueLen(32);
+    NS_TEST_EXPECT_MSG_EQ(q.GetMaxQueueLen(), 32, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.GetQueueTimeout(), Seconds(30), "trivial");
+    q.SetQueueTimeout(Seconds(10));
+    NS_TEST_EXPECT_MSG_EQ(q.GetQueueTimeout(), Seconds(10), "trivial");
+
+    Ptr<const Packet> packet = Create<Packet>();
+    Ipv4Header h;
+    h.SetDestination(Ipv4Address("1.2.3.4"));
+    h.SetSource(Ipv4Address("4.3.2.1"));
+    Ipv4RoutingProtocol::UnicastForwardCallback ucb = MakeCallback(&RAodvRqueueTest::Unicast, this);
+    Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback(&RAodvRqueueTest::Error, this);
+    QueueEntry e1(packet, h, ucb, ecb, Seconds(1));
+    q.Enqueue(e1);
+    q.Enqueue(e1);
+    q.Enqueue(e1);
+    NS_TEST_EXPECT_MSG_EQ(q.Find(Ipv4Address("1.2.3.4")), true, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.Find(Ipv4Address("1.1.1.1")), false, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 1, "trivial");
+    q.DropPacketWithDst(Ipv4Address("1.2.3.4"));
+    NS_TEST_EXPECT_MSG_EQ(q.Find(Ipv4Address("1.2.3.4")), false, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 0, "trivial");
+
+    h.SetDestination(Ipv4Address("2.2.2.2"));
+    QueueEntry e2(packet, h, ucb, ecb, Seconds(1));
+    q.Enqueue(e1);
+    q.Enqueue(e2);
+    Ptr<Packet> packet2 = Create<Packet>();
+    QueueEntry e3(packet2, h, ucb, ecb, Seconds(1));
+    NS_TEST_EXPECT_MSG_EQ(q.Dequeue(Ipv4Address("3.3.3.3"), e3), false, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.Dequeue(Ipv4Address("2.2.2.2"), e3), true, "trivial");
+    NS_TEST_EXPECT_MSG_EQ(q.Find(Ipv4Address("2.2.2.2")), false, "trivial");
+    q.Enqueue(e2);
+    q.Enqueue(e3);
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 2, "trivial");
+    Ptr<Packet> packet4 = Create<Packet>();
+    h.SetDestination(Ipv4Address("1.2.3.4"));
+    QueueEntry e4(packet4, h, ucb, ecb, Seconds(20));
+    q.Enqueue(e4);
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 3, "trivial");
+    q.DropPacketWithDst(Ipv4Address("1.2.3.4"));
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 1, "trivial");
+
+    CheckSizeLimit();
+
+    Ipv4Header header2;
+    Ipv4Address dst2("1.2.3.4");
+    header2.SetDestination(dst2);
+
+    Simulator::Schedule(q.GetQueueTimeout() + Seconds(1), &RAodvRqueueTest::CheckTimeout, this);
+
+    Simulator::Run();
+    Simulator::Destroy();
+}
+
+void
+RAodvRqueueTest::CheckSizeLimit()
+{
+    Ptr<Packet> packet = Create<Packet>();
+    Ipv4Header header;
+    Ipv4RoutingProtocol::UnicastForwardCallback ucb = MakeCallback(&RAodvRqueueTest::Unicast, this);
+    Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback(&RAodvRqueueTest::Error, this);
+    QueueEntry e1(packet, header, ucb, ecb, Seconds(1));
+
+    for (uint32_t i = 0; i < q.GetMaxQueueLen(); ++i)
+    {
+        q.Enqueue(e1);
+    }
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 2, "trivial");
+
+    for (uint32_t i = 0; i < q.GetMaxQueueLen(); ++i)
+    {
+        q.Enqueue(e1);
+    }
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 2, "trivial");
+}
+
+void
+RAodvRqueueTest::CheckTimeout()
+{
+    NS_TEST_EXPECT_MSG_EQ(q.GetSize(), 0, "Must be empty now");
+}
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RAODV routing table entry
+ */
+struct RAodvRtableEntryTest : public TestCase
+{
+    RAodvRtableEntryTest()
+        : TestCase("RtableEntry")
+    {
+    }
+
+    void DoRun() override
+    {
+        Ptr<NetDevice> dev;
+        Ipv4InterfaceAddress iface;
+        RoutingTableEntry rt(/*output device*/ dev,
+                             /*dst*/ Ipv4Address("1.2.3.4"),
+                             /*validSeqNo*/ true,
+                             /*seqNo*/ 10,
+                             /*interface*/ iface,
+                             /*hop*/ 5,
+                             /*next hop*/ Ipv4Address("3.3.3.3"),
+                             /*lifetime*/ Seconds(10));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetOutputDevice(), dev, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetDestination(), Ipv4Address("1.2.3.4"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetValidSeqNo(), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetSeqNo(), 10, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetInterface(), iface, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetHop(), 5, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetNextHop(), Ipv4Address("3.3.3.3"), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetLifeTime(), Seconds(10), "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetFlag(), VALID, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetRreqCnt(), 0, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.IsPrecursorListEmpty(), true, "trivial");
+
+        Ptr<NetDevice> dev2;
+        Ipv4InterfaceAddress iface2;
+        rt.SetOutputDevice(dev2);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetOutputDevice(), dev2, "trivial");
+        rt.SetInterface(iface2);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetInterface(), iface2, "trivial");
+        rt.SetValidSeqNo(false);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetValidSeqNo(), false, "trivial");
+        rt.SetFlag(INVALID);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetFlag(), INVALID, "trivial");
+        rt.SetFlag(IN_SEARCH);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetFlag(), IN_SEARCH, "trivial");
+        rt.SetHop(12);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetHop(), 12, "trivial");
+        rt.SetLifeTime(Seconds(1));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetLifeTime(), Seconds(1), "trivial");
+        rt.SetNextHop(Ipv4Address("1.1.1.1"));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetNextHop(), Ipv4Address("1.1.1.1"), "trivial");
+        rt.SetUnidirectional(true);
+        NS_TEST_EXPECT_MSG_EQ(rt.IsUnidirectional(), true, "trivial");
+        rt.SetBlacklistTimeout(Seconds(7));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetBlacklistTimeout(), Seconds(7), "trivial");
+        rt.SetRreqCnt(2);
+        NS_TEST_EXPECT_MSG_EQ(rt.GetRreqCnt(), 2, "trivial");
+        rt.IncrementRreqCnt();
+        NS_TEST_EXPECT_MSG_EQ(rt.GetRreqCnt(), 3, "trivial");
+        rt.Invalidate(Seconds(13));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetFlag(), INVALID, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetLifeTime(), Seconds(13), "trivial");
+        rt.SetLifeTime(MilliSeconds(100));
+        NS_TEST_EXPECT_MSG_EQ(rt.GetLifeTime(), MilliSeconds(100), "trivial");
+        Ptr<Ipv4Route> route = rt.GetRoute();
+        NS_TEST_EXPECT_MSG_EQ(route->GetDestination(), Ipv4Address("1.2.3.4"), "trivial");
+
+        NS_TEST_EXPECT_MSG_EQ(rt.InsertPrecursor(Ipv4Address("10.0.0.1")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.IsPrecursorListEmpty(), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.InsertPrecursor(Ipv4Address("10.0.0.2")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.InsertPrecursor(Ipv4Address("10.0.0.2")), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.LookupPrecursor(Ipv4Address("10.0.0.3")), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.LookupPrecursor(Ipv4Address("10.0.0.1")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.DeletePrecursor(Ipv4Address("10.0.0.2")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.LookupPrecursor(Ipv4Address("10.0.0.2")), false, "trivial");
+        std::vector<Ipv4Address> prec;
+        rt.GetPrecursors(prec);
+        NS_TEST_EXPECT_MSG_EQ(prec.size(), 1, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.InsertPrecursor(Ipv4Address("10.0.0.4")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.DeletePrecursor(Ipv4Address("10.0.0.5")), false, "trivial");
+        rt.GetPrecursors(prec);
+        NS_TEST_EXPECT_MSG_EQ(prec.size(), 2, "trivial");
+        rt.DeleteAllPrecursors();
+        NS_TEST_EXPECT_MSG_EQ(rt.IsPrecursorListEmpty(), true, "trivial");
+        rt.GetPrecursors(prec);
+        NS_TEST_EXPECT_MSG_EQ(prec.size(), 2, "trivial");
+        Simulator::Destroy();
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief Unit test for RAODV routing table
+ */
+struct RAodvRtableTest : public TestCase
+{
+    RAodvRtableTest()
+        : TestCase("Rtable")
+    {
+    }
+
+    void DoRun() override
+    {
+        RoutingTable rtable(Seconds(2));
+        NS_TEST_EXPECT_MSG_EQ(rtable.GetBadLinkLifetime(), Seconds(2), "trivial");
+        rtable.SetBadLinkLifetime(Seconds(1));
+        NS_TEST_EXPECT_MSG_EQ(rtable.GetBadLinkLifetime(), Seconds(1), "trivial");
+        Ptr<NetDevice> dev;
+        Ipv4InterfaceAddress iface;
+        RoutingTableEntry rt(/*output device*/ dev,
+                             /*dst*/ Ipv4Address("1.2.3.4"),
+                             /*validSeqNo*/ true,
+                             /*seqNo*/ 10,
+                             /*interface*/ iface,
+                             /*hop*/ 5,
+                             /*next hop*/ Ipv4Address("1.1.1.1"),
+                             /*lifetime*/ Seconds(10));
+        NS_TEST_EXPECT_MSG_EQ(rtable.AddRoute(rt), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.AddRoute(rt), false, "trivial");
+        RoutingTableEntry rt2(/*output device*/ dev,
+                              /*dst*/ Ipv4Address("4.3.2.1"),
+                              /*validSeqNo*/ false,
+                              /*seqNo*/ 0,
+                              /*interface*/ iface,
+                              /*hop*/ 15,
+                              /*next hop*/ Ipv4Address("1.1.1.1"),
+                              /*lifetime*/ Seconds(1));
+        NS_TEST_EXPECT_MSG_EQ(rtable.AddRoute(rt2), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.LookupRoute(rt2.GetDestination(), rt), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt2.GetDestination(), rt.GetDestination(), "trivial");
+        rt.SetHop(20);
+        rt.InsertPrecursor(Ipv4Address("10.0.0.3"));
+        NS_TEST_EXPECT_MSG_EQ(rtable.Update(rt), true, "trivial");
+        RoutingTableEntry rt3;
+        NS_TEST_EXPECT_MSG_EQ(rtable.LookupRoute(Ipv4Address("10.0.0.1"), rt), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.Update(rt3), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.SetEntryState(Ipv4Address("10.0.0.1"), INVALID),
+                              false,
+                              "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.SetEntryState(Ipv4Address("1.2.3.4"), IN_SEARCH),
+                              true,
+                              "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.DeleteRoute(Ipv4Address("5.5.5.5")), false, "trivial");
+        RoutingTableEntry rt4(/*output device*/ dev,
+                              /*dst*/ Ipv4Address("5.5.5.5"),
+                              /*validSeqNo*/ false,
+                              /*seqNo*/ 0,
+                              /*interface*/ iface,
+                              /*hop*/ 15,
+                              /*next hop*/ Ipv4Address("1.1.1.1"),
+                              /*lifetime*/ Seconds(-10));
+        NS_TEST_EXPECT_MSG_EQ(rtable.AddRoute(rt4), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.SetEntryState(Ipv4Address("5.5.5.5"), INVALID),
+                              true,
+                              "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.LookupRoute(Ipv4Address("5.5.5.5"), rt), false, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.MarkLinkAsUnidirectional(Ipv4Address("1.2.3.4"), Seconds(2)),
+                              true,
+                              "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.LookupRoute(Ipv4Address("1.2.3.4"), rt), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.IsUnidirectional(), true, "trivial");
+        rt.SetLifeTime(Seconds(-5));
+        NS_TEST_EXPECT_MSG_EQ(rtable.Update(rt), true, "trivial");
+        std::map<Ipv4Address, uint32_t> unreachable;
+        rtable.GetListOfDestinationWithNextHop(Ipv4Address("1.1.1.1"), unreachable);
+        NS_TEST_EXPECT_MSG_EQ(unreachable.size(), 2, "trivial");
+        unreachable.insert(std::make_pair(Ipv4Address("4.3.2.1"), 3));
+        rtable.InvalidateRoutesWithDst(unreachable);
+        NS_TEST_EXPECT_MSG_EQ(rtable.LookupRoute(Ipv4Address("4.3.2.1"), rt), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rt.GetFlag(), INVALID, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.DeleteRoute(Ipv4Address("1.2.3.4")), true, "trivial");
+        NS_TEST_EXPECT_MSG_EQ(rtable.DeleteRoute(Ipv4Address("1.2.3.4")), false, "trivial");
+        Simulator::Destroy();
+    }
+};
+
+/**
+ * \ingroup raodv-test
+ *
+ * \brief RAODV test suite
+ */
+class RAodvTestSuite : public TestSuite
+{
+  public:
+    RAodvTestSuite()
+        : TestSuite("routing-raodv", Type::UNIT)
+    {
+        AddTestCase(new NeighborTest, TestCase::Duration::QUICK);
+        AddTestCase(new TypeHeaderTest, TestCase::Duration::QUICK);
+        AddTestCase(new RreqHeaderTest, TestCase::Duration::QUICK);
+        AddTestCase(new RrepHeaderTest, TestCase::Duration::QUICK);
+        AddTestCase(new RrepAckHeaderTest, TestCase::Duration::QUICK);
+        AddTestCase(new RerrHeaderTest, TestCase::Duration::QUICK);
+        AddTestCase(new QueueEntryTest, TestCase::Duration::QUICK);
+        AddTestCase(new RAodvRqueueTest, TestCase::Duration::QUICK);
+        AddTestCase(new RAodvRtableEntryTest, TestCase::Duration::QUICK);
+        AddTestCase(new RAodvRtableTest, TestCase::Duration::QUICK);
+    }
+} g_raodvTestSuite; ///< the test suite
+
+} // namespace raodv
+} // namespace ns3
diff --git a/ztestcmd.txt b/ztestcmd.txt
new file mode 100644
index 000000000..1c5a53e7a
--- /dev/null
+++ b/ztestcmd.txt
@@ -0,0 +1,22 @@
+./ns3 run scratch/manet-routing-compare
+
+./ns3 run scratch/aodv-example
+
+./ns3 run scratch/raodv-example
+
+./ns3 run scratch/aodv-analysis
+
+./ns3 run "scratch/aodv-analysis --nodeCount=10 --packetsPerSecond=5 --nodeSpeed=15"
+
+./ns3 run "scratch/aodv-analysis --PrintHelp"
+
+mergecap -w merged_output.pcap *.pcap
+wireshark merged_output.pcap
+
+
+
+
+mkdir -p ./scratch/results
+rm -rf ./scratch/results/*
+
+rm -rf ./scratch/statistics
